<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">

		<!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame
		Remove this if you use the .htaccess -->
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

		<title>Watson</title>

		<link rel='stylesheet' href='css/generalmedia.css'>
		<meta name="description" content="">
		<meta name="author" content="Burt">

		<meta name="viewport" content="width=device-width; initial-scale=1.0">

	</head>

	<body>
		<div id="wrapper">
			<!-- Header division -->

			<div id="header">
				<a href="index.html"><h3 style="margin:0; color: white;">CHAPTER 9:FUNCTIONAL, LOGICAL, AND OBJECT-ORIENTED PROGRAMMING</h3></a>
			</div>
			<!-- End header -->

			<!-- Navbar division -->

			<div id="nav">
				<table style="width: 100%" cellspacing="2" cellpadding="2">

					<tr style="background-color: #E31B23;">

						<td style="width: 25%"><a href="labs.html">LABS</a></td>

						<td style="width: 25%"><a href="documentation.html">DOCUMENTATION</a></td>

						<td style="width: 25%"><a href="tutorials.html">TUTORIALS</a></td>

						<td style="width: 25%"><a href="about.html">ABOUT</a></td>

					</tr>

				</table>

			</div><!-- End nav -->

			<div id="nav">
				<table style="width: 100%" cellspacing="2" cellpadding="2">

					<tr style="background-color: #E31B23;">

						<td style="width: 15%"><a href="chapters.html">CHAPTERS</a></td>

						<td style="width: 5%"><a href="ch01.html">01</a></td>

						<td style="width: 5%"><a href="ch02.html">02</a></td>

						<td style="width: 5%"><a href="ch03.html">03</a></td>

						<td style="width: 5%"><a href="ch04.html">04</a></td>

						<td style="width: 5%"><a href="ch05.html">05</a></td>

						<td style="width: 5%"><a href="ch06.html">06</a></td>

						<td style="width: 5%"><a href="ch07.html">07</a></td>

						<td style="width: 5%"><a href="ch08.html">08</a></td>

						<td style="width: 5%"><a href="ch09.html">09</a></td>

						<td style="width: 5%"><a href="ch10.html">10</a></td>

						<td style="width: 5%"><a href="ch11.html">11</a></td>

						<td style="width: 5%"><a href="ch12.html">12</a></td>

						<td style="width: 5%"><a href="ch13.html">13</a></td>

						<td style="width: 5%"><a href="ch14.html">14</a></td>

						<td style="width: 5%"><a href="ch15.html">15</a></td>

					</tr>

				</table>

			</div>
			<!-- End nav -->

			<!-- Main content -->
			<p class="Section">
				Chapter 9  Functional, Logical, and Object-Oriented Programming
			</p>

			<p class="Section">
				9.1  Introduction
			</p>

			<p>
				This chapter continues our study of programming by introducing three different approaches to the problem solving process.  Section 9.2 discusses functional programming, in which computer programs are viewed as “functions” to be computed, rather than as sequences of commands to be executed.  Section 9.3 introduces declarative programming, which views programs as a collection of declarations – true statements of two types: facts and rules.  Section 9.4 discusses object-oriented programming, in which programs are viewed as a collection of objects.  Coordinated action is carried out by the exchange of messages between objects.
			</p>

			<p>
				Imperative programming (discussed in the previous chapter), functional programming, and declarative programming are each considered to be distinct programming paradigms.  Object-oriented constructs and behaviors are often viewed as higher-level organizational attributes that can be incorporated into each of the three basic paradigms, rather than as a separate programming paradigm unto itself.
			</p>

			<p>
				Over the past decade, object-oriented concepts have revolutionized programming languages.  In fact, the vast majority of widely used programming languages are now object-oriented, including C++, Java, and Visual Basic.   While functional and logical programming have not made nearly as deep a mark on mainstream programming as object-oriented programming, these two paradigms are used in various sub-disciplines of computer science, such as artificial intelligence.  Despite their rather limited use at the present time, study of functional and logical programming will help you to see that the imperative paradigm is but one approach to writing computer programs.
			</p>

			<p class="Section">
				9.2 Functional programming
			</p>

			<p>
				Whereas the imperative programming paradigm views a program as a list of commands to be executed, the <span class="Bolded">functional programming </span>paradigm views a program as a sequence of function calls that transform one or more inputs into the desired output.  
			</p>

			<div class="Standard">
				In this section we will concentrate on Lisp, the best known and most commonly used functional language.  <span class="Bolded">Lisp</span> is a LISt Processing language.  First developed in 1958 by John McCarthy, Lisp is the second oldest programming language still in widespread use.<span class="Footnote"><span class="Footnote_20_anchor" title="Footnote: The oldest high-level language still in widespread use today is FORTRAN, though like LISP modern dialects of FORTRAN contain many features absent from earlier versions."><a href="#ftn1" id="body_ftn1">1</a></span></span>  Though the language has changed somewhat over the years, our presentation concentrates on some of the core features of Lisp that have remain unchanged for many years.
			</div>

			<p>
				Lisp is a functional recursive language.  This means that programs are collections of functions, where the individual functions tend to use recursion, rather than iteration, to implement repetition.  Another difference between Lisp and the traditional imperative languages is that Lisp makes no distinction between programs structures and data structures – both are lists.  
			</p>

			<p>
				One of the most striking differences between Lisp and traditional imperative languages is that the use of assignment operations – where a value is computed and then “stored” in a variable – is strongly discouraged.  In fact, Lisp doesn’t even include variable declaration statements, such a “<span class="Subfigure">Var I : integer;</span>” that are a standard feature of most imperative languages.  While the idea of programming without using assignments statements may sound incredible, once you “wrap your head around” the functional way of approaching problems, you will find it possible create quite compact programs capable of complex behaviors.
			</p>

			<p>
				If all of this sounds a bit intimidating, don’t be put off, Lisp is actually quite a simple (albeit powerful) little language that is very easy to learn.  
			</p>

			<p>
				Let’s begin our study of Lisp by defining what a list is.  A Lisp <span class="Bolded">list</span> is a sequence of three things: (1) an open parenthesis, (2) zero or more atoms or lists, and (3) a close parenthesis.  This, definition of “list” begs the question, “What is an atom?”.  A Lisp <span class="Bolded">atom</span> is an indivisible object.  There are two kinds of atoms in Lisp: numeric atoms and symbolic atoms.  <span class="Bolded">Numeric atoms</span> are simply numbers, both integer and real, like “<span class="Subfigure">27</span>”or “<span class="Subfigure">3.14159</span>”.  <span class="Bolded">Symbolic atoms</span>, also called symbols, consist of a string of one or more characters that do not include spaces.  For example: “<span class="Subfigure">green</span>”, “<span class="Subfigure">name</span>”, “<span class="Subfigure">+</span>”, and “<span class="Subfigure">age</span>” are valid symbols.  Various dialects of Lisp may impose additional constraints on naming symbols, such as preventing symbolic atoms from beginning with a number or forbidding certain non-alphabetic characters.
			</p>

			<p>
				The following:
			</p>
			<p class="Subfigure">
				(this is a list of 7 atoms)
			</p>

			<p>
				is a valid Lisp list that consists of seven atoms enclosed within parentheses.  The first element of the list is the symbolic atom “<span class="Subfigure">this</span>”, the second element of the list is the symbolic atom “<span class="Subfigure">is</span>”, and the third element is the symbol “<span class="Subfigure">a</span>”.  The sixth element of the list is the numeric atom “<span class="Subfigure">7</span>”.
			</p>

			<p>
				The following are not valid Lisp lists:
			</p>
			<p class="Subfigure">
				 
			</p>
			<p class="Subfigure">
				I
			</p>
			<p class="Subfigure">
				do not like green eggs and ham
			</p>
			<p class="Subfigure">
				I will not eat them in the rain
			</p>
			<p class="Subfigure">
				( I will not eat them on a train
			</p>
			<p class="Subfigure">
				I do not like them Sam I am.)
			</p>
			<p class="Subfigure">
				 
			</p>
			<p>
				The first example, “<span class="Subfigure">I</span>”, is an atom, not a list.  The remaining four examples are neither atoms nor lists.  The second, third, and fourth examples are missing either or both of the required parentheses.  The fifth example contains the punctuation mark “.” which is neither a valid symbol, nor a valid number.
			</p>

			<p>
				Here is another valid list:
			</p>

			<p class="Subfigure">
				<span class="Emphasized"> </span>(((a list) within a list) within another list)
			</p>

			<p>
				This list is different from our first valid list in that some of its elements are lists.  In fact, the first element of this list is the list  “<span class="Subfigure">((a list) within a list)</span>”.  The second element is the symbolic atom “<span class="Subfigure">within</span>”, the third element is the symbolic atom “<span class="Subfigure">another</span>”, and the final element is the symbolic atom “<span class="Subfigure">list</span>”.  
			</p>

			<p>
				The first element of this list, “<span class="Subfigure">((a list) within a list)</span>”, can be further decomposed.  Its first element is itself the list “<span class="Subfigure">(a list)</span>”.  Its second element is the symbol “<span class="Subfigure">within</span>”, its third element is the symbol “<span class="Subfigure">a</span>”, and its last element is the atom “<span class="Subfigure">list</span>”.
			</p>

			<p>
				As can be seen in Figure 9.1, Lisp lists are represented internally using a tree-like structure of nodes.  Each node has two pointers, a left pointer and a right pointer.  The left pointer points to a list element (which can be either an atom or another list) and the right pointer points to the remainder of the list.  The right pointer of the very last node of every list contains a special value, known as nil.  <span class="Bolded">Nil</span>, sometimes indicated by the Greek letter <span class="Subfigure">λ</span>, is used to indicate both the end of a list and also an “empty list”.  In addition to the Greek letter lambda and the word “nil”, the empty list can also be written as an open parenthesis followed immediately by a close parenthesis,“<span class="Subfigure">()</span>”.  Nil is the only construct in Lisp that is considered to be both a list and an atom.<span class="Subfigure"> </span>
			</p>

			<h1>INSERT MISSINGOBJECT HERE</h1>
				
			<p class="Figure">
				Figure 9.1 :  Internal representation of the list <span class="Subfigure">(this is a list)</span>
			</p>

			<h1>INSERT MISSINGOBJECT HERE</h1>

			<p class="Figure">
				Figure 9.2 :  Internal representation of <span class="Subfigure">((this is a list) within a list)</span>
			</p>

			<p>
				Figure 9.2 illustrates the internal representation of another list.  This list includes a sublist as its first element.  Lisp lists may contain an arbitrary number of sublists arranged in any order and “nested” to an arbitrary depth.  The only rule is that for every open parenthesis there must be a matching close parenthesis. This ability of lists to contain arbitrary numbers of sublists is one of the features of Lisp that give the language such flexibility.
			</p>

			<p>
				Now that we have an understanding of how Lisp represents data, we can turn our attention to how it represents programs, or procedures.  Here is a procedure for adding the numbers “<span class="Subfigure">5</span>” and “<span class="Subfigure">3</span>”, which when run returns the value “<span class="Subfigure">8</span>”.
			</p>

			<p class="Subfigure">
				(+ 5 3)
			</p>

			<p>
				A <span class="Bolded">Lisp procedure</span> is a list that specifies a function to be computed.  The first element of every procedure list is an atom that specifies the name of the function to be executed.  This function can be either a built-in function, like addition, in the above example; or a programmer-defined function.  The other elements of the procedure list specify the arguments, or inputs, to the procedure.    In the above example, these inputs are the numeric atoms (i.e., numbers) “<span class="Subfigure">5</span>” and “<span class="Subfigure">3</span>”.  In general, the arguments to a procedure may be either lists or atoms.  Because the name of the function is always the first thing in the procedure list, Lisp procedures are said to be expressed in <span class="Bolded">prefix notation</span>, rather than in the more standard infix notation, where the operator appears between the operands (e.g., <span class="Subfigure">5 + 3</span>).
			</p>
			
			<h1>INSERT MISSINGOBJECT HERE</h1>

			<p class="Figure">
				Figure 9.3 :  Internal representation of <span class="Subfigure">(* (+ 1 2) (- 7 3))</span>
			</p>

			<p>
				Here is another example of a Lisp procedure that uses built-in functions:
			</p>

			<p class="Subfigure">
				(* (+ 1 2) (- 7 3))
			</p>

			<p>
				In order to emphasize the fact that this procedure is a valid Lisp list, its internal representation is illustrated in Figure 9.3.
			</p>

			<p>
				As is generally the case with parenthesized mathematical expressions, expressions in Lisp are evaluated starting with the inner most set of parentheses, working outward; with parenthesized expressions at the same “level” evaluated from left to right.  In the above example, the multiplication operator is to be applied to the results of an addition operation (“<span class="Subfigure">1</span>” plus “<span class="Subfigure">2</span>”) and a subtraction operation (“<span class="Subfigure">7</span>” minus “<span class="Subfigure">3</span>”).   The expression is evaluated in the following way.  First, the sub-expression <span class="Subfigure">(+ 1 2)</span> is evaluated giving“<span class="Subfigure">3</span>” for an overall expression of <span class="Subfigure">(* 3 (-7 3))</span>.  Next, the second sub-expression <span class="Subfigure">(- 7 3)</span> is evaluated, giving “<span class="Subfigure">4</span>” and an overall expression of <span class="Subfigure">(* 3 4)</span>.  Finally, the multiplication operation is performed on <span class="Subfigure">(* 3 4)</span> giving the final result, “<span class="Subfigure">12</span>”.
			</p>

			<p>
				As you may have surmised by now, Lisp contains all of the basic mathematical operators that you would expect, such as addition, subtraction, multiplication, and division; as well as various ‘advanced’ operators.   The expression evaluation pattern seen above, where the operation that is specified first is actually applied last is typical of Lisp – and, as we will see shortly, not just for procedures involving mathematical operators, but for all Lisp procedures.
			</p>

			<p>
				At this point you may be asking yourself how Lisp knows whether a list represents data or program, since a list can contain either.  The answer is that all lists are assumed to be procedures, unless explicit measures are taken to inform Lisp that a list represents data.
			</p>

			<p>
				The most common way of informing Lisp that a list is to be treated as data is to “quote” the list.  <span class="Bolded">Quote</span> is a built-in procedure that accepts an atom or list as input and returns the input as the output.  For example, <span class="Subfigure">(quote </span><span class="T11">(this is a list)</span><span class="Subfigure">) </span>will return <span class="T11">(this is a list)</span>.  Likewise <span class="Subfigure">(quote </span><span class="T11">(a list (containing a list))</span><span class="Subfigure">) </span>evaluates to the list: <span class="T11">(a list (containing a list))</span>.  Finally, <span class="Subfigure">(quote </span><span class="T11">a</span><span class="Subfigure">)</span> will return the atom “<span class="T11">a</span>”.  In general, <span class="Subfigure">quote</span> will return the second element in its list, regardless of whether that element is a list or an atom.
			</p>
			<p>
				   
			</p>
			<p>
				If the <span class="Subfigure">quote</span> procedure seems a bit silly, remember that its primary function is to demark where executable code ends and data begins.  Without <span class="Subfigure">quote</span>, Lisp would attempt to evaluate lists such as <span class="Subfigure">(this is a list)</span> by applying the “<span class="Subfigure">this</span>” procedure to the values associated with the atoms “<span class="Subfigure">is</span>”, “<span class="Subfigure">a</span>”, and “<span class="Subfigure">list</span>” – even if no such procedure had been defined.
			</p>

			<p>
				Since <span class="Subfigure">quote</span> is used frequently in Lisp programs, most versions of the language include one of more “shorthand notations” for expressing this important function.  One shorthand involves replacing the word <span class="Subfigure">quote</span> and the outer set of parentheses with the symbol  <span class="Subfigure">'</span>, thus the expressions   <span class="Subfigure">'</span><span class="T11">(a quoted list)</span><span class="Subfigure"> </span>and<span class="Subfigure"> (quote </span><span class="T11">(a quoted list)</span><span class="Subfigure">)</span> both evaluate to <span class="T11">(a quoted list)</span>.  Another common shorthand for <span class="Subfigure">quote</span> involves enclosing the atom or list to be quoted in double quote marks.  Thus, the expression   <span class="Subfigure">"</span><span class="T11">(a quoted list)</span><span class="Subfigure">"</span>  is equivalent to  <span class="Subfigure">(quote </span><span class="T11">(a quoted list)</span><span class="Subfigure">) </span> in many dialects of Lisp.
			</p>

			<p>
				Although, as we have seen, it is possible to do math in Lisp, the primary focus of the language is list processing.  Thus, a rather large number of primitives exist in the language for tearing down, building up, and otherwise manipulating lists.  In the remainder of this section we will look several of the most common Lisp primitives.
			</p>

			<p>
				One of the most basic Lisp operators is “<span class="Subfigure">car</span>”.  The <span class="Subfigure">car</span> procedure accepts a list as input and returns the first element of that list as output.  So, for example:
			</p>

			<p class="Figure">
				<span class="Subfigure">(car (quote</span><span class="T11">(this is a list)</span><span class="Subfigure">) )</span>
			</p>

			<p>
				returns the atom “<span class="T11">this</span>” which is the first element of the list.
			</p>
			<p class="Figure">
				<span class="Subfigure">(car (quote</span><span class="T11">(this is a list)</span><span class="Subfigure">) )</span>
			</p>

			<h1>INSERT MISSINGOBJECT HERE</h1>

			<p class="Figure">
				Figure 9.4:   An illustration of the <span class="Subfigure">car</span> operator
			</p>

			<p>
				Figure 9.4 illustrates the action of the <span class="Subfigure">car</span> operator on a simple list of atoms.  Notice that this example uses the <span class="Subfigure">quote</span> operator to tell Lisp where the data for <span class="Subfigure">car</span> begins.  If we had failed to quote the data and instead written an expression such as:
			</p>

			<p class="Subfigure">
				(car (this is a list))
			</p>

			<p>
				an error would be generated since Lisp doesn’t know of a procedure called “<span class="Subfigure">this</span>”.
			</p>

			<p>
				The <span class="Subfigure">car</span> operator can be applied to lists of arbitrary complexity, but it must always be given a list, never an atom.  If the first element of a list is itself a list, <span class="Subfigure">car</span> will return that list.  For example:
			</p>

			<p class="Figure">
				<span class="Subfigure">(car (quote</span><span class="T11">((a list) containing another list)</span><span class="Subfigure">) )</span>
			</p>

			<p>
				evaluates to the list <span class="T11">(a list)</span> since that is the first element in the data list.   Likewise,
			</p>

			<p class="Figure">
				<span class="Subfigure">(car (quote</span><span class="T11">(((a list) in a list) in another list)</span><span class="Subfigure">) )</span>
			</p>

			<p>
				evaluates to <span class="T11">((a list) in a list)</span>.
			</p>

			<p>
				Thus, the <span class="Subfigure">car</span> of a list can be either an atom or a list.   If the result of a <span class="Subfigure">car</span> is a list, then the <span class="Subfigure">car</span> of that list may also be computed.  So,
			</p>

			<p class="Figure">
				<span class="Subfigure">(car (car (quote</span><span class="T11">(((a list) in a list) in another list)</span><span class="Subfigure">) ))</span>
			</p>

			<p>
				produces <span class="T11">(a list)</span>. In order to help you clearly see why this is the case, Figure 6.4 illustrates the way this result is computed.  Since the result of this expression is itself a list, the <span class="Subfigure">car</span> operator could be applied to that result to produce the atom “<span class="T11">a</span>”.  The form of that expression would be
			</p>

			<h1>INSERT MISSINGOBJECT HERE</h1>

			<p class="Figure">
				Figure 9.5:  An illustration of nested <span class="Subfigure">car</span> operations
			</p>

			<p>
				An interesting historical note about <span class="Subfigure">car</span> is that the name of this command comes from the phrase “Contents of Address Register” and has to do with how this function was implemented on Lisp’s original 1950’s hardware platform.  A better name for <span class="Subfigure">car</span> might have been “first” or “head” since it always returns the first element of a list, which is sometimes called the “head” of the list.  Though the reference to the address register is antiquated, the name “<span class="Subfigure">car</span>” has stuck over the years, and no one seems eager to change it.
			</p>

			<p>
				Before moving on, we should note how every procedure we have looked at so far returns a result.  This is a standard feature of Lisp; every procedure will return a result – either an atom or a list.  In most Lisp systems, if a procedure is called or invoked from the command line console, the result of that procedure is automatically printed to the display screen.
			</p>

			<p>
				The next list operator we will look at is “<span class="Subfigure">cdr</span>”, usually pronounced “cŭ dér”.  The <span class="Subfigure">cdr</span> procedure accepts a list as input and returns as output a list of everything in the original list except the first element.  In other words, <span class="Subfigure">cdr</span> returns everything in a list except its <span class="Subfigure">car</span>.  So,
			</p>
			<p class="Figure">
				<span class="Subfigure">(cdr (quote</span><span class="T11">(this is a list)</span><span class="Subfigure">) )</span>
			</p>

			<p>
				returns the list “<span class="T11">(is a list)</span>”.  Unlike <span class="Subfigure">car</span>, <span class="Subfigure">cdr</span> always returns a list, never an atom.  
			</p>

			<p>
				The basic operation of <span class="Subfigure">cdr</span> is illustrated in Figure 9.6.  In order to make it easy to compare <span class="Subfigure">car</span> and <span class="Subfigure">cdr</span>, this example employs the same data as was used for the illustration of <span class="Subfigure">car</span> in Figure 9.4.
			</p>

			<h1>INSERT MISSINGOBJECT HERE</h1>

			<p class="Figure">
				Figure 9.6:   An illustration of the <span class="Subfigure">cdr</span> operator
			</p>

			<p>
				The <span class="Subfigure">cdr</span> operation may be applied to lists of arbitrary complexity, but it must always be given a list, never an atom.  The first element of the data list is always omitted from the output of <span class="Subfigure">cdr</span>, even if that first element is a list.  Thus, the expression
			</p>

			<p class="Figure">
				<span class="Subfigure">(cdr (quote</span><span class="T11">((a list) within a list)</span><span class="Subfigure">) )</span>
			</p>
			<p class="Figure">
				 
			</p>
			<p>
				will return <span class="T11">(within a list)</span>– everything in the original list save the first element <span class="T11">(a list)</span>.
			</p>
			<p class="P4">
				 
			</p>
			<p>
				Since <span class="Subfigure">cdr</span> operations always return a list, it is always possible to perform a <span class="Subfigure">cdr</span> on the results of another <span class="Subfigure">cdr</span> operation.  In other words, <span class="Subfigure">cdr</span> operations may be nested.  If the input list to <span class="Subfigure">cdr</span> is either an empty list or a list that contains only a single item, <span class="Subfigure">cdr</span> returns the empty list, nil, as its result.  Thus,
			</p>

			<p class="Blockcenter">
				<span class="Subfigure">(cdr (quote </span><span class="T11">(list)</span><span class="Subfigure">))</span>
			</p>
			<p class="Blockcenter">
				(cdr () )
			</p>
			<p class="Blockcenter">
				(cdr nil)
			</p>

			<p>
				each return nil, which is the same as the empty list <span class="Subfigure">()</span>.
			</p>

			<p>
				An example of nested <span class="Subfigure">cdr</span> operations is presented in Figure 9.7.  This example uses the same data as Figure 9.5, so that the operation of nested <span class="Subfigure">cdr</span>s can be compared to the operation of nested <span class="Subfigure">car</span>s.  As you can see from the example, the first cdr generates a list with all of the items in the input list except the first one.  The second cdr generates a list with all of the items in the input list except the first two.  This pattern could be continued until no more items remained in the list.  For example, the list <span class="T11">(list)</span> would be returned by the expression
			</p>

			<h1>INSERT MISSINGOBJECT HERE</h1>

			<p class="Figure">
				Figure 9.7:  An illustration of nested <span class="Subfigure">cdr</span> operations
			</p>

			<p>
				As with <span class="Subfigure">car</span>, the name <span class="Subfigure">cdr</span> is anachronistic.  It stands for “Contents of Data Register”.  A better name for this operation might be “tail”, since the contents of a list minus its head are often referred to as the tail of the list.
			</p>

			<p>
				Both <span class="Subfigure">car</span> and <span class="Subfigure">cdr</span> are very efficient operations in Lisp.  If we compare Figures 6.1, 6.4, and 6.6, we can see that the action of <span class="Subfigure">car</span> can be implemented by returning the value pointed to by the left pointer of the first node of a list’s internal data structure.  Similarly, <span class="Subfigure">cdr</span> can be implemented by returning the node list pointed to by the right pointer of the first node in a list’s internal data structure.  If that pointer is empty (contains nil) then nil is returned.
			</p>

			<p>
				It is possible, and in fact common, to create Lisp expressions that apply both <span class="Subfigure">car</span> and <span class="Subfigure">cdr</span> operations to different portions of an input list. By combining these two functions we can retrieve any desired element from any list.  For example, to retrieve the third element of an input list, we need to apply <span class="Subfigure">cdr</span> two times, followed by <span class="Subfigure">car</span> once. In other words, to get the third item, we discard the first two items in the list, and then select the first item from those remaining.  Because Lisp expressions are evaluated from the “inside out”, the third element of the list <span class="T11">(I will not eat them in the rain)</span>, “<span class="Subfigure">not</span>” could be retrieved in the following way:
			</p>

			<h1>INSERT MISSINGOBJECT HERE</h1>

			<p class="Figure">
				Figure 9.8:  An illustration of nested <span class="Subfigure">car</span> and <span class="Subfigure">cdr</span> operations
			</p>

			<p>
				It is also possible to use <span class="Subfigure">car</span> and <span class="Subfigure">cdr</span> operations to “reach down” and pull an element from any sublist of a list.  Figure 9.7 illustrates retrieving the last atom, of the last sublist, of the first element, of a list.   You should study this example carefully.  Once you fully understand it, you will have mastered using <span class="Subfigure">car</span> and <span class="Subfigure">cdr</span>.  As you work your way through this example, notice how we use <span class="Subfigure">cdr</span> to move through a list an element at a time, and <span class="Subfigure">car</span> to move down into a sublist.
			</p>

			<p>
				Sometimes as we are processing a list, we end up in a situation were we have a one element list, where that element is itself a list, and we wish to delve into the underlying list.  In other words, a situation with a list like <span class="T11">((many sublists)) where it is first necessary to <span class="Subfigure">car</span> this list to get to the underlying list <span class="T11">(many sublists) before you can process that list.  I point this out, since it is quite easy to overlook this required step.
			</p>

			<h1>INSERT MISSINGOBJECT HERE</h1>

			<p class="Figure">
				Figure 9.9:  An illustration of the relationship between <span class="Subfigure">car</span>, <span class="Subfigure">cdr</span>, and <span class="Subfigure">cons</span>
			</p>

			<p>
				A third list operator is “<span class="Subfigure">cons</span>”.  Whereas, <span class="Subfigure">car</span> and <span class="Subfigure">cdr</span> are used to decompose lists, <span class="Subfigure">cons</span> is Lisp’s primary list constructor that is used to build up lists.  The <span class="Subfigure">cons</span> operator accepts two inputs, the first can be either an atom or list, but the second must be a list.  <span class="Subfigure">Cons</span> returns a new list, the <span class="Subfigure">car</span> of which is its first argument, the <span class="Subfigure">cdr</span> of which is its second argument.   For example,
			</p>

			<p class="Figure">
				<span class="Subfigure">(cons (quote </span><span class="T11">this</span><span class="Subfigure">) (quote</span><span class="T11">(is a list)</span><span class="Subfigure">) )</span>
			</p>
			<p class="Subfigure">
				 
			</p>
			<p>
				returns the list <span class="T11">(this is a list)</span>.  Note that the <span class="Subfigure">car</span> of <span class="T11">(this is a list)</span> is the atom <span class="T11">this</span>, which was the first input to <span class="Subfigure">cons</span>.  The <span class="Subfigure">cdr</span> of <span class="T11">(this is a list)</span> is the list <span class="T11">(is a list)</span>, which was the second input to <span class="Subfigure">cons</span>.  
			</p>

			<p>
				As mentioned above, while the second input to <span class="Subfigure">cons </span>must be a list, the first input can be either a list or an atom.  If the first input is a list, then that list will become the first element of the returned list.  So, the expression
			</p>

			<p class="Figure">
				<span class="Subfigure">(cons (quote</span><span class="T11">(this)</span><span class="Subfigure">) (quote</span><span class="T11">(list contains a sublist)</span><span class="Subfigure">) )</span>
			</p>

			<p>
				produces the list <span class="T11">((this) list contains a sublist)</span>; a list in which the first element is a list containing a single atomic element.
			</p>

			<p>
				It is interesting to note that if you take the <span class="Subfigure">cons</span> of the <span class="Subfigure">car</span> and <span class="Subfigure">cdr</span> of the same list, you will end up with a copy of the original list.  This relationship between <span class="Subfigure">cons</span>, <span class="Subfigure">car</span>, and <span class="Subfigure">cdr</span> is illustrated in Figure 9.9.
			</p>

			<h1>INSERT MISSINGOBJECT HERE</h1>

			<p class="Figure">
				Figure 9.10: The Lisp list composition operators: <span class="Subfigure">cons</span>, <span class="Subfigure">list</span>, and <span class="Subfigure">append</span>
			</p>

			<p>
				In addition to <span class="Subfigure">cons</span>, there are a number of other Lisp operators that are used to create lists.  Two of the most common operators are <span class="Subfigure">list</span> and <span class="Subfigure">append</span>.  <span class="Subfigure">List</span> is a function that takes any number of inputs, each of which may be an atom or a list, and returns a new list, the elements of which were the inputs to the function.  <span class="Subfigure">Append</span> accepts any number of lists as input (no atoms are allowed) and returns a new list composed of the input lists with the outermost level of parentheses removed from each of them.
			</p>

			<p>
				You may be asking yourself which of the three list composition operators, <span class="Subfigure">cons</span>, <span class="Subfigure">list</span>, or <span class="Subfigure">append</span> you should use when you wish to build a list.  Well this all depends, of course, on what kind of list you are trying to build and what kinds of inputs you have, but here is a good way of keeping the functionality of each of these three operators straight.  Assume you want to build a list with no sublists – a simple list of atoms.  In order to do so, use <span class="Subfigure">cons</span> if you have an atom and a list of atoms and want to insert the new atom at the head of the existing list.  Use <span class="Subfigure">list</span> if you have a bunch of atoms and want to build a list out of them.  Finally, use <span class="Subfigure">append</span> if you already have two or more lists of atoms and want to join them together into a single list.  Figure 9.10 illustrates three methods of constructing the list <span class="T11">(a b c d)</span>, using <span class="Subfigure">cons</span>, <span class="Subfigure">list</span>, and <span class="Subfigure">append</span>.  Notice that each of these operators requires different inputs in order to construct identical output lists.
			</p>

			<p>
				At the beginning of this section I made the claim that Lisp was a simple, albeit powerful, little language.  In fact, the core of the Lisp “engine” can be diagramed in less than a page.  It appears in Figure 9.11.
			</p>

			<p>
				Lisp is an interpreted language.  Unlike most procedural languages which are translated, or complied, to machine language (or to an intermediate byte code as is the case with Java), Lisp instructions are evaluated by the Lisp engine as they are encountered during program execution.  While program written in interpreted languages tend to run slower than compiled programs, interpreted languages can make up for this deficiency with increased flexibility.
			</p>

			<p>
				Due to the fact that Lisp is interpreted and uses the same data structures, lists, for both programs and data, the language is extremely flexible.  In fact, Lisp is so flexible that it is possible to create a Lisp program that writes other programs and then execute those programs.  This idea, that Lisp is self-extensible, attracted a lot of attention in the early days of the language.
			</p>

			<p>
				Now lets turn our attention to the Lisp engine, or interpreter.  The name of the Lisp interpreter is “Eval”.  Eval is a simple recursive procedure that evaluates lisp expressions.  
			</p>

			<p>
				Eval works in the following way.  
			</p>

			<div class="Standard">
				First, Eval checks to see if it has been given an atom.  If so, it then checks to see whether that atom is a number.  If the input is a numeric atom, Eval simply returns the number and exits.  If the input was an atom, but was not numeric, the value (if any) bound to that variable is returned.<span class="Footnote"><span class="Footnote_20_anchor" title="Footnote: Although I have not yet shown you how to bind a value to a symbol, know that it is possible. We will look into ways of doing this in the next section."><a href="#ftn2" id="body_ftn2">2</a></span></span>  Although I have not yet shown you how to bind a value to a symbol, know that it is possible. We will look into this matter in the next section.
			</div>

			<p>
				If the input given to Eval was not an atom, then it must be a list.  Eval next determines whether the first element of its input list is <span class="Subfigure">quote</span>.  If so, Eval returns the second element of its input list and exits.
			</p>

			<h1>INSERT MISSINGOBJECT HERE</h1>

			<p class="Figure">
				Figure 9.11:  The Lisp interpreter -- Eval
			</p>

			<p>
				Next, Eval checks to see whether the first element of the input list requires special handling of some sort.  For example, it may be the <span class="Subfigure">defun</span> operator (described in the next section) that is used to define new functions and is thus not a “normal” function.  If special handling is required, Eval performs the necessary actions and returns.
			</p>

			<p>
				Assuming the procedure named in the first element of Eval’s input list is a standard Lisp function, Eval then calls itself on each of the elements of the input list other than the first.  This is a recursive call and is what gives Lisp its “inside out” feeling.
			</p>

			<p>
				Once all of the inputs, other than the first, have been properly evaluated, the final task of Eval is to call the function named in the first element of the input list on the values already returned for each of its inputs.
			</p>

			<p>
				Eval then returns the computed value computed by this function to the procedure that called it.  If that function is the top-level “command interpreter”, the return result will be printed on the display device.
			</p>

			<p>
				And that’s it.  That is all the basic Lisp engine does.  Figure 9.11 summarizes the contents of the preceding paragraphs in program “flowchart” form.
			</p>

			<h1 class="Heading_20_1"><a id="a__Exercises_9_2_1"><span/></a>Exercises 9.2.1</h1>

			<ol>
				<li>
					<p class="P16" style="margin-left:0cm;">
						<span class="WW8Num1zfalse" style="display:block;float:left;min-width:0.635cm;">1.</span>Identify each of the following as an atom, list, or neither an atom nor list:<span class="odfLiEnd"/> 
					</p>
				</li>
			</ol>

			<p class="Subfigure">
				R2D2<span> </span> <span> (attack of the clones)</span> <span> </span> <span> (C3PO)</span> <span> </span> <span> 1138</span> 					<span> </span> <span> ((((()()))))</span>
			</p>
			<p>
				 
			</p>
			<p>
				 
			</p>
			<ol>
				<li>
					<p class="P16" style="margin-left:0cm;">
						<span class="WW8Num1zfalse" style="display:block;float:left;min-width:0.635cm;">2.</span>Using Figures 9.1, 9.2, and 9.3 as a guide, show the internal representation of the following lists:<span class="odfLiEnd"/> 
					</p>
				</li>
			</ol>
			<p class="P4">
				 
			</p>
			<span class="Blockcenter">
			<p>
				2.1  <span class="Subfigure">(please state the nature of the medical emergency)</span>
			</p>
			<p>
				2.2  <span class="Subfigure">((please state)the nature(of the medical)emergency)</span>
			</p>
			<p>
				2.3<span class="Subfigure"> (please(state the nature of the(medical)emergency))</span>
			</p>
			</span>
			<p>
				 
			</p>
			<p>
				 
			</p>
			<ol>
				<li>
					<p class="P16" style="margin-left:0cm;">
						<span class="WW8Num1zfalse" style="display:block;float:left;min-width:0.635cm;">3.</span>Evaluate the following Lisp expressions.  Indicate any potential errors.<span class="odfLiEnd"/> 
					</p>
				</li>
			</ol>
			<p>
				 
			</p>
			<span class="Blockcenter">
			<p>
				<span> 3.1   <span class="Subfigure">(+ 2 (* 5 3))</span></span>
			</p>
			<p>
				<span> 3.2   <span class="Subfigure">(/ (- 5 3) (+ 1 1))</span></span>
			</p>
			<p>
				<span> 3.2   <span class="Subfigure">(5 + 3)</span></span>
			</p>
			<p>
				<span> 3.4   <span class="Subfigure">( * + 3 5 2)</span></span>
			</p>
			</span>
			<p>
				 
			</p>
			<ol>
				<li>
					<p class="P16" style="margin-left:0cm;">
						<span class="WW8Num1zfalse" style="display:block;float:left;min-width:0.635cm;">4.</span>Evaluate the following Lisp expressions.  Indicate any potential errors.<span class="odfLiEnd"/> 
					</p>
				</li>
			</ol>
			<p>
				 
			</p>
			<span class="Blockcenter">
			<p>
				<span> 4.1   <span class="Subfigure">(quote (brave))</span></span>
			</p>
			<p>
				<span> 4.2   <span class="Subfigure">(quote (new world))</span></span>
			</p>
			<p>
				<span> 4.3   <span class="Subfigure">(quote Huxley)</span></span>
			</p>
			</span>
			<p/>
			<p>
				 
			</p>
			<ol>
				<li>
					<p class="P16" style="margin-left:0cm;">
						<span class="WW8Num1zfalse" style="display:block;float:left;min-width:0.635cm;">5.</span>Evaluate the following Lisp expressions.  Indicate any potential errors.<span class="odfLiEnd"/> 
					</p>
				</li>
			</ol>
			<p>
				 
			</p>
			<span class="Blockcenter">
			<p>
				<span> 5.1  <span class="Subfigure">(car(quote(a hobbits tale)))</span></span>
			</p>
			<p>
				<span> 5.2  <span class="Subfigure">(car(car(quote((a hobbits tale) by Bilbo Baggins))))</span></span>
			</p>
			<p>
				<span> 5.3  <span class="Subfigure">(car(quote(the shire)))</span></span>
			</p>
			<p>
				<span> 5.4  <span class="Subfigure">(car(the shire))</span></span>
			</p>
			<p>
				<span> 5.5  <span class="Subfigure">(car(car(car(quote(((the)shire))))))</span></span>
			</p>
			<p>
				<span> 5.6  <span class="Subfigure">(car(quote Frodo))</span></span>
			</p>
			</span>
			<p>
				 
			</p>

			<ol>
				<li>
					<p class="P16" style="margin-left:0cm;">
						<span class="WW8Num1zfalse" style="display:block;float:left;min-width:0.635cm;">6.</span>Evaluate the following Lisp expression.  Indicate any potential errors.<span class="odfLiEnd"/> 
					</p>
				</li>
			</ol>

			<p class="Subfigure">
				(car (quote (car (quote (((a list) in a list) in another list)))))
			</p>

			<p>
				 
			</p>
			<ol>
				<li>
					<p class="P16" style="margin-left:0cm;">
						<span class="WW8Num1zfalse" style="display:block;float:left;min-width:0.635cm;">7.</span>Evaluate the following Lisp expressions.  Indicate any potential errors.<span class="odfLiEnd"/> 
					</p>
				</li>
			</ol>
			<span class="Blockcenter">
			<p>
				<span> 7.1  <span class="Subfigure">(cdr (quote (Doctor Morbius)))</span></span>
			</p>
			<p>
				<span> 7.2  <span class="Subfigure">(cdr (cdr (cdr (quote (Welcome to Altair 4)))))</span></span>
			</p>
			<p>
				<span> 7.3  <span class="Subfigure">(cdr (quote Robbie))</span></span>
			</p>
			<p>
				<span> 7.4  <span class="Subfigure">(cdr (cdr (quote (monsters (from the) Id))))</span></span>
			</p>
			</span>
			<ol>
				<li>
					<p class="P16" style="margin-left:0cm;">
						<span class="WW8Num1zfalse" style="display:block;float:left;min-width:0.635cm;">8.</span>Evaluate the following Lisp expressions.  Indicate any potential errors.<span class="odfLiEnd"/> 
					</p>
				</li>
			</ol>
			<span class="Blockcenter">
			<p>
				8.1  <span class="Subfigure">(car (cdr (quote (I am a doctor not a))))</span>
			</p>
			<p>
				8.2  <span class="Subfigure">(car (cdr (cdr (quote (I am a doctor not a)))))</span>
			</p>
			<p>
				8.3  <span class="Subfigure">(car (cdr (cdr (cdr (quote(I am a doctor not a))))))</span>
			</p>
			<p>
				8.4  <span class="Subfigure">(car (cdr (car (quote((most illogical)captain)))))</span>
			</p>
			<p>
				8.5  <span class="Subfigure">(cdr (car (quote ((hailing frequencies open)))))</span>
			</p>
			<p>
				8.6  <span class="Subfigure">(cdr (car (quote (hailing frequencies open))))</span>
			</p>
			</span>
			<ol>
				<li>
					<p class="P16" style="margin-left:0cm;">
						<span class="WW8Num1zfalse" style="display:block;float:left;min-width:0.635cm;">9.</span>Evaluate the following Lisp expressions.  Indicate any potential errors.<span class="odfLiEnd"/> 
					</p>
				</li>
			</ol>
			<span class="Blockcenter">
			<p>
				<span> 9.1  <span class="Subfigure">(cons (quote open) (quote (the pod bay doors Hal)))</span></span>
			</p>
			<p>
				<span> 9.2  <span class="Subfigure">(cons (quote(open)) (quote(the pod bay doors Hal)))</span></span>
			</p>
			<p>
				<span> 9.3  <span class="Subfigure">(cons (quote(open the pod))(quote((bay doors) Hal)))</span></span>
			</p>
			</span>
			<p>
				 
			</p>
			<p>
				 
			</p>
			<ol>
				<li>
					<p class="P16" style="margin-left:0cm;">
						<span class="WW8Num1zfalse" style="display:block;float:left;min-width:0.635cm;">10.</span>Evaluate the following Lisp expressions.  Indicate any potential errors.<span class="odfLiEnd"/> 
					</p>
				</li>
			</ol>
			<span class="Blockcenter">
			<p>
				<span> 10.1  <span class="Subfigure">(list (quote just) (quote a) (quote moment))</span></span>
			</p>
			<p>
				<span> 10.2  <span class="Subfigure">(list (quote(just a)) (quote(moment)))</span></span>
			</p>
			<p>
				<span> 10.3  <span class="Subfigure">(list (quote(just a)) (quote moment)) </span></span>
			</p>
			</span>
			<p>
				 
			</p>
			<p>
				 
			</p>
			<ol>
				<li>
					<p class="P16" style="margin-left:0cm;">
						<span class="WW8Num1zfalse" style="display:block;float:left;min-width:0.635cm;">11.</span>Evaluate the following Lisp expressions.  Indicate any potential errors.<span class="odfLiEnd"/> 
					</p>
				</li>
			</ol>
			<span class="Blockcenter">
			<p>
				<span> 11.1  <span class="Subfigure">(append (quote just) (quote a) (quote moment))</span></span>
			</p>
			<p>
				<span> 11.2  <span class="Subfigure">(append (quote (just a)) (quote (moment)))</span></span>
			</p>
			<p>
				<span> 11.3  <span class="Subfigure">(append (quote (just a)) (quote moment)) </span></span>
			</p>
			</span>
			<p>
				 
			</p>
			<p>
				 
			</p>
			<ol>
				<li>
					<p class="P16" style="margin-left:0cm;">
						<span class="WW8Num1zfalse" style="display:block;float:left;min-width:0.635cm;">12.</span>Using the illustration of Figure 9.10, trace through the actions of the Lisp interpreter when evaluating the expression:<span class="odfLiEnd"/> 
					</p>
				</li>
			</ol>

			<p class="Subfigure">
				(+ 3 (- 12 10))
			</p>

			<p class="Bolded">
				9.2.2  User-defined functions
			</p>

			<p>
				In the previous section, we looked at the fundamentals of Lisp – the list data structure, a variety of basic mathematical and list-oriented operators, expression evaluation, and the behavior of the Lisp interpreter.  In this section we turn our attention to the question of how Lisp programs may be written.
			</p>

			<p>
				A <span class="Bolded">Lisp program</span> is simply a collection of related functions that work together to solve a problem.  In a sense, the expressions presented in the previous section can be considered “programs”, but they weren’t general purpose in the sense that they could only operate on numbers and quoted data, not variables, and were limited to accessing built-in operators, such as <span class="Subfigure">cond</span>, <span class="Subfigure">cdr</span>, and <span class="Subfigure">+</span>.  In order to be able to write truly useful programs we need a way to ‘extend’ Lisp beyond its built-in functions, to include user-defined functions.
			</p>

			<p>
				The <span class="Subfigure">defun</span> procedure is used to define functions; in fact, its name stands for <span class="Bolded">de</span>fine <span class="Bolded">fun</span>ction.  The format of the <span class="Subfigure">defun</span> procedure is:
			</p>

			<p>
				<span class="Subfigure">  </span><span class="Subfigure">( defun</span><span class="Italicized">function_name</span><span class="Subfigure">(</span><span class="Italicized">argument</span><span class="Subscript">1</span><span class="Subfigure"> </span><span class="Italicized">argument</span><span class="Subscript">2</span><span class="Subfigure"> </span><span class="Italicized">argument</span><span class="Subscript">3</span><span class="Subfigure"> </span>…<span class="Subfigure"> </span><span class="Italicized">argument</span><span class="Subscript">n</span><span class="Subfigure">)</span>
			</p>
			<p>
				               <span class="Italicized">function_body</span>
			</p>
			<p class="P4">
				<span class="T9">  </span>)
			</p>

			<p>
				where <span class="Italicized">function_name</span> is a symbolic atom that specifies the name of the function being defined; each of the <span class="Italicized">arguments</span> are symbolic atoms that will be bound to input values; and <span class="Italicized">function_body</span>  is a list that specifies the operations to be carried out on the arguments.  Note that the <span class="Italicized">function_body</span> list can be a simple list of atoms or quite complex with many nested sublists.  
			</p>

			<p>
				While <span class="Subfigure">defun</span> is used to define functions, it is not, itself, a traditional function.  Most Lisp functions accept one or more elements as input, and return a single result value.  The <span class="Subfigure">defun</span> procedure returns <span class="Italicized">function_name</span> – the name of the function being defined – as its result.  In addition, <span class="Subfigure">defun</span> has the “side effect” of actually creating the function and adding its name to the collection of functions recognized by Lisp.  Thus, when the Lisp Eval interpreter, illustrated in Figure 9.10, encounters a list with the symbol <span class="Subfigure">defun</span> as its first element, it will take the “yes” branch at the condition labeled “Is the first element of S non-standard?”
			</p>

			<p>
				Now, let’s write a function.  We will start with something very simple; a function called <span class="Subfigure">head</span> that returns the first element of a list.  This function will do exactly the same thing as the built-in function <span class="Subfigure">car</span>, but will have a more meaningful name.  So, if the <span class="Subfigure">head</span> function were called in the following manner:
			</p>

			<p class="Figure">
				<span class="Subfigure">(head (quote</span><span class="T11">(this is a list)</span><span class="Subfigure">))</span>
			</p>

			<p>
				we would expect it to return the atom <span class="T11">this</span>.  In exactly the same manner that the expression <span class="Subfigure">(car (quote</span><span class="T11">(this is a list)</span><span class="Subfigure">))</span> would have.
			</p>

			<p>
				Here is the definition of the function <span class="Subfigure">head</span>:
			</p>
			<span class="Blockcenter">
			<p>
				(defun head (L)
			</p>
			
			<p class="Subblockcenter">
				<span> </span>(car L)
			</p>
			
			<p>
				)
			</p>
			</span>

			<p>
				The definition is a list.  The first element of that list is the keyword <span class="Subfigure">defun</span>, an atom.  The second element of the list is the name of the function we are defining, <span class="Subfigure">head</span>.  The third element of every <span class="Subfigure">defun</span> list is always itself a list.  This list contains symbolic atoms that will act as placeholders for the function’s inputs.  
			</p>

			<p>
				Since the purpose of the <span class="Subfigure">head</span> function will be to return the first element of a list, it needs a way to refer to its input list.  In this example, the symbol <span class="Subfigure">L</span> is used to represent the input list.  There is nothing magic or special about using <span class="Subfigure">L</span>, we could just as easily have used another symbol, such as LST or LIS.  However, one symbol we could not have used for our list variable is <span class="Subfigure">LIST</span>.  That is because Lisp already uses <span class="Subfigure">list</span> as the name of one of its list composition functions, as we discussed in the previous section.  
			</p>

			<p>
				You may have noticed that I am writing Lisp function names in lower case and Lisp argument names in upper case.  The reason for doing so is to make it easier to quickly tell which atoms refer to functions and which refer to data.  However, many Lisp interpreters are not “case sensitive”, which means that <span class="Subfigure">list</span>, <span class="Subfigure">List</span>, <span class="Subfigure">LiST</span>, and <span class="Subfigure">LIST</span> look identical to those interpreters and would thus refer to the same object.
			</p>

			<p>
				Returning to our example, the fourth and final element of the <span class="Subfigure">head</span> definition list is the list:<span class="Subfigure">(car L)</span>.  This list represents the actions to be taken by the <span class="Subfigure">head</span> function on the input list <span class="Subfigure">L</span>; namely that the <span class="Subfigure">car</span> of <span class="Subfigure">L</span> will be computed and returned by this function.
			</p>

			<p>
				At this point you might be saying, hold on a second <span class="Subfigure">L</span> is an atom, not a list, and <span class="Subfigure">car</span> can only be applied to lists, so what gives here?  What gives is that since <span class="Subfigure">L</span> is not quoted, it will be evaluated by the Lisp interpreter prior to <span class="Subfigure">car</span> being called.  So, the value bound to <span class="Subfigure">L</span>, not <span class="Subfigure">L</span> itself, is what will be passed to <span class="Subfigure">car</span>.  This behavior can be seen by tracing <span class="Subfigure">(car L)</span> on the Eval graph of Figure 9.10.  
			</p>

			<p>
				If <span class="Subfigure">head</span> is passed a list, the first element of that list will be returned.  Passing <span class="Subfigure">head</span> an atom will generate an error, but that shouldn’t be a surprise, since passing an atom to <span class="Subfigure">car</span> would also generate an error.
			</p>

			<p>
				It is important to note that <span class="Subfigure">(car (L))</span> could not be used in the definition of this function.  Why?  The reason is that Eval would attempt to interpret the list <span class="Subfigure">(L)</span>.  Since Eval treats all lists as function calls – unless they are quoted – it would look for a function named <span class="Subfigure">L</span>, and since there is no such function, an error would be produced.
			</p>

			<p>
				<span class="Subfigure">( defun</span><span class="Italicized">function_name</span><span class="Subfigure">(</span><span class="Italicized">argument</span><span class="Subscript">1</span><span class="Subfigure"> </span><span class="Italicized">argument</span><span class="Subscript">2</span><span class="Subfigure"> </span><span class="Italicized">argument</span><span class="Subscript">3</span><span class="Subfigure"> </span>…<span class="Subfigure"> </span><span class="Italicized">argument</span><span class="Subscript">n</span><span class="Subfigure">)</span>
			</p>
			<p>
				<span> <span class="Italicized">function_body</span></span>
			</p>
			<p class="P4">
				<span class="T9"> </span>)
			</p>
			<p class="Figure">
				(a) The general format of the <span class="Subfigure">defun</span> procedure
			</p>
			<span class="Blockcenter">
			<p>
				(defun head (L)
			</p>
			
			<p class="Subblockcenter">
				<span> </span>(car L)
			</p>
			
			<p>
				)
			</p>
			</span>
			<p class="Figure">
				(b) Definition of a function that returns the first element (head) of a list
			</p>

			<h1>INSERT MISSINGOBJECT HERE</h1>

			<p class="Figure">
				(c) Invocation and return of user-defined function <span class="Subfigure">head</span>
			</p>

			<p class="Figure">
				Figure 9.12:  An overview of user-defined functions in Lisp
			</p>

			<p>
				When evaluated by the Lisp interpreter, the definition of <span class="Subfigure">head</span> specified using <span class="Subfigure">defun</span> will be added to the collection of known Lisp functions. During the rest of the current Lisp session – that is until the Lisp environment is restarted – you will be able to use <span class="Subfigure">head</span> just like any other Lisp function.  
			</p>

			<p>
				Our definition of head constitutes a program. A <span class="Bolded">program</span> in Lisp consists of one or more <span class="Subfigure">defun</span>s together with any needed data lists.  Programs are generally stored in files.  A program is run by loading its file into the Lisp environment and then calling its main function.
			</p>

			<p>
				Figure 9.12 contains a summary of user-defined Lisp functions.  Part (a) describes the format of the <span class="Subfigure">defun</span> procedure.  Part (b) presents our example user-defined function, <span class="Subfigure">head</span>.  Part (c) illustrates function invocation and return using the definition given in Part (b).
			</p>

			<p>
				Let’s look at some additional function definitions.  First up, we could do for <span class="Subfigure">cdr</span> what we did for <span class="Subfigure">car</span> – create a new function with the same functionality but a better name.  Here is a definition for a new version of <span class="Subfigure">cdr</span> called <span class="Subfigure">tail</span>.
			</p>

			<span class="Blockcenter">			
			<p>
				(defun tail (L)
			</p>
			<p class="Subblockcenter">
				<span>  </span>(cdr L)
			</p>
			<p>
				)
			</p>
			</span>
			<p>
				It also might be useful if we defined a group of functions that retrieved the second, third, and fourth elements of a list, since those are tasks that are performed quite frequently.   One way of defining <span class="Subfigure">second</span>, using only built-in functions, would be
			</p>

			<span class="Blockcenter">
			<p>
				(defun second (L)
			</p>
			<p class="Subblockcenter">
				<span>  </span>(car (cdr L))
			</p>
			<p>
				)
			</p>
			</span>
			<p>
				We could also define <span class="Subfigure">second</span> using <span class="Subfigure">head</span> and <span class="Subfigure">tail</span>.
			</p>

			<span class="Blockcenter">
			<p>
				(defun second (L)
			</p>
			<p class="Subblockcenter">
				<span>  </span>(head (tail L))
			</p>
			<p>
				)
			</p>
			</span>

			<p>
				Definitions of <span class="Subfigure">third</span> and <span class="Subfigure">fourth</span> are left as exercises.  Most versions of Lisp include <span class="Subfigure">second</span>, <span class="Subfigure">third</span>, and <span class="Subfigure">fourth</span> as built-in functions, but they are called by the more cryptic names <span class="Subfigure">cadr</span>, <span class="Subfigure">caddr</span>, and <span class="Subfigure">cadddr</span>, due to their underlying definitions – i.e., <span class="Subfigure">cadr</span> is implemented as<span class="Subfigure">(car(cdr L))</span>, <span class="Subfigure">caddr</span> as <span class="Subfigure">(car(cdr(cdr L)))</span>, and so forth.
			</p>

			<p>
				In addition to list manipulation based functions, mathematical functions can also be written in Lisp.  For example,
			</p>
			<ul class="Blockcenter"><li>
			<span class="Subfigure">
			<p>
				(defun second (NUM)
			</p>
			<ul  class="Subblockcenter"><li>
			<p>
				( * NUM NUM)
			</p>
			</ul></li>
			<p>
				)
			</p>
			</ul></li></span>

			<p>
				Defines a function that takes a numeric atom, a number, and returns its <span class="Subfigure">square</span> – i.e., multiplies the number by itself.  A slightly more complex mathematical oriented example would be a function that converts a temperature reading from degrees Fahrenheit to degrees Celsius.  The conversion formula is <span class="Subfigure">C = (F – 32)/1.8</span>.  Here is the function definition in Lisp using the name <span class="Subfigure">f-to-c</span>:
			</p>
			<ul class="Blockcenter"><li>
			<span class="Subfigure">
			<p>
				(defun f-to-c (TEMP)
			</p>
			<ul class="Subblockcenter"><li>
			<p>
				( / ( - TEMP 32) 1.8)
			</p>
			</ul></li></ul></li>
			<p class="Subfigure">
				)
			</p>
			</span>
			<p>
				Calling <span class="Subfigure">(f-to-c 32)</span> returns <span class="Subfigure">0.0</span>, <span class="Subfigure">while</span><span class="Subfigure">(f-to-c 212)</span> returns <span class="Subfigure">100.0</span>.
			</p>
			<p class="Blockcenter">
				<span class="Subfigure">(cond (</span><span class="Italicized">condition</span><span class="Subscript">1</span><span class="Subfigure"> </span><span class="Italicized">result</span><span class="Subscript">1</span><span class="Subfigure">)</span>
			</p>
			<p class="Subfigure">
				<span class="Subfigure">(</span><span class="Italicized">condition</span><span class="Subscript">2</span><span class="Subfigure"> </span><span class="Italicized">result</span><span class="Subscript">2</span><span class="Subfigure">)</span>
			</p>
			<p class="Subfigure">
			 :             :
			</p>
			<p class="Subfigure">
				<span class="Subfigure">(</span><span class="Italicized">condition</span><span class="Subscript">n</span><span class="Subfigure"> </span><span class="Italicized">result</span><span class="Subscript">n</span><span class="Subfigure">))</span>
			</p>

			<p class="Figure">
				Figure 9.13:  The format of the <span class="Subfigure">cond</span> function
			</p>

			<p>
				As we learned in Chapter 8, the three basic control constructs of imperative programming are sequence, selection, and repetition.  Functional languages such as Lisp also implement a form of these control constructs.  At this point we have seen how to write Lisp procedures that consist of a sequence of nested operations, thus we have mastered sequence in Lisp
			</p>

			<p>
				We now turn our attention to selection.  Selection is implemented in Lisp using the “condition” operation,  <span class="Subfigure">cond</span>.  The cond operator is similar to the If-Then-Else construction of Chapter 8, except that it allows many different “cases” to be tested instead of just two.
			</p>

			<p>
				The format of the <span class="Subfigure">cond</span> function is shown in Figure 9.12.  This function takes the form of a list, where the first element of the list is the atom <span class="Subfigure">cond</span>.  Following the function name are one or more condition/result lists. Each of these lists contains two elements.  The first element is a condition, or predicate, that will return either true or false.  If the condition is true, the associated result list will be evaluated and its result returned as the result of the <span class="Subfigure">cond</span> function.  If none of the conditions are true, <span class="Subfigure">cond</span> will return nil.  If multiple conditions are true, <span class="Subfigure">cond</span> will return the result associated with the <span class="Italicized">first</span> true condition.
			</p>
			
			<ul class="Blockcenter"><li>
			<span class="Subfigure">			
			<p>
				(defun legal (AGE)
			</p>
			<ul class="Subblockcenter"><li>
			<p>
				<span> (cond ((&gt;= AGE 21)  T )</span>
			</p>
			<ul class="Subblockcenter"><li>
			<p>
				<span>  (    T       nil) )</span>
			</p>
			
			<p>
				)
			</p>
			</ul></li></ul></li></span>
			<p class="Figure">
				(a) Definition of function <span class="Subfigure">legal</span>
			</p>
			<ul class="Blockcenter"><li>
			<p>
				(legal 18)  nil
			</p>
			<p>
				(legal 21)  T
			</p>
			<p>
				(legal 42)  T
			</p>
			</ul></li>
			<p class="Figure">
				(b) Input/Output behavior of <span class="Subfigure">legal</span>
			</p>
			<p class="Figure">
				 
			</p>
			<p class="Figure">
				Figure 9.13:  A program that illustrates selection via the <span class="Subfigure">cond</span> function
			</p>
			<p class="Figure">
				 
			</p>

			<p>
				Lisp contains a large number of functions, called predicates, that can be used to test for a wide range of conditions.  Predicates exist to test whether two numbers are less than <span class="Subfigure">&lt;</span>, greater than <span class="Subfigure">&gt;</span>, equal <span class="Subfigure">=</span>, less than or equal <span class="Subfigure">&lt;=</span>, greater than or equal <span class="Subfigure">&gt;=</span>, or not equal <span class="Subfigure">/=</span>.
			</p>

			<p>
				Figure 9.13(a) presents the definition of a function that uses <span class="Subfigure">cond</span> to perform a condition test.  The function, called <span class="Subfigure">legal</span>, determines whether a person is of legal drinking age by comparing their <span class="Subfigure">AGE</span> to 21.  If <span class="Subfigure">AGE</span> is greater than or equal to 21, the function returns true, otherwise the function returns false.  The input/output behavior of legal is illustrated in Figure 9.13(b) using three different values for <span class="Subfigure">AGE</span>, one less than 21, one equal to 21, and one greater than 21.
			</p>

			<p>
				At this point it is important to say a few words about how Lisp represents true and false.  False is implemented as the empty list, nil or ().  Anything that is not false is considered true.  So, for example the number <span class="Subfigure">2</span>, the symbol <span class="Subfigure">cow</span>, and the list <span class="Subfigure">(chicken)</span> would all be considered true, since they are not nil.  Though every non-nil value is, by definition, true, Lisp includes a special atom, <span class="Subfigure">T</span>, solely for indicating true.  Using <span class="Subfigure">T</span> makes Lisp programs easier to read and understand.
			</p>

			<p>
				The <span class="Subfigure">cond</span> of  Figure 9.13(a)  has two condition/result pairs.  The first condition/result pair reads <span class="Subfigure">((&gt;= AGE 21) T)</span>.  Thus, if <span class="Subfigure">(&gt;= AGE 21)</span> is true, then its associated result, <span class="Subfigure">T</span>, meaning true, will be returned.  Assuming that <span class="Subfigure">(&gt;= AGE 21)</span> is not true, <span class="Subfigure">cond</span> would next examine its second condition/result pair.  This pair reads <span class="Subfigure">( T nil)</span>.  Placing a <span class="Subfigure">T</span> in the condition portion of the second condition/result pair guarantees that the result of this pair, nil, will be returned if this pair is ever examined.  
			</p>

			<p>
				At first it may seem odd to ever use T in the condition portion of a condition/result pair, but in fact it is very common to do so.  Use of a <span class="Subfigure">T</span> condition in the final condition/result pair of a <span class="Subfigure">cond</span> causes that pair to behave like the else clause of an If-Then-Else statement.  In other words, if none of the “regular” conditions apply, you can be sure that the last one will, since it is always true – i.e., applies in all cases.  One note of caution however, a <span class="Subfigure">T</span> condition should only be used in the final condition/result pair of a <span class="Subfigure">cond</span>.  Any condition/result pairs placed after the <span class="Subfigure">T</span> condition will never be evaluated, since execution of the <span class="Subfigure">cond</span> will terminate at the first <span class="Subfigure">T</span> condition.
			</p>

			<p>
				Here is the definition of another function that uses the <span class="Subfigure">cond</span> operator
			</p>
			<ul class="Blockcenter"><li>
			<span class="Subfigure">
			<p>
				(defun absolute_value (NUM)
			</p>
			<ul class="Subblockcenter"><li>
			<p>
				(cond ((&gt;= NUM 0)   NUM    )
			</p>
			<ul class="Subblockcenter"><li>
			<p>
				(    T     (- 0 NUM) ) )
			</p>
			</ul></li></ul></li>	
			<ul class="Blockcenter"><li>
			<p>
				)
			</p>
			</ul></li>
			
			
			</span>
			<p>
				This function returns the absolute value of a number.  If the number is greater than or equal to zero, that number is returned unchanged.  Otherwise (that is if the number is less than zero) the original number is subtracted from zero (giving a positive result) and that result is returned as the value of the function.
			</p>

			<p>
				As was the case with imperative language If-Then-Else statements, <span class="Subfigure">cond</span> functions may be nested within one another.  Figure 9.14 contains a Lisp function based on the yuppie example illustrated in Figure 8.14.  While the input/output behavior of these two programs is different, comparing them gives a good feel for the differences between Lisp functions and imperative programs.  The general rule used to define yuppies is the same in both figures – i.e., that yuppies are individuals who are under 40 and make $50,000 or more per year.  The Lisp version of this program is a function that accepts two inputs, <span class="Subfigure">AGE</span> and <span class="Subfigure">INCOME</span>, and returns a list indicating whether or not the conditions of yuppiedom have been met.  If the conditions have been met, the list <span class="Subfigure">(yuppie)</span> will be returned.  If the inputs for <span class="Subfigure">AGE</span> and <span class="Subfigure">INCOME</span> do not fall with in the yuppie range, other lists such as <span class="Subfigure">(too old)</span>, <span class="Subfigure">(too poor)</span>, and <span class="Subfigure">(old and poor)</span> will be returned.  
			</p>

			<p>
				In addition to the nesting of <span class="Subfigure">cond</span> operations, Figure 9.14 introduces a number of other concepts.  The <span class="Subfigure">yuppie</span> function is the first function we’ve written that uses multiple input – two numeric atoms in this case, <span class="Subfigure">AGE</span> and <span class="Subfigure">INCOME</span>.  This function is also the first one to return a list, as opposed to an atom.
			</p>

			<p>
				By now you should have a pretty good feeling for both sequence and selection in Lisp functions.  Before we move on to the repetition control construct, two additional topics should be addressed.  The first is input/output.  The second is predicates for symbolic atoms and lists.
			</p>

			<p>
				Basic text-based input is achieved in Lisp by use of the <span class="Subfigure">read</span> function.  The read function returns one element, either an atom or a list, entered by the user while the program is running.
			</p>

			<p class="Blockcenter">
				(defun yuppie (AGE INCOME)
			</p>
			<p>
				<span class="Subblockcenter">  </span>(cond (( &lt; AGE 40)  
			</p>
			<p>
				<span class="Subfigure">                (cond ((&gt;= INCOME 50000)(quote </span><span class="T11">(yuppie)</span><span class="Subfigure">))</span>
			</p>
			<p>
				<span class="Subfigure">                         (        T        (quote </span><span class="T11">(too poor)</span><span class="Subfigure">))))</span>
			</p>
			<p>
				<span class="Subfigure">  </span><span>    (    T          </span>
			</p>
			<p>
				<span class="Subfigure">                (cond ((&gt;= INCOME 50000)(quote </span><span class="T11">(too old)</span><span class="Subfigure">))</span>
			</p>
			<p>
				<span class="Subfigure">                         (        T        (quote </span><span class="T11">(old and poor)</span><span class="Subfigure">))))</span>
			</p>
			<p>
				)
			</p>
			<p>
				)
			</p>

			<p class="Figure">
				Figure 9.14:  A Lisp program that illustrates nested conditions
			</p>

			<p class="Footnote">
				<span class="footnodeNumber"><a class="Footnote" id="ftn1" href="#body_ftn1">1</a></span> The oldest high-level language still in widespread use today is FORTRAN, though like LISP modern dialects of FORTRAN contain many features absent from earlier versions.
			</p>
			<p class="Footnote">
				<span class="footnodeNumber"><a class="Footnote" id="ftn2" href="#body_ftn2">2</a></span> Although I have not yet shown you how to bind a value to a symbol, know that it is possible.  We will look into ways of doing this in the next section.
			</p>
			<!-- End Main content -->
			<nav>
				<p>
					--
				</p>
				<p>
					<a href="index.html">Home</a>
				</p>
				<p>
					<a href="mailto:someone@example.com?Subject=Hello%20again" target="_top"> Contact</a>
				</p>
			</nav>

			<div>

			</div>

		</div>
	</body>
</html>
