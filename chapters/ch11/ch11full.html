<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">

		<!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame
		Remove this if you use the .htaccess -->
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

		<title>Watson</title>

		<!-- Google fonts -->
	    <link href='http://fonts.googleapis.com/css?family=Exo+2' rel='stylesheet' type='text/css'>
	    <!-- CSS files -->
	    <link href = "css/bootstrap.css" rel = "stylesheet">
	    <link href = "css/styles.css" rel = "stylesheet">
	    <link href = "css/generalmedia.css" rel = "stylesheet">
	    <!-- Java Script files -->
	    <script type="text/javascript" src="js/jquery-1.10.2.min.js"></script>
	    <script type="text/javascript" src="js/bootstrap.min.js"></script>
	    
		<meta name="description" content="">
		<meta name="author" content="Burt">

		<meta name="viewport" content="width=device-width; initial-scale=1.0">

	</head>

	<body>
		<div id="wrapper">
			<a id="tippytop"></a>
			<!-- Header division -->

			<div id="includedContent"></div>
              <script type="text/javascript" src="js/nav.js"></script>

			<!--Floating nav -->
		      <!-- Previous -->
		      <style>
		        div.floating-previous
		        {position:fixed;z-index:200;left:1px; right: auto; width:20px;top:45%;}
		        div.floating-previous a, div.floating-menu h3 {display:block;margin:0 0.5em;}
		      </style>
		      <div class="floating-previous">
		        <a href="../ch10/ch10.html">
		          <img id="larrow" style="border:0;" src="Images/left-arrow-blue.png" alt="Previous page" width="40">
		        </a>
		      </div>
		
		      <!-- Next -->
		      <style>
		        div.floating-next
		        {position:fixed;z-index:200; left: auto; right:1px; top:45%;}
		        div.floating-next a, div.floating-menu h3 {display:block;margin:0 0.5em;}
		      </style>
		      <div class="floating-next">
		        <a href="../ch12/ch12.html">
		          <img id="rarrow" style="border:0;" src="Images/right-arrow-blue.png" alt="Next page" width="40">
		        </a>
		      </div>
		    <!-- End floating nav -->
			<!-- End nav -->
			<!-- Main content -->
			
			<p> 
				&nbsp; 
			</p>
	
			<p class="Section">
				11.1  Introduction
			</p>
			
			<p>
				This chapter examines programming at its lowest levels.  Since “low-level” programming is inextricably tied to the capabilities and features of the machines being programmed, this chapter includes details on the organization of computers at the machine level.
			</p>
			
			<p>
				Section 11.2 presents a brief overview of the principle features of register-based machines, using the Watson Virtual Machine as a model.  We will try to avoid getting bogged down in too many details in this section, preferring instead to move quickly to Section 11.3, which provides an introduction to assembly language programming.  The assembly level is the lowest level of code that humans normally interact with.  
			</p>
			
			<p>
				Section 11.4 contains a rather detailed presentation of how various types of data, such as numbers, characters, and images, can be represented at the machine level.  This section also examines how basic numeric operations, such as addition and multiplication, can be performed.
			</p>
			
			<p>
				Section 11.5 fills in some of the details concerning the architecture of register-based machines, outlined in Section 11.2.  The Watson Virtual Machine is used as a guide to explore the translation of programs from the assembly level to the machine level.  Machine level is the lowest level of software.  At this level, programs and data are represented as strings of 1’s and 0’s.  Finally, the concept of the instruction cycle and details of how machine language programs are actually executed are described.
			</p>
			
			<p class="Section">
				11.2 Register-based machines 
			</p>
			
			<p>
				The general organization of a machine is often referred to as its <span class="Ital">architecture</span>.  Over the years, computer scientists and engineers have explored a wide variety of computer architectures.  This section introduces the most popular architecture – the register-based machine.  Our study of register-based machines will be aided by reference to the Watson Virtual Machine.  While the Watson Virtual Machine (VM) is a “toy” computer, designed solely for the purpose of instruction, it embodies most of the major features of register-based machines and does exist as a fully programmable software simulation (the Watson assembly lab).
			</p>
			
			<p>
				The Watson Virtual Machine is presented in Figure 11.1.  The Watson VM consists of two major parts: a main memory and a CPU (Central Processing Unit).  These two components are connected together via a third component, called the data bus, which allows information to be copied between the CPU and main memory.
			</p>

			<img src="Images/AssemblyIMGS/fig11-1.png" alt="" class="Image">
			
			<p class="Figure">
				Figure 11.1:  The Watson Virtual Machine
			</p>
			
			<p>
				The purpose of <span class="Ital">main memory</span> is to store computer programs and the data on which they act.  The main memory of the Watson Virtual Machine can be visualized as a list, or array, of 256 storage locations, numbered 0 to 255.  Each of these locations is individually addressable.  In other words, the main memory unit can be given an address and told to retrieve a value from that location, or be given an address and told to write a value to that location.  
			</p>
			
			<p>
				The purpose of the <span class="Ital">Central Processing Unit</span>, or CPU, is to perform the arithmetic and logic functions specified by the instructions of a computer program.  CPU’s are complex devices composed of many functional units.  One of the most prominent features of the CPU’s of register-based machines is a large collection of general-purpose registers.  The Watson Virtual Machine contains sixteen of these registers – labeled 0-9 and A-F.
			</p>
			
			<p>
				Registers can be directly manipulated by the arithmetic and logic units of the CPU.  Main memory locations cannot.  Thus, in order to perform any kind of arithmetic or logic operation on values stored in main memory it is necessary to copy those values into CPU registers, manipulate the contents of the registers in the desired way, and then copy the computed results back to main memory.  For example, in order to add two numbers stored in main memory locations, the computer must:
			</p>
			
			<ol>
				<li>
					Copy the values of both numbers from main memory into separate CPU registers, 
				</li>
				<br/>
				<li>
					Add the contents of those registers, placing the result into yet another register, 
				</li>
				<br/>
				<li>
					Copy the result of the addition operation back into a main memory location. 
				 </li>
			</ol>
			
			<p>
				In addition to the general-purpose registers, there are a number of special-purpose registers important to the operation of the CPU.  These registers include the instruction register, the program counter, and the status bits.  The <span class="Ital">instruction register</span> holds a copy of the program instruction that the CPU is currently executing.  The <span class="Ital">program counter</span> contains the address of the next instruction to be executed.  The <span class="Ital">status bits</span> are used to hold information about the most recently performed computation – was a carry generated? Was the result zero? Or negative? Did an overflow occur?
			</p>
			
			<p>
				We’ll not worry too much about these special-purpose registers right now.  They are described in detail in Section 11.5.  At this point, I just want you to know they exist.
			</p>
			
			<p>
				Real world computers are similar to the Watson Virtual machine in that they contain a main memory, CPU, and data bus.  The Watson Virtual Machine differs from real machines in that it has no I/O devices (such as keyboards, display screens, mice, and modems); nor any long-term storage devices (like disk drives).  The size of its memory is also very small, containing only 256 “words”.  Modern computers typically have memories capable of storing hundreds of millions of words.  There are other differences between the Watson VM and real-world computers, such as the size of the numbers it can manipulate and the limited number of commands in its machine language. 
			</p>
			
			<p class="Section">
				11.3 Assembly language programming 
			</p>
			
			<p>
				This section explores how the Watson Virtual Machine can be programmed at the assembly level.  The assembly level is the lowest level at which human programmers normally interact with a machine.  Assembly languages were developed in the 1950’s to free humans from having to program computers in their native machine languages of 0’s and 1’s.  
			</p>
			
			<p>
				While assembly languages were a great leap forward and are much easier to read and write than machine languages, such languages are still tied very closely to the underlying machine they were designed for.  Thus, the assembly language you will learn in this section is specific to the Watson VM.  However, since the Watson VM incorporates most of the features found in today’s microprocessors, learning to program a real machine – such as an x86 microprocessor – will be much easier after covering the basics here.
			</p>
			
			<p class="Section">
				11.3.1  An overview of the Watson Assembly Language
			</p>
			
			<p>
				The Watson assembly language consists of 18 instructions, which can be divided into six groups.  These instructions are summarized in Figure 11.2.  Here I will provide a brief overview of these instructions.  The remainder of this section is devoted to exploring these instructions in much more depth and examining at how they can be used in simple assembly language programs.
			</p>
			
			<p>
				The first group of Watson assembly instructions are the variable declaration statements: <span class="Subfigure">.BLOCK</span> and <span class="Subfigure">.WORD</span>.  These are both used to reserve memory locations for data storage.  They differ in that <span class="Subfigure">.WORD</span> can reserve only a single word of memory, while <span class="Subfigure">.BLOCK</span> can reserve multiple words.   Another difference is that <span class="Subfigure">.WORD</span> can initialize its storage location to a specified value.  The <span class="Subfigure">.BLOCK</span> command is not capable of initializing the memory locations it reserves.
			</p>
			
			<p>
				The next group of instructions, the input and output instructions, are used to copy values between main memory and the general-purpose registers.  There are three “load” commands that copy information into registers: <span class="Subfigure">LOAD</span>, <span class="Subfigure">LOADIMM</span>, and <span class="Subfigure">LOADIND</span>.  Two “store” commands, <span class="Subfigure">STORE</span> and <span class="Subfigure">STOREIND</span>, copy information from the registers into main memory.  The various forms of the load and store commands and the differences between them are examined below.
			</p>
			
			<p>
				The math operations <span class="Subfigure">ADD</span> and <span class="Subfigure">SUBTRACT</span> form the next group of Watson assembly language instructions.  These instructions behave pretty much the way you would expect.  <span class="Subfigure">ADD</span> adds the contents of two registers together and places the sum into a specified register.  <span class="Subfigure">SUBTRACT</span> subtracts the contents of one register from another placing the result into a specified register.
			</p>
			
			<ul class="Blockcenter">
				<li><span class="Subfigure"><h3>Watson Assembly Language Instructions</h3></span></li>
				<br/>
				<li><span class="Subfigure">Variable Declarations</span></li>
				<ul class="Subblockcenter">
					<li><span class="Subfigure"><span class="Ital">label</span>        .BLOCK <span class="Ital">size</span></span></li>
					<li><span class="Subfigure"><span class="Ital">label</span>        .WORD  <span class="Ital">initial value</span></span></li>
				</ul>
				<br/>
				<li><span class="Subfigure">Input / Output Instructions</span></li>
				<ul class="Subblockcenter">
					<li><span class="Subfigure">LOADIMM        <span class="Ital">destination register</span>, <span class="Ital">value</span></span></li>
					<li><span class="Subfigure">LOAD           <span class="Ital">destination register</span>, <span class="Ital">source variable label</span></span></li>
					<li><span class="Subfigure">STORE          <span class="Ital">source register</span>, <span class="Ital">destination variable label</span></span></li>
					<li><span class="Subfigure">LOADIND        <span class="Ital">destination register</span>, <span class="Ital">source location register</span></span></li>
					<li><span class="Subfigure">STOREIND       <span class="Ital">source register</span>, <span class="Ital">destination location register</span></span></li>
				</ul>
				<br/>
				<li><span class="Subfigure">Math Operations</span></li>
				<ul class="Subblockcenter">
					<li><span class="Subfigure">ADD        <span class="Ital">result register</span>, <span class="Ital">first operand register</span>, <span class="Ital">second operand register</span></span></li>
					<li><span class="Subfigure">SUBTRACT   <span class="Ital">result register</span>, <span class="Ital">first operand register</span>, <span class="Ital">second operand register</span></span></li>
				</ul>
				<br/>
				<li><span class="Subfigure">Logic Operations</span></li>
				<ul class="Subblockcenter">
					<li><span class="Subfigure">AND        <span class="Ital">result register</span>, <span class="Ital">first operand register</span>, <span class="Ital">second operand register</span></span></li>
					<li><span class="Subfigure">OR         <span class="Ital">result register</span>, <span class="Ital">first operand register</span>, <span class="Ital">second operand register</span></span></li>
					<li><span class="Subfigure">NOT        <span class="Ital">result register</span>, <span class="Ital">operand register</span></span></li>
				</ul>
				<br/>
				<li><span class="Subfigure">Shift Operations</span></li>
				<ul class="Subblockcenter">
					<li><span class="Subfigure">ASL        <span class="Ital">result register</span>, <span class="Ital">operand register</span>, <span class="Ital">number of bits</span></span></li>
					<li><span class="Subfigure">ASR        <span class="Ital">result register</span>, <span class="Ital">operand register</span>, <span class="Ital">number of bits</span></span></li>
				</ul>
				<br/>
				<li><span class="Subfigure">Program Control Operations</span></li>
				<ul class="Subblockcenter">
					<li><span class="Subfigure">COMPARE       <span class="Ital">first operand register</span>, <span class="Ital">second operand register</span></span></li>
					<li><span class="Subfigure">BRANCH        <span class="Ital">test condition</span>, <span class="Ital">target label</span></span></li>
					<li><span class="Subfigure">JUMP          <span class="Ital">target label</span></span></li>
					<li><span class="Subfigure">HALT</span></li>
				</ul>
			</ul>
			
			<p class="Figure">
				Figure 11.2:  The Watson Assembly Language
			</p>
			
			<p>
				Discussion of the next two groups of Watson assembly language instructions, the logic and shift operators, is deferred to Section 11.5.  The reason for doing so is that it is difficult to say much about these statements without some understanding of data representation at the machine level, which is covered in Section 11.4.
			</p>
			
			<p>
				The final group of Watson assembly language instructions is the program control statements.  These commands determine which program instruction, if any, will be executed next.  <span class="Subfigure">HALT</span> is the most straightforward statement of this group.  It causes program execution to terminate.  For this reason, <span class="Subfigure">HALT</span> is normally the last statement executed by a program.  <span class="Subfigure">JUMP</span> is pretty easy to understand as well.  It breaks out of the normal sequence of program execution and causes control to “jump” immediately to a specified instruction.  <span class="Subfigure">COMPARE</span> and <span class="Subfigure">BRANCH</span> are usually used together to implement a “conditional branch”.  Essentially, <span class="Subfigure">COMPARE</span> will compare the values held in two registers and set the machine’s status bits.  <span class="Subfigure">BRANCH</span> then examines these bits to determine whether a particular condition is true (e.g., <span class="Subfigure">A == B</span>).  If the condition is true control is transferred to a specified instruction.  If the condition is not true the statement has no effect.  Conditional branches are the low level equivalent of the “if” statement.
			</p>
			
			<p>
				Don’t be overly concerned if the behavior and usefulness of each of the above instructions isn’t immediately obvious.  We’re just “looking at the roadmap” here.  The details of each statement are presented throughout the remainder of this chapter.
			</p>
			
			<p class="Section">
				11.3.2 Variables, assignment, and sequence 
			</p>
			
			<p>
				This part of Section 11.3 explores how the instructions presented above can be used to construct simple assembly language programs.  The programs we describe here will be limited to declaring and initializing variables, simple assignment, and sequence.  Later parts of this section examine more advanced concepts, such as how selection and repetition can be implemented in assembly language
			</p>
			
			<p>
				Figure 11.3 contains a complete assembly language program that implements the high-level language assignment statement:
			</p>
			
			<p class="Subfigure">
				total = abc + xyz;
			</p>
			
			<p>
				This statement is written in the Watson JavaScript language, which was introduced in Chapter 8, as are all other high-level language statements used in this chapter.  As you will recall from your study of JavaScript, this statement adds the current value of the variable <span class="Subfigure">abc</span> to the current value of the variable <span class="Subfigure">xyz</span> and places the result into the variable <span class="Subfigure">total</span>.  Of course, <span class="Subfigure">abc</span> and <span class="Subfigure">xyz</span> must contain valid data when this statement is executed in order for a meaningful result to be assigned to <span class="Subfigure">total</span>.  Let’s assume for the purposes of this example that <span class="Subfigure">abc</span> contains the value 2 and <span class="Subfigure">xyz</span> the value 3.  After this statement executes the value of <span class="Subfigure">total</span> should be 5.
			</p>
			
			
			<img src="Images/AssemblyIMGS/fig11-3.png" alt="" class="Image">
						
			<p class="Figure">
				Figure 11.3:  Assembly language version of the statement:  <span class="Subfigure">total = abc + xyz;</span>
			</p>
			
			<p>
				How can the actions of this high-level assignment statement be implemented using low-level assembly language instructions?
			</p>
			
			<p>
				The first thing that must be addressed is how variables such as <span class="Subfigure">total</span>, <span class="Subfigure">abc</span>, and <span class="Subfigure">xyz</span> can be set up and initialized.  As you know, variables are simply “named locations in memory that hold a value of a particular type.”  The Watson Assembly Language supports only one type of data, integers.<span class="Footnote" title="Footnote: Represented as two’s complement binary numbers. See Section 11.4.1 for details."><a href="#ftn1" id="body_ftn1">[1]</a></span> Hence all that need concern us here is the fact that a variable is a named location in memory.
			</p>
			
			<p>
				Watson Assembly Language contains two separate statements for “reserving” and naming memory locations.  These statements are: <span class="Subfigure">.BLOCK</span> and <span class="Subfigure">.WORD</span>.  They have the following general forms:
			</p>
			
			<ul class="Blockcenter">
				<li><span class="Subfigure"><span class="Ital">label</span>        .BLOCK <span class="Ital">size</span></span></li>
				
				<li><span class="Subfigure"><span class="Ital">label</span>        .WORD  <span class="Ital">initial value</span></span></li>
			</ul>
			
			<p>
				The first statement, <span class="Subfigure">.BLOCK</span>, reserves a block of memory some number of words long and gives that block a label or name by which it may be referred.  A “word” is the amount of space normally needed to store an integer value.  So, for example, the statement:
			</p>
			
			<p class="Subfigure">
				TOTAL  .BLOCK  1
			</p>
			
			<p>
				reserves a block of memory one word long and gives it the name “total”.  The effect of this statement is essentially to declare a variable named “total”.  Hence, it is roughly equivalent to the Watson JavaScript statement:
			</p>
			
			<p class="Subfigure">
				var total; // Numeric
			</p>
			
			<p>
				with the exception that the variable “total” can only hold whole numbers (not fractions) since Watson Assembly Language supports integers as its only “data type”.
			</p>
			
			<p>
				While the <span class="Subfigure">.BLOCK</span> statement declares a variable, it does <span class="Ital">not</span> initial it.  To both declare and initialize a variable, the Watson Assembly Language includes a <span class="Subfigure">.WORD</span> statement.  The <span class="Subfigure">.WORD</span> statement always reserves exactly one word of memory for a variable but it also allows the programmer to specify an initial value for that variable.  For example, the statements:
			</p>
			
			<p class="Subfigure">
				ABC  .WORD  2
			</p>
			
			<p class="Subfigure">
				XYZ  .WORD  3
			</p>
			
			<p>
				not only reserve one word of memory for each of the variables <span class="Subfigure">ABC</span> and <span class="Subfigure">XYZ</span>, but also initialize <span class="Subfigure">ABC</span> to the integer value 2 and <span class="Subfigure">XYZ</span> to the integer value 3.  These statements have essentially the same effect as the Watson JavaScript statements:
			</p>
			
			<ul class="Blockcenter">
				<li><span class="Subfigure">var abc; // Numeric</span></li>
				<li><span class="Subfigure">var xyz; // Numeric</span></li>
				<br/>
				<li><span class="Subfigure">abc = 2;</span></li>
				<li><span class="Subfigure">xyz = 3;</span></li>
			</ul>
			
			<p>
				in that both groups of statements declare the variables and initialize them.  There are, however, subtle differences in the ways these two groups of statements accomplish their goals.  The high-level statements first declare the variables and then, in separate statements, initialize those variables.  The assembly language statements declare and initialize the variable in a single “step”.  Since Watson JavaScript does not support declaring and initializing variables in a single instruction, there is no “direct” translation of <span class="Subfigure">.WORD</span> to Watson JavaScript.  Regardless, these four Watson JavaScript statements do accomplish the same tasks that the two <span class="Subfigure">.WORD</span> assembly statements do.<span class="Footnote" class="Superscript" title="Footnote: It should be noted that true JavaScript, as well as many other common programming languages, like Java and C++, do support the ability to declare and initialize variables in a single statement."><a href="#ftn2" id="body_ftn2">[2]</a></span>
			</p>
			
			<p>
				Now that we have seen how variables can be declared and initialized in assembly language, we can return to the problem at hand, which is trying to figure out how the assignment statement:  <span class="Subfigure">total = abc + xyz;</span>  can be translated into assembly language.
			</p>
			
			<p>
				Like most assembly languages, Watson Assembly Language has very limited support for directly manipulating the values stored in the computer’s main memory.  Operations involving main memory are essentially limited to copying information back and forth between CPU registers and memory locations.  The operation of copying a value from a memory location to a CPU register is known as “loading” a register.  Copying the contents of a CPU register into a memory location is known as “storing” a register.
			</p>
			
			<p>
				As discussed in Section 11.2, all mathematical and logical operations supported by the Watson Virtual Machine must be performed on registers, not memory locations.  This means that variables (named locations in memory) cannot be directly manipulated in Watson Assembly Language.  Instead, in order to use the contents of a variable, the value of that variable must first be copied into a register.  The register may then be used as a “stand in” for the actual variable in mathematical and logical operations.  If the contents of the register that represents the variable changes in any way, then the contents of that register must be copied back to the variable’s main memory location.  
			</p>
			
			<p>
				So, in order to add <span class="Subfigure">ABC</span> and <span class="Subfigure">XYZ</span> together, each must first be loaded into a register.  The general form of the <span class="Subfigure">LOAD</span> statement is:
			</p>
			
			<p class="Subfigure">
				LOAD                <span class="Ital">destination register</span>, <span class="Ital">source variable label</span>
			</p>
			
			<p>
				The Watson Virtual Machine supports sixteen general-purpose registers labeled 0-9 and A-F.  As long as we ensure that <span class="Subfigure">ABC</span> and <span class="Subfigure">XYZ</span> are placed into <span class="Ital">different</span> registers, it does not matter which registers we choose. (If we tried to place both values into the same register, the first value would be destroyed when the second was loaded.)  The following two assembly language instructions copy the values held in the memory locations labeled <span class="Subfigure">ABC</span> and <span class="Subfigure">XYZ</span> into registers D and E, respectively.
			</p>
			
			<p class="Subfigure">
				LOAD REGD, ABC
			</p>
			
			<p class="Subfigure">
				LOAD REGE, XYZ
			</h2>
			
			<p>
				The first statement may be read as “load into register D the value of variable <span class="Subfigure">ABC</span>”.  The second one reads similarly.  After these statements execute, register D will contain the value 2 and register E will contain the value 3, since <span class="Subfigure">ABC</span> was initialized to 2 in its <span class="Subfigure">.WORD</span> declaration and <span class="Subfigure">XYZ</span> was initialized to 3 in its <span class="Subfigure">.WORD</span> declaration.
			</p>
			
			<p>
				We are now ready to add the two values together. The form of the <span class="Subfigure">ADD</span> statement is:
			</p>
			
			<p class="Subfigure">
				ADD   <span class="Ital">result register</span>,<span class="Ital"> first operand register</span>,<span class="Ital">  second operand register</span>
			</p>
			
			<p>
				Any of the sixteen general-purpose registers in the Watson Virtual Machine could serve as the result register, including register D or E.  Assuming we choose register F to hold the result, the <span class="Subfigure">ADD</span> statement would have the following form:
			</p>
			
			<p class="Subfigure">
				ADD  REGF, REGD, REGE
			</p>
			
			<p>
				When this statement is encountered register D will contain a 2 and register E will contain a 3, so the value 5 will be placed into register F.
			</p>
			
			<p>
				Many people find the form of the <span class="Subfigure">ADD</span> statement initially confusing due to the fact that the result register is listed first.  Their confusion often clears up when they realize that the registers are in exactly the same order that they would appear if the <span class="Subfigure">ADD</span> statement were written in a more “high-level” syntax like:
			</p>
			
			<p class="Subfigure">
				<span class="Ital">result register</span> = <span class="Ital">first operand register</span> + <span class="Ital">second operand register </span>;
			</p>
			
			<p>
				or in the current example:
			</p>
			
			<p class="Subfigure">
				REGF = REGD + REGE ;
			</p>
			
			<p>
				At this point, the value of variables <span class="Subfigure">ABC</span> and <span class="Subfigure">XYZ</span> have been successfully added; their sum placed into register F.  All that remains is for this sum to be stored into the variable <span class="Subfigure">TOTAL</span>.  The general form of the <span class="Subfigure">STORE</span> statement is:
			</p>
			
			<p class="Subfigure">
				STORE          <span class="Ital">source register</span>, <span class="Ital">destination variable label</span>
			</p>
			
			<p>
				In order to store the contents of register F into the memory location associated with the variable <span class="Subfigure">TOTAL</span>, a statement of the following form will be required:
			</p>
			
			<p class="Subfigure">
				STORE  REGF, TOTAL
			</p>
			
			<p>
				Finally, the <span class="Subfigure">HALT</span> statement, which signals the logical end of the program, must be included in the program.  Execution of the program ceases whenever the Watson Virtual Machine encounters a HALT statement.
			</p>
			
			<p>
				To briefly recap, the Watson Assembly Language program of Figure 11.3 implements the assignment statement<span class="Subfigure"> total = abc + xyz; </span>by loading the value of <span class="Subfigure">ABC</span> into register D and the value of <span class="Subfigure">XYZ</span> into register E.  The contents of both of these registers are added together with the sum placed into register F.  The contents of register F are then stored into variable <span class="Subfigure">TOTAL</span> and the program halts.  This process of copying values from the main memory locations that represent variables into CPU registers, manipulation of those values by “register-based” instructions, and then copying of results back to main memory is typical of most assembly language programs.
			</p>
			
			<p>
				Another assembly language program is presented in Figure 11.4.  This program is similar to the program of Figure 11.3 in that it too implements a single high-level assignment statement.  In this case the statement is:  <span class="Subfigure">x = x - 1;</span>
			</p>
			
			<p>
				The assembly language program begins by declaring the variable <span class="Subfigure">X</span> and initializing it to 15, in preparation for implementing the actions of the assignment statement.  The second line of the program loads the value currently held in <span class="Subfigure">X</span>, 15, into register A.  The third line of the program loads the value 1 into register B via the “load immediate” statement:
			</p>
			
			<p class="Subfigure">
				LOADIMM REGB, 1
			</p>
			
			<p>
				The general form of the load immediate statement is: 
			</p>
			
			<p class="Subfigure">
				LOADIMM        <span class="Ital">destination register</span>, <span class="Ital">value</span>
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-4.png" alt="" class="Image">
						
			<p class="Figure">
				Figure 11.4: Assembly language version of the statement:  <span class="Subfigure">x = x - 1;</span>
			</p>
			
			<p>
				While the standard version of the <span class="Subfigure">LOAD</span> statement contains the <span class="Ital">label</span> of the memory location where the value to be loaded is held, the <span class="Subfigure">LOADIMM</span> statement includes the <span class="Ital">value</span> to be loaded directly in the statement – the value to be loaded appears in the statement “immediately” following the destination register.  Load immediate statements are quite useful, but the values they can contain are generally limited to a rather narrow range.  For example, the Watson Assembly Language limits load immediate values to the range –128 to +127.
			</p>
			
			<p>
				The fourth line of the program 
			</p>
			
			<p class="Subfigure">
				SUBTRACT REG0, REGA, REGB
			</p>
			
			<p>
				subtracts the value held in register B from the value held in register A and places the difference in register 0.  Since register A contains 15 (the current value of <span class="Subfigure">X</span>) and register B contains 1, the value 14 will be placed into register 0 when this statement executes.  
			</p>
			
			<p>
				The general form of the subtract statement is:
			</p>
			
			<p class="Subfigure">
				SUBTRACT   <span class="Ital">result register</span>, <span class="Ital">first operand register</span>, <span class="Ital">second operand register</span>
			</p>
			
			<p>
				As with the <span class="Subfigure">ADD</span> statement, the registers of <span class="Subfigure">SUBTRACT</span> appear in the same order they would if the statement were written in a more “high-level” form such as:
			</p>
			
			<p class="Subfigure">
				<span class="Ital">result register</span> = <span class="Ital">first operand register</span> - <span class="Ital">second operand register </span>;
			</p>
			
			<p>
				Keeping this “high-level” form of the <span class="Subfigure">SUBTRACT</span> statement in mind should help you to remember the correct order of the registers.
			</p>
			
			<p>
				The fifth line of the program of Figure 11.4 copies the contents of register 0 into the main memory location associated with the variable <span class="Subfigure">X</span>.  This line has the effect of updating the value of the <span class="Subfigure">X</span> to be one minus its previous value, thus completing the actions of the high-level assignment statement.  Finally, line six of the program issues the <span class="Subfigure">HALT</span> command causing execution to terminate.
			</p>
			
			<p class="Section">
				Exercises for Section 11.3.2
			</p>
			
			<ol>
				<li>
					<p>Write an assembly language program to implement the high-level assignment statement: </p>
					
					<p class="Subfigure">diff = xyz – abc;</p>
				</li>
				<li>
					<p>Write an assembly language program to implement the high-level assignment statement: </p>
					
					<p class="Subfigure">num = num + 4;</p>
				</li>
				<li>
					<p>Write an assembly language program to implement the high-level assignment statement: </p>
					
					<p class="Subfigure">A = ( B + C ) -  D;</p>
				</li>
				<li>
					<p>Write an assembly language program to implement the high-level assignment statement: </p>
					
					<p class="Subfigure">A = 2 * ( B + C );</p>
				</li>
			</ol>
			
			<p class="Section">
				11.3.3 Implementing selection constructs in assembly language 
			</p>
			
			<p>
				Now that we have a basic understanding of variables, assignment, and sequence in assembly language programs, we turn our attention to the issue of implementing the high-level selection, or “if”, construct.  Figure 11.5 contains an assembly language program that determines whether an individual is a minor or not based on his or her age.  In this example, the value “1” is used to mean “true” and the value “0” false.  
			</p>
			
			<p>
				The high-level code segment begins by assigning a “0” to “minor”, indicating that the individual is initially assumed to be an adult.  The value held in the “age” variable is then compared to 18 and if “age” is less than 18, “minor” is set to “1” indicating the individual is now known to be a minor.  Otherwise, “minor” is left unchanged; it retains its initial value of 0 meaning the individual is not a minor. 
			</p>
			
			<p>
				The assembly language program that implements this high-level code segment introduces two new instructions: <span class="Subfigure">COMPARE</span> and <span class="Subfigure">BRANCH</span>.   These two statements can be used together to implement the semantics of high-level “if” constructs.  The program also illustrates that any statement in an assembly language program may have a label associated with it, not just <span class="Subfigure">.BLOCK</span> and .<span class="Subfigure">WORD</span> statements.
			</p>
			
			<!-- Start of figure 11-5
			<p>
				High-level Watson JavaScript code:
			</p>
			
			<ul class="Blockcenter">
				<li><span class="Subfigure">minor = 0;</span></li>
				<li><span class="Subfigure">if (age &lt; 18)</span></li>
				<li><span class="Subfigure">{</span></li>
				<ul class="Subblockcenter">
					<li><span class="Subfigure">minor = 1;</span></li>
				</ul>
				<li><span class="Subfigure">}</span></li>
			</ul>
			-->
			
			<img src="Images/AssemblyIMGS/fig11-5.png" alt="" class="Image">

			<!--
			<p><span class="Subfigure">AGE        .WORD     2                        </span>;  declare and initialize “age” to 2.  Our subject is 2 years old.</p>
			
			<p><span class="Subfigure">MINOR .BLOCK    1                        </span>;  declare “minor”.</p>
			
			<p class="P73"><span class="Subfigure">LOADIMM   REG0, 0            </span>;  load the constant value 0 into register 0.</p>
			
			<p class="P73"><span class="Subfigure">STORE     REG0, MINOR        </span>;  store a zero into “minor” – i.e., minor is assumed “false”.</p>
			
			<p><span class="Subfigure">IF        LOAD      REGA, AGE           </span>;  load the value of variable “age” into register A.</p>
			
			<p class="P73"><span class="Subfigure">LOADIMM   REGB, 18        </span>;  load the constant value 18 into register B.</p>
			
			<p class="P73"><span class="Subfigure">COMPARE   REGA, REGB        </span>;  compare registers A &amp; B – i.e., the value of “age” to 18.</p>
			
			<p class="P73"><span class="Subfigure">BRANCH    LT, THEN          </span>;  IF “age” is less than 18 branch to “then”.</p>
			
			<p class="P73"><span class="Subfigure">JUMP            ENDIF                </span>; otherwise jump to the end of the if block – “endif”</p>
			
			<p><span class="Subfigure">THEN        LOADIMM   REG1, 1                </span>; THEN: load the constant value 1 into register 1.</p>
			
			<p class="P73"><span class="Subfigure">STORE     REG1, MINOR        </span>;              store a one into “minor” – i.e., minor is “true”.</p>
			
			<p><span class="Subfigure">ENDIF        HALT                                </span>;  halt execution of this assembly language program.</p>
			-->
			<p class="Figure">
				Figure 11.5: High-level and assembly code to determine whether a person is a minor.
			</p>
			
			<p>
				Let’s now walk through the actions of this assembly language program.  First, the variables <span class="Subfigure">AGE</span> and <span class="Subfigure">MINOR</span> are declared.  Since <span class="Subfigure">AGE</span> must be initialized to some valid value, I arbitrarily decided to set it to 2 via the <span class="Subfigure">.WORD</span> command.  (In other words, I am assuming the person currently being “processed” is two years old.)  <span class="Subfigure">MINOR</span> is declared via <span class="Subfigure">.BLOCK</span> since its value will be set within the code.
			</p>
			
			<p>
				Once the variables have been declared and age initialized, the high-level statement that sets <span class="Subfigure">MINOR</span> to zero can be implemented.  This task can be accomplished by loading a zero into a register (via <span class="Subfigure">LOADIMM</span>) and then storing (via <span class="Subfigure">STORE</span>) that register’s value into the main memory location labeled <span class="Subfigure">MINOR</span>. 
			</p>
			
			<p>
				At this point you might be wondering why I didn’t simply declare <span class="Subfigure">MINOR</span> to be zero via:
			</p>
			
			<p class="Subfigure">
				MINOR   .WORD  0
			</p>
			
			<p>
				While it is certainly true that the <span class="Subfigure">.WORD</span> statement initializes the value of <span class="Subfigure">MINOR</span> to zero, the statement does not quite reflect the exact meaning of the high-level language code. The high-level code does not declare <span class="Subfigure">MINOR</span> and initialize it as part of the declaration process (as the <span class="Subfigure">.WORD</span> statement does).  Instead, the high-level code places a value of zero into the variable “minor” via an explicit assignment statement.
			</p>
			
			<p>
				In general, <span class="Subfigure">.WORD</span> statements should not be used to implement the actions of assignment statements.  The <span class="Subfigure">.WORD</span> statement is a way of declaring a variable in assembly language and giving it an initial value at the same time.  Often, I use these initial values in the example programs to represent input values – such as an age of two in the current example.
			</p>
			
			<p>
				Now that <span class="Subfigure">MINOR</span> has been given its default value of 0, or “false”, we can turn our attention to the “if-then” construct.  The “if-then” construct consists of two distinct parts: the “if” condition test and the “then” actions (to be executed only if the condition is true).  This high-level construct can be built from <span class="Subfigure">COMPARE</span>, <span class="Subfigure">BRANCH</span> and <span class="Subfigure">JUMP</span> statements – together with two strategically placed instruction labels.  Under this scheme, the <span class="Subfigure">COMPARE</span> and <span class="Subfigure">BRANCH</span> instructions will be used to implement the condition test and to transfer control directly to the “then” actions if the condition is true.  The <span class="Subfigure">JUMP</span> will be used to skip over the “then” actions if the condition is false. 
			</p>
			
			<p>
				The general form of the <span class="Subfigure">COMPARE</span> statement is:
			</p>
			
			<p class="Subfigure">
				COMPARE        <span class="Ital">first operand register</span>, <span class="Ital">second operand register</span>
			</p>
			
			<p>
				The statement examines the values held in the two registers to determine the relationship that exists between them. Valid relationships include:
			</p>
			
			<ol>
				<li>first value is equal to the second value  (EQ)</li>
				<li>first value is not equal to the second value (NE)</li>
				<li>first value is less than the second value (LT)</li>
				<li>first value is less than or equal to second value (LE)</li>
				<li>first value is greater than the second value (GT)</li>
				<li>first value is greater than or equal to second value (GE)</li>
			</ol>
			
			<p>
				A <span class="Subfigure">BRANCH</span> instruction usually appears immediately following a <span class="Subfigure">COMPARE</span>.  The <span class="Subfigure">BRANCH</span> instruction is a low-level command that allows the Watson Virtual Machine to execute different parts of a program depending on the results of a test condition.  The general form of the <span class="Subfigure">BRANCH</span> instruction is:
			</p>
			
			<p class="Subfigure">
				BRANCH  <span class="Ital">test condition</span>, <span class="Ital">target label</span>
			</p>
			
			<p>
				where <span class="Ital">test condition</span> is usually one of the six conditions resulting from a <span class="Subfigure">COMPARE</span>: 
			</p>
			
			<p class="Subfigure">
				EQ,  NE,  LT,  LE,  GT,  GE
			</p>
			
			<p>
				and <span class="Ital">target label</span> is a label associated with a “target” instruction.  
			</p>
			
			<p>
				<span class="Subfigure">BRANCH</span> works in the following way.  If the <span class="Ital">test condition</span> is true then program control will branch to the target instruction and execution will continue from that point on.  If the test condition is false, the current sequence of instructions will not be interrupted – execution will continue with the statement immediate following the <span class="Subfigure">BRANCH</span>. 
			</p>
			
			<p>
				The general form of the <span class="Subfigure">JUMP</span> instruction is:
			</p>
			
			<p class="Subfigure">
				JUMP         <span class="Ital">target label</span>
			</p>
			
			<p>
				Both the <span class="Subfigure">JUMP</span> and <span class="Subfigure">BRANCH</span> statements are similar in that they are both used to break out of the normal sequential flow of control from one statement to the next.  The difference is that <span class="Subfigure">BRANCH</span> is a “conditional” statement.  It only transfers control to its target statement if its test condition is true.  <span class="Subfigure">JUMP</span>, on the other hand, is an “unconditional” statement.  It always transfers control its target statement.
			</p>
			
			<p>
				It is interesting to note that since <span class="Subfigure">JUMP</span> unconditionally transfers control to its target statement, in order for the statement that physically follows the <span class="Subfigure">JUMP</span> to ever be executed, it must contain a label that is the target of some other <span class="Subfigure">JUMP</span> or <span class="Subfigure">BRANCH</span> instruction.  Otherwise, the program will have no way of referencing that instruction.
			</p>
			
			<p>
				In the example of Figure 11.5, the variable <span class="Subfigure">AGE</span> is to be compared to the value 18.  In order to do so, the values must first be loaded into registers.  This is accomplished by loading <span class="Subfigure">AGE</span> into register A and issuing a load immediate of 18 into register B.  The actual statements to accomplish this task are:
			</p>
			
			<ul class="Blockcenter">
				<li><span class="Subfigure">IF &nbsp; LOAD      REGA, AGE </span></li>
				<li><span class="Subfigure">&nbsp;&nbsp;&nbsp;&nbsp; LOADIMM   REGB, 18</span></li>
			</ul>
			
			<p>
				Notice that the <span class="Subfigure">LOAD</span> statement has been labeled <span class="Subfigure">IF</span>, since it marks the beginning of the assembly language code for implementing the high-level “if” statement.  While this label isn’t strictly necessary in order to implement an “if” construct, it does make the assembly code somewhat easier to read.
			</p>
			
			<p>
				Once these values have been copied into the registers, they can be compared via:
			</p>
			
			<p class="Subfigure">
				COMPARE  REGA, REGB
			</p>
			
			<p>
				If the value held in register A (age) is <span class="Ital">less than</span> the value held in register B (18), the “then” instructions should be executed which will set <span class="Subfigure">MINOR</span> to 1, as the person is a minor.  The following assembly language instruction causes control to be transferred to the statement labeled <span class="Subfigure">THEN</span>.
			</p>
			
			<p class="Subfigure">
				BRANCH    LT,   THEN
			</p>
			
			<p>
				If the condition test is not true, the <span class="Subfigure">BRANCH</span> statement will have no effect and control will be transferred to the statement immediately following it.  Thus, in the event that age is not less than 18 (i.e., it is greater than or equal to 18) the statement
			</p>
			
			<p class="Subfigure">
				JUMP    ENDIF
			</p>
			
			<p>
				will be executed.  This statement will have the effect of “jumping” over the statements comprising the “then” block.
			</p>
			
			<p>
				Assuming the condition test was true, the “then” actions of the “if” construct are executed.  These actions place the value 1 into the variable <span class="Subfigure">MINOR</span>.
			</p>
			
			<ul class="Blockcenter">
				<li><span class="Subfigure">THEN &nbsp; LOADIMM   REG1, 1</span></li>
				<li><span class="Subfigure">&nbsp;&nbsp; &nbsp; &nbsp; STORE     REG1, MINOR</span></li>
			</ul>
			
			<p>
				The “then” code loads a 1 into register 1 via a load immediate statement, and then copies that value into the memory location associated with the variable <span class="Subfigure">MINOR</span> via the <span class="Subfigure">STORE</span> statement.  The result is that a 1 is placed into <span class="Subfigure">MINOR</span>.  Note that the load immediate statement sports a <span class="Subfigure">THEN</span> label.  This label is necessary for the program to execute properly since it is the target of the <span class="Subfigure">BRANCH</span> instruction.
			</p>
			
			<p>
				The final statement of this program serves as the target of the <span class="Subfigure">JUMP</span> instruction and is labeled <span class="Subfigure">ENDIF</span>.
			</p>
			
			<p class="Subfigure">
				ENDIF   HALT
			</p>
			
			<p>
				This statement will always execute when the program is run, regardless of whether the condition was true or false.
			</p>

			<img src="Images/AssemblyIMGS/fig11-6.png" alt="" class="Image">
			<!-- Text Figure
			<h4 class="Blockcenter">
				High-level Watson JavaScript code:
			</h4>
			<br/>
			<ul class="Blockcenter">
				<li><span class="Subfigure">if (age &lt; 18)</span></li>
				<li><span class="Subfigure">{</span></li>
				<ul class="Subblockcenter">
					<li><span class="Subfigure">minors = minors + 1;</span></li>
				</ul>
				<li><span class="Subfigure">}</span></li>
				<li><span class="Subfigure">else</span></li>
				<li><span class="Subfigure">{</span></li>
				<ul class="Subblockcenter">
					<li><span class="Subfigure">adults = adults + 1;</span></li>
				</ul>
				<li><span class="Subfigure">}</span></li>
			</ul>
			<br/>
			<h4 class="Blockcenter">
				Equivalent assembly language code:
			</h4>
			
			<p><span class="Subfigure">MINORS &nbsp; .WORD     0                    </span>; declare and initialize the number of “minors” to 0.</p>
			
			<p><span class="Subfigure">ADULTS &nbsp; .WORD     0                    </span>; declare and initialize the number of “adults to 0.</p>
			
			<p><span class="Subfigure">AGE &nbsp;&nbsp;&nbsp;&nbsp; .WORD     21                   </span>; declare and initialize the “age” of the person to 21.</p>
			
			<p><span class="Subfigure">IF        LOAD     REGA, AGE            </span>; load the value of variable “age” into register A.</p>
			
			<p><span class="Subfigure">          LOADIMM  REGB, 18             </span>; load the constant value 18 into register B.</p>
			
			<p><span class="Subfigure">          COMPARE  REGA, REGB           </span>; compare registers A &amp; B – i.e., the value of “age” to 18</p>
			
			<p><span class="Subfigure">          BRANCH   LT,   THEN           </span>; IF “age” is less than 18 branch to “then”.</p>
			
			<p><span class="Subfigure">          JUMP     ELSE                 </span>; otherwise jump to “else”.</p>
			
			<p><span class="Subfigure">THEN     LOAD     REG0, MINORS         </span>; THEN: load the number of minors into register 0.</p>
			
			<p><span class="Subfigure">          LOADIMM  REG1, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span>;  load the constant value 1 into register 1.</p>
			
			<p><span class="Subfigure">          ADD      REG0, REG0, REG1 &nbsp;&nbsp; </span>; add contents of register 1 to register 0.</p>
			
			<p><span class="Subfigure">          STORE    REG0, MINORS         </span>; update number of minors from register 0.</p>
			
			<p><span class="Subfigure">          JUMP     ENDIF               </span>; go to the statement labeled “endif”.</p>
			
			<p><span class="Subfigure">ELSE &nbsp;&nbsp;&nbsp; LOAD     REG0, ADULTS         </span>; ELSE: load the number of adults into register 0. </p>
			
			<p><span class="Subfigure">          LOADIMM  REG1, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span>; load the constant value  1 into register 1</p>
			
			<p><span class="Subfigure">          ADD      REG0, REG0, REG1 &nbsp;&nbsp; </span>; add contents of register 1 to register 0.</p>
			
			<p><span class="Subfigure">          STORE    REG0, ADULTS        </span>; update number of adults from register 0.</p>
			
			<p><span class="Subfigure">ENDIF &nbsp;&nbsp; HALT                          </span>;  halt execution of this assembly language program.</p>
			-->
			
			<p class="Figure">
				Figure 11.6: High-level and assembly code to increment minor and adult counters.
			</p>
			
			<p>
				Figure 11.6 presents a program that extends the ideas of Figure 11.5 from the “if-then” construct to the more general “if-then-else” construct.  
			</p>
			
			<p>
				The purpose of the program of Figure 11.6 is to illustrate how a high-level “if-then-else” structure can be implemented as a series of assembly language instructions.  The actual high-level “if” construct adds one to either the number of “adults” or the number of “minors” – depending on whether the value of “age” is less than 18 or not.  This high-level construct is not really a complete program, in the sense that it would need to be placed in a repetition structure (loop) in order to “process” more than one person.
			</p>
			
			<ul class="Blockcenter">
				<ul class="Subblockcenter">
					<li><span class="Subfigure">if (<span class="Ital">variable</span><span class="Subscript">1   </span><span class="Ital">condition  variable</span><span class="Subscript">2</span>)</span></li>
					<li><span class="Subfigure">{</span></li>
					<ul class="Subblockcenter">
						<li><span class="Subfigure"><span class="Ital">then_statements</span></span></li>
					</ul>
					<li><span class="Subfigure">}</span></li>
					<br/>
					<li><span class="Subfigure">LOAD    <span class="Ital">reg</span><span class="Subscript">x </span>,<span class="Ital">variable</span><span class="Subscript">1</span></span></li>
					<li><span class="Subfigure">LOAD    <span class="Ital">reg</span><span class="Subscript">y </span>,<span class="Ital">variable</span><span class="Subscript">2</span></span></li>
					<li><span class="Subfigure">COMPARE <span class="Ital">reg</span><span class="Subscript">x </span>,<span class="Ital"> reg</span><span class="Subscript">y</span></span></li>
					<li><span class="Subfigure">BRANCH  <span class="Ital">condition</span>,<span class="Ital"> label</span><span class="Subscript">1</span></span></li>
					<li><span class="Subfigure">JUMP    <span class="Ital">label</span><span class="Subscript">2</span></span></li>
				</ul>
				<li><span class="Subfigure"><span class="Ital">label</span><span class="Subscript">1</span><span class="Ital">    assembly language version of then_statements</span></span></li>
				<li><span class="Subfigure"><span class="Ital">label</span><span class="Subscript">2</span><span class="Ital">    assembly language statements following “if-then”</span></span></li>
			</ul>
			
			<p class="Figure">
				(a)  Template for constructing assembly language version of “if-then”
			</p>
			
			<ul class="Blockcenter">
				<ul class="Subblockcenter">
					<li><span class="Subfigure">if (<span class="Ital">variable</span><span class="Subscript">1   </span><span class="Ital">condition  variable</span><span class="Subscript">2</span>)</span></li>
					<li><span class="Subfigure">{</span></li>
					<ul class="Subblockcenter">
						<li><span class="Subfigure"><span class="Ital">then_statements</span></span></li>
					</ul>
					<li><span class="Subfigure">}</span></li>
					<li><span class="Subfigure">else</span></li>
					<li><span class="Subfigure">{</span></li>
					<ul class="Subblockcenter">
						<li><span class="Subfigure">else_statements</span></li>
					</ul>
					<li><span class="Subfigure">}</span></li>
					<br/>
					<li><span class="Subfigure">LOAD    <span class="Ital">reg</span><span class="Subscript">x </span>,<span class="Ital">variable</span><span class="Subscript">1</span></span></li>
					<li><span class="Subfigure">LOAD    <span class="Ital">reg</span><span class="Subscript">y </span>,<span class="Ital">variable</span><span class="Subscript">2</span></span></li>
					<li><span class="Subfigure">COMPARE <span class="Ital">reg</span><span class="Subscript">x </span>,<span class="Ital"> reg</span><span class="Subscript">y</span></span></li>
					<li><span class="Subfigure">BRANCH  <span class="Ital">condition</span>,<span class="Ital"> label</span><span class="Subscript">1</span></span></li>
					<li><span class="Subfigure">JUMP    <span class="Ital">label</span><span class="Subscript">2</span></span></li>
				</ul>
				<li><span class="Subfigure"><span class="Ital">label</span><span class="Subscript">1</span><span class="Ital">    assembly language version of then_statements</span></span></li>
				<li><span class="Subfigure"><span class="Ital">              </span>JUMP    <span class="Ital">label</span><span class="Subscript">3</span></span></li>
				<li><span class="Subfigure"><span class="Ital">label</span><span class="Subscript">2</span><span class="Ital">    assembly language version of else_statements</span></span></li>
				<li><span class="Subfigure"><span class="Ital">label</span><span class="Subscript">3</span><span class="Ital">    assembly language statements following “if-then-else”</span></span></li>
			</ul>
				
			<p class="Figure">
				(b)  Template for constructing assembly language version of “if-then-else”
			</p>
			
			<p class="Figure">
				Figure 11.7:  General templates for implementing selection constructs in assembly 
			</p>
			
			<p>
				Figure 11.7 summarizes the process of translating high-level “if-then” and “if-then-else” constructs to assembly language.  Part (a) of the figure contains a template for generating an assembly version of an “if-then” construct.  Part (b) presents a template for generating an assembly version of an “if-then-else” construct.  
			</p>
			
			<p class="Section">
				Exercises for Section 11.3.3
			</p>
			
			<ol>
				<li>
					Write an assembly language program to implement the high-level selection construct: 
				
					<ul class="Blockcenter">
						<li><span class="Subfigure">minor = 1;</span></li>
						<li><span class="Subfigure">if (age &gt; 17)</span></li>
						<li><span class="Subfigure">{</span></li>
							<ul class="Subblockcenter">
								<li><span class="Subfigure">minor = 0;</span></li>
							</ul>
						<li><span class="Subfigure">}</span></li>
					</ul>
				</li>
				<li>
					Write an assembly language program to implement the high-level selection construct: 
					
					<ul class="Blockcenter">
						<li><span class="Subfigure">if (A &gt; B)</span></li>
						<li><span class="Subfigure">{</span></li>
							<ul class="Subblockcenter">
								<li><span class="Subfigure">max = A;</span></li>
							</ul>
						<li><span class="Subfigure">}</span></li>
						<li><span class="Subfigure">else</span></li>
						<li><span class="Subfigure">{</span></li>
							<ul class="Subblockcenter">
								<li><span class="Subfigure">max = B;</span></li>
							</ul>
						<li><span class="Subfigure">}</span></li>
					</ul>
				</li>
			</ol>
			
			<p class="Section">
				11.3.4  Implementing repetition constructs in assembly language
			</p>
			
			<p>
				In addition to implementing selection structures, <span class="Subfigure">COMPARE</span>, <span class="Subfigure">BRANCH</span>, and <span class="Subfigure">JUMP</span> can be used (along with statement labels) to implement high-level repetition constructs such as “while” and “for” loops.    A template for writing the assembly language version of the high-level “while” construct is presented in Figure 11.8.
			</p>
			
			<p>
				As you may recall from your study of Watson JavaScript, the semantics of the “while” construct involve first testing the loop condition to determine whether it is true or false.  If the condition is “false” the loop should be exited immediately (i.e., control should be transferred to the statement immediately following the loop construct).  If the condition is “true” the body of the loop should be executed once.  Following execution of the loop body, control returns to the top of the loop where the loop condition is tested once again and this process repeats itself until the loop condition becomes “false”.
			</p>
			
			<p>
				The assembly language version of the “while” loop implements the semantics of the high-level construct in a straightforward way.  Two statement labels are used: one at the top of the loop and one immediately following the loop.  As with the assembly language version of the high-level “if” construct, two registers are loaded with the values to be tested.  
			</p>
			
			<!--Maybe make containers for columns and redo part B-->
			
			<ul class="Blockcenter">
				<ul class="Subblockcenter">
					<li><span class="Subfigure">while (<span class="Ital">variable</span><span class="Subscript">1   </span><span class="Ital">condition  variable</span><span class="Subscript">2</span>)</span></li>
					<li><span class="Subfigure">{</span></li>
					
					<ul class="Subblockcenter">
						<li><span class="Subfigure"><span class="Ital">loop_body</span></span></li>
					</ul>
					<li><span class="Subfigure">}</span></li>
				</ul>
				
				<li><span class="Subfigure"><span class="Ital">label1</span>  LOAD    <span class="Ital">reg</span><span class="Subscript">x </span>,<span class="Ital">variable</span><span class="Subscript">1</span></span></li>
				
				<li><span class="Subfigure">&nbsp; &nbsp; &nbsp; &nbsp; LOAD    <span class="Ital">reg</span><span class="Subscript">y </span>,<span class="Ital">variable</span><span class="Subscript">2</span></span></li>
				
				<li><span class="Subfigure">&nbsp; &nbsp; &nbsp; &nbsp; COMPARE <span class="Ital">reg</span><span class="Subscript">x </span>,<span class="Ital"> reg</span><span class="Subscript">y</span></span></li>
				
				<li><span class="Subfigure">&nbsp; &nbsp; &nbsp; &nbsp; BRANCH  <span class="Ital">exit_condition</span>,<span class="Ital"> label2</span></span></li>
				
				<li><span class="Subfigure">&nbsp; &nbsp; &nbsp; &nbsp; assembly language version of loop_body</span></li>
				
				<li><span class="Subfigure">&nbsp; &nbsp; &nbsp; &nbsp; JUMP    <span class="Ital">label1</span</span></li>
				
				<li><span class="Subfigure"><span class="Ital">label2</span>  assembly language statements following “while” loop</span></li>
			</ul>
			
			<p class="Figure">
				(a)  Template for constructing assembly language version of “while” loop
			</p>
			
			<ul class="Blockcenter">
				<li><span class="Subfigure"><span class="Underlined">While condition</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Underlined">Exit condition</span></span></li>
				<li><span class="Subfigure">==   equal &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NE   not equal</span></li>
				<li><span class="Subfigure">&lt;&gt;   not equal &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EQ   equal</span></li>
				<li><span class="Subfigure">&lt;    less than &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GE   greater than or equal to</span></li>
				<li><span class="Subfigure">&gt;    greater than &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LE   less than or equal to</span></li>
				<li><span class="Subfigure">&lt;=   less than or equal to &nbsp; &nbsp; &nbsp;GT   greater tha</span></li>
				<li><span class="Subfigure">&gt;=   greater than or equal to &nbsp; LT   less than</span></li>
			</ul>
			
			<p class="Figure">
				(b)  Exit condition substitutions used in above templates
			</p>
			
			<p class="Figure">
				Figure 11.8:  General template for implementing the “While” construct in assembly
			</p>
			
			<p>
				Following the two <span class="Subfigure">LOAD</span> instructions, a <span class="Subfigure">COMPARE</span> statement examines the values held in those registers.  A <span class="Subfigure">BRANCH</span> statement, which contains the loop’s “exit condition”, is then executed.  If the exit condition is true, control is transferred to the assembly language statement immediately following the loop. Otherwise, the exit condition is false, so control flows sequentially into the assembly statements that represent the body of the loop.  At the end of the loop body, an unconditional <span class="Subfigure">JUMP</span> instruction is used to return control back to the top of the loop where the condition can be tested again.
			</p>
			
			<p>
				Note that the loop exit condition used at the assembly level is the exact opposite of the condition used in the high-level while statement.  This is because the high-level condition specifies the conditions under which the program should continue to loop, while the assembly condition specifies the conditions under which the program should exit the loop.  Thus, if the high-level code specifies that a loop should execute while <span class="Subfigure">A == B</span> (while A is equal to B), the assembly language code would capture the same meaning by specifying that the loop should be exited when <span class="Subfigure">A NE B</span> (when A is not equal to B).
			</p>
			
			<p>
				Figure 11.9 presents an assembly language program that includes a “while” loop.  The purpose of the program is to implement the high-level multiplication statement:
			</p>
			
			<p class="Subfigure">
				z = x * y;
			</p>
			
			<p>
				You may have noticed that Watson Assembly Language does not include a multiply instruction.  How then can multiplication be performed at the assembly level?  One way that multiplication can be implemented is by repeatedly adding the value of the first operand to an initially zero product for some number of times equal to the second operand.<span class="Footnote" title="Footnote: There are other, more efficient, ways of solving this problem that will become apparent during the discussion of data representation and manipulation in Section 11.4.1.3."><a href="#ftn3" id="body_ftn3">[3]</a></span>  In the specific example given above, the first operand, “x”, is added to an initially zero product, “z”, “y” times. This “multiplication via repeated addition” algorithm can be expressed in high-level Watson JavaScript code using either a “for” loop, such as: 
			</p>
			
			<ul class="Blockcenter">
				<li><span class="Subfigure">z = 0;</span></li>
				<li><span class="Subfigure">for (i = 1; i &lt;= y; i++)</span></li>
				<li><span class="Subfigure">{</span></li>
				<ul class="Subblockcenter">
					<li><span class="Subfigure">z = z + x;</span></li>
				</ul>
				<li><span class="Subfigure">}</span></li>
			</ul>
			
			<p>
				Or an equivalent “while” loop:
			</p>
			
			<ul class="Blockcenter">
				<li><span class="Subfigure">z = 0;</span></li>
				<li><span class="Subfigure">i = 1;</span></li>
				<li><span class="Subfigure">while (i &lt;= y)</span></li>
				<li><span class="Subfigure">{</span></li>
				<ul class="Subblockcenter">
					<li><span class="Subfigure">z = z + x;</span></li>
					<li><span class="Subfigure">i = i + 1;</span></li>
				</ul>
				<li><span class="Subfigure">}</span></li>
			</ul>

			<img src="Images/AssemblyIMGS/fig11-9pt2.png" alt="" class="Image">
			<img src="Images/AssemblyIMGS/fig11-9pt2.png" alt="" class="Image">
			<!--Figure 11.9 Text (not formatted)
			<p>
				High-level Language Statement:
			</p>
			
			<p class="Subfigure">
				z = x * y;
			</p>
			
			<p>Implementing multiplication of positive integers via repeated additions:</p>
			
			<p class="P94"><span class="T12">  </span>z = 0;</p>
			
			<p class="P71"><span class="T12">   </span>z = 0;<span>   i = 1;</span></p>
			
			<p class="P78"><span class="T12">   </span>for (i=1; i&lt;=y; y++)<span>   while (i &lt;= y)</span></p>
			
			<p class="P78"><span class="T12">   </span>{<span>   </span><span>   {</span></p>
			
			<p class="P83">z = z + x;<span>      z = z + x;</span></p>
			
			<p class="P71"><span class="T12">   </span>} <span>      i = i + 1;</span></p>
			
			<p class="P78"><span>   }</span></p>
			
			<h2 class="Heading_20_2"><a id="a__Multiplication_using_“For”_Multiplication_using_“While”"></a>Multiplication using “For”                          Multiplication using “While”</h2>
			
			<p>Equivalent assembly language code:</p>
			
			<p><span class="Subfigure">X        .WORD     5                        </span>       ;  declare and initialize “x” to 5    /* first operand */</p>
			
			<p><span class="Subfigure">Y        .WORD     4                           </span>;  declare and initialize “y” to 4    /* second operand */</p>
			
			<p><span class="Subfigure">Z         .BLOCK    1                           </span>;  declare “z”  /* z will hold the product of the operands */ </p>
			
			<p class="Footnote"><span class="Subfigure">I        .BLOCK    1                           </span>;  declare “i”   /* i counts the number of loop iterations */</p>
			
			<p class="P73"><span class="Subfigure">LOADIMM   REGA, 0               </span>;   </p>
			
			<p class="P73"><span class="Subfigure">STORE            REGA, Z                   </span>;  z = 0;</p>
			
			<p class="P73"><span class="Subfigure">LOADIMM   REGA, 1               </span>;</p>
			
			<p><span class="Subfigure">        STORE            REGA, I                   </span>;  i = 1;</p>
			
			<p><span class="Subfigure">LOOP        LOAD            REGA, I                   </span>;  while (i &lt;= y) </p>
			
			<p class="P73"><span class="Subfigure">LOAD            REGB, Y                   </span>;  </p>
			
			<p class="P73"><span class="Subfigure">COMPARE   REGA, REGB           </span>;               </p>
			
			<p class="P73"><span class="Subfigure">BRANCH    GT, ENDLP             </span>;  {</p>
			
			<p class="P73"><span class="Subfigure">LOAD            REGA, Z                   </span>;      </p>
			
			<p class="P73"><span class="Subfigure">LOAD            REGB, X                   </span>;      </p>
			
			<p class="P73"><span class="Subfigure">ADD            REGC, REGA, REGB </span>;      </p>
			
			<p class="P73"><span class="Subfigure">STORE            REGC, Z                   </span>;        z = z + x;</p>
			
			<p class="P73"><span class="Subfigure">LOAD             REGA, I                   </span>;        </p>
			
			<p class="P73"><span class="Subfigure">LOADIMM   REGB, 1                   </span>;</p>
			
			<p class="P73"><span class="Subfigure">ADD       REGC, REGA, REGB </span>;                 </p>
			
			<p class="P73"><span class="Subfigure">STORE            REGC, I                   </span>;        i = i + 1;</p>
			
			<p class="P73"><span class="Subfigure">JUMP            LOOP                   </span>;   }</p>
			
			<p><span class="Subfigure">ENDLP        HALT                                   </span>; </p>
			-->
			
			<p class="Figure">
				Figure 11.9:  Assembly language version of the statement:   <span class="Subfigure">z = x * y;</span>
			</p>
			
			<p>
				Note that this particular multiplication procedure requires that the second operand be non-negative.  There exist straightforward extensions to this algorithm that allow for the multiplication of negative integers.  
			</p>
			
			<p>
				The assembly language program presented in Figure 11.9 implements its “while” loop directly from the template of Figure 11.8.  Assignment statements are implemented in a manner similar to that presented in Figure 11.3.  In this example, the assembly language implementation of each high-level instruction begins by copying the values of all operand variables from memory into registers.  The contents of the registers are then manipulated in accordance with the meaning of the high-level instruction, and results are immediately copied from the registers back to the underlying main memory variables. As such, the resulting assembly language program, while correct, is not very efficient.
			</p>
			
			<p>
				Figure 11.10 presents an optimized version of the program of Figure 11.9.  While an inspection of the two programs should reveal that they compute identical results, the program of Figure 11.10 involves fewer steps (17 verses 22) and therefore should run somewhat faster.  The approach taken in the optimized version of the program is to keep temporary results in CPU registers rather than writing them back to main memory after each operation.  This approach works by loading the initial values of the variables into registers at the beginning of the program, using those registers in place of the underlying variables during processing, and then copying results back to main memory at the end of the program.  Frequently, compilers, the programs that translate high-level language programs into low-level code, use strategies such as this to produce code that is more efficient than would be produced by a literal, statement-by-statement translation of the high-level program.
			</p>

			<img src="Images/AssemblyIMGS/fig11-10.png" alt="" class="Image">
			<!--Figure 11.10 text (not formatted)
			<p><span class="Subfigure">X        .WORD     5                        </span>       ;  declare and initialize “x” to 5    /* first operand */</p>
			
			<p><span class="Subfigure">Y        .WORD     4                           </span>;  declare and initialize “y” to 4    /* second operand */</p>
			
			<p><span class="Subfigure">Z         .BLOCK    1                           </span>;  declare “z”  /* z will hold the product of the operands */ </p>
			
			<p class="Footnote"><span class="Subfigure">I        .BLOCK    1                           </span>;  declare “i”   /* i counts the number of loop iterations */</p>
			
			<p class="P73"><span class="Subfigure">LOADIMM   REG1, 1               </span>;  register 1 holds the constant value 1.</p>
			
			<p class="P73"><span class="Subfigure">LOAD      REGA, X            </span>;  register A holds the value of variable “x”.</p>
			
			<p class="P73"><span class="Subfigure">LOAD      REGB, Y                      </span>;  register B holds the value of variable “y”.</p>
			
			<p class="P73"><span class="Subfigure">LOADIMM   REGC, 0               </span>;  register C holds the value of variable “z” – initially 0.</p>
			
			<p class="P73"><span class="Subfigure">LOADIMM   REGD, 1               </span>;  register D holds the value of variable “i” – initially 1.</p>
			
			<p><span class="Subfigure">LOOP        COMPARE   REGD, REGB           </span>;  compare register D (the counter “i”) to register B (“y”).</p>
			
			<p class="P73"><span class="Subfigure">BRANCH    GT, ENDLP             </span>;  if  “i” is greater  than “y” then branch to “endlp”.</p>
			
			<p class="P73"><span class="Subfigure">ADD            REGC, REGC, REGA </span>;  otherwise, add the value of  “x” to  “z”.</p>
			
			<p class="P73"><span class="Subfigure">ADD       REGD, REGD, REG1 </span>;                    add 1 to the counter “i”.</p>
			
			<p class="P73"><span class="Subfigure">JUMP            LOOP                   </span>;                    return to the top of the loop.</p>
			
			<p><span class="Subfigure">ENDLP        STORE     REGD, I          </span>;   copy results back to main memory variables.</p>
			
			<p><span class="Subfigure">        STORE            REGC, Z                   </span>;   the product of “x” and “y” is saved in variable “z”    .</p>
			
			<p class="P127"><span class="Subfigure">HALT                                   </span>;   halt execution of this assembly language program.</p>
			-->
			
			<p class="Figure">
				Figure 11.10:  Optimized assembly version of:   <span class="Subfigure">z = x * y;</span>
			</p>
			
			<p class="Section">
				Exercises for Section 11.3.4
			</p>
			
			<ol>
				<li>
					Write an assembly language program to implement the high-level assignment statement:
			
					<p class="Subfigure">Z = X / Y;</p>
			
					using repeated subtraction, where <span class="Subfigure">X</span>, <span class="Subfigure">Y</span>, and <span class="Subfigure">Z</span> are positive integers.
				</li>
				<br/>
				<li>
					Write an assembly language program to compute the sum of the numbers from 1 to 20 using a loop construct.
				</li>
			</ol>
			
			<p class="Section">
				11.3.5  Array processing in assembly language
			</p>
			
			<p>
				In section 8.9 of Chapter 8, an array was defined as a collection of data elements, all of the same type, that are stored in contiguous memory locations.  To access an item stored in an array, high-level languages require both the name of the array and the relative position, or “offset” of the item of interest.  Hence, <span class="Subfigure">A[0]</span> is a  reference to the first element of the array <span class="Subfigure">A</span>, because the offset is zero.  Likewise,  <span class="Subfigure">A[1]</span> is a reference to the 2<span class="Superscript">nd</span> element because it is offset from the start of the array by one element.
			</p>
			
			<p>
				Variables, as well as constants, may be used for subscripts.  Hence, the statement:
			</p>
			
			<p class="Subfigure">
				A[i] = -1;
			</p>
			
			<p>
				places the value –1 into the element at index position <span class="Ital">i</span> of array <span class="Subfigure">A</span>.  Similarly the statement:
			</p>
			
			<p class="Subfigure">
				X = A[j];
			</p>
			
			<p>
				places a copy of element <span class="Ital">j</span> of <span class="Subfigure">A</span> into the variable <span class="Subfigure">X</span>.
			</p>
			
			<p>
				This ability to access and modify array elements using variable subscripts is important when one wishes to access or modify <span class="Ital">all</span> of the elements of an array.  Generally, if one wants to perform an operation on all of the elements of an array, the desired operation is described in terms of some generic element, such as the element at index position <span class="Ital">i</span>, and then the operation is embedded within a repetition construct.
			</p>
			
			<p>
				As an example, perhaps one wants to initialize all of the elements of an array to some initial value.  The following high-level Watson JavaScript program initializes each of the elements of a 30-element numeric array, named <span class="Subfigure">myArray</span>, to –1.
			</p>
			
			<ul class="Blockcenter">
				<li><span class="Subfigure">var i; // Numeric</span></li>
				<li><span class="Subfigure">var myArray = new Array(30); // Numeric</span></li>
				<br/>
				<li><span class="Subfigure">for (i = 0; i &lt; 30; i++)</span></li>
				<li><span class="Subfigure">{</span></li>
				<ul class="Subblockcenter">
					<li><span class="Subfigure">myArray[i] = -1;</span></li>
				</ul>
				<li><span class="Subfigure">}</span></li>
			</ul>
			
			<p>How can such a program be translated into assembly language?</p>
			
			<p>
				Declaring an array is simple – just reserve the appropriate amount of space via the <span class="Subfigure">.BLOCK</span> command.  For a 30-element array of integers named <span class="Subfigure">myArray</span> the command:
			</p>
			
			<p class="Subfigure">
				MYARRAY        .BLOCK        30
			</p>
			
			<p>
				does the job.  Accessing the elements of this array via variable subscripts is somewhat more challenging to implement. In fact, in order to use arrays effectively, it will be necessary for us to find a way to calculate the memory address of each of the elements of the array.  We will also need access to assembly language instructions that can load data from, and store data to, calculated addresses. 
			</p>
			
			<p>
				We will look at the calculation of addresses in a moment.  But first, let’s examine the way in which a value can be retrieved from a memory location via the “load indirect” statement assuming the memory address calculation has already been done for us. 
			</p>
			
			<p>
				The form of the load indirect instruction is:
			</p>
			
			<p class="Subfigure">
				LOADIND        <span class="Ital">destination register</span>, <span class="Ital">source location register</span>
			</p>
			
			<p>
				A statement such as:
			</p>
			
			<p class="Subfigure">
				LOADIND        REGA, REGB
			</p>
			
			<p>
				will place a copy of the value held in the memory address indicated by register B into register A.  
			</p>
			
			<p>
				Consider a high-level assignment statement such as:
			</p>
			
			<p class="Subfigure">
				x = A[5];
			</p>
			
			<p>
				which places the value of the element of <span class="Subfigure">A</span> located at index position 5 into the variable <span class="Subfigure">x</span>.  Assuming register B held the address of <span class="Subfigure">A[5]</span>, such a statement could be implemented by the following code segment:
			</p>
			
			<ul class="Blockcenter">
				<li><span class="Subfigure">LOADIND      REGA, REGB</span></li>
				<li><span class="Subfigure">STORE        REGA, X</span></li>
			</ul>
			
			<p>
				Placing a value into an array works in a similar manner, except that the “store indirect” command is used rather than the “load indirect” command.  The form of the store indirect instruction is:
			</p>
			
			<p class="Subfigure">
				STOREIND        <span class="Ital">source register</span>, <span class="Ital">destination location register</span>
			</p>
			
			<p>
				Hence, the statement:
			</p>
			
			<p class="Subfigure">
				STOREIND        REGE, REGF
			</p>
			
			<p>
				will store the value held in register E into the memory address indicated by register F.
			</p>
			
			<p>
				These instructions, <span class="Subfigure">LOADIND</span> and <span class="Subfigure">STOREIND</span>, are referred to as “indirect” instructions due to the fact that they do not directly specify which memory address is to be accessed.  Instead, the statements indirectly specify the target address by indicating where that address may be found – i.e., indirect instructions specify a register that is consulted for the actual target address.
			</p>
			
			<p>
				Indirect instructions add a lot of power to an assembly language by allowing programs written in that language to compute “on the fly” the memory addresses of objects that are to be accessed or modified.  Without some form of indirection, array processing with variable subscripts would be impossible, since the memory location specified by an expression such as <span class="Subfigure">a[i]</span> depends on the value of the subscript <span class="Subfigure">i</span>.
			</p>
			
			<p>
				It should now be clear that if we had the address of a particular element of an array we could both access that element (via <span class="Subfigure">LOADIND</span>) and modify the element (via <span class="Subfigure">STOREIND</span>).  This begs the question:  “How can the address of an array element be computed?”
			</p>
			
			<p>
				The address of the element at index position <span class="Subfigure">i</span> of an array can be computed from the expression:
			</p>
			
			<p class="Subfigure">
				<span class="Ital">base_address_of_array</span>  + ( <span class="Ital">i</span>  * <span class="Ital">size_of_each_element</span> )
			</p>
			
			<p>
				where:
			</p>
			
			<ul class="Blockcenter">
				<li><span class="Ital">base_address_of_array</span> is the location of the first element of the array.</li>
				<br/>
				<li><span class="Ital">i</span> is the subscript indicating which element of the array is to be accessed.</li>
				<br/>
				<li><span class="Ital">size_of_each_element</span> is the number of “words” required to hold a single</li>
			</ul>
			
			<p>
				array element.
			</p>
			
			<p>
				Since we are limiting ourselves to the study of integers (which require a single word of memory), <span class="Ital">size_of_each_element</span> is one and can be safely ignored, leading to the simplified form of the expression:
			</p>
			
			<p class="Subfigure">
				<span class="Ital">base_address_of_array</span>  + <span class="Ital">i</span>
			</p>
			
			<p>
				The term <span class="Ital">i </span>is often referred to as the “offset” into the array, since it specifies how far past the base address the element of interest is located.
			</p>
			
			<p>
				Here is an example that illustrates the process of memory address computation for array elements.  If we assume that the array <span class="Subfigure">A</span> begins at memory location 10, then <span class="Subfigure">A[3]</span> (the 4<span class="Superscript">th</span> element) will be stored at location 13.  
			</p>

			<img src="Images/AssemblyIMGS/fig11-11a.png" alt="" class="Image">
			<!--Figure 11.11a Text (not formatted)
			<p class="Subfigure">
				<span class="Ital">base_address_of_array</span>  +  <span class="Ital">i</span>
			</p>
			
			<p class="P97">10<span>      +  3</span></p>
			
			<p class="P97">13</p>
			
			<p class="P101">var i; // Numeric<span>   var i; //Numeric</span></p>
			
			<p class="P101">var a = new array(30); //Numeric <span>   var a = new array(30); //Numeric</span></p>
			
			<p class="P101"><span>   i = 0;</span><span>   for (i = 0; i &lt; 30; i++)</span><span>   while (i &lt; 30) </span></p>
			
			<p class="P101">{<span>   {</span></p>
			
			<p class="P101"><span class="T12">   </span>a[i] = -1;<span>    </span><span>     a[i] = -1;</span></p>
			
			<p class="P101"><span>     i = i + 1;</span></p>
			
			<p class="P101">}<span>   }</span></p>
			-->
			
			<p class="Figure">
				(a) “for” and “while” versions of high-level code 
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-11b.png" alt="" class="Image">
			<!--figure 11.11b text (not formatted)
			<p><span class="Subfigure">I        .BLOCK    1                    </span>;   var i;  //  Numeric</p>
			
			<p><span class="Subfigure">A        .BLOCK    30                   </span>;   var a = new array(30); // Numeric</p>
			
			<p class="P73"><span class="Subfigure">LOADIMM   REGA, 0                 </span>;   </p>
			
			<p class="P73"><span class="Subfigure">STORE     REGA, I               </span>;   i = 0;</p>
			
			<p><span class="Subfigure">LOOP        LOAD      REGA, I              </span>;  while (i  &lt; 30) </p>
			
			<p class="P73"><span class="Subfigure">LOADIMM   REGB, 30         </span>; </p>
			
			<p class="P73"><span class="Subfigure">COMPARE   REGA, REGB           </span>;    </p>
			
			<p class="P73"><span class="Subfigure">BRANCH    GE, ENDLP            </span>;  {</p>
			
			<p class="P73"><span class="Subfigure">LOADIMM   REGA, 1                   </span>;                Register A assigned the base address of array a</p>
			
			<p class="P73"><span class="Subfigure">LOAD            REGB, I                     </span>;                Register B assigned the value of subscript i </p>
			
			<p class="P73"><span class="Subfigure">ADD            REGC, REGA, REGB </span>;                Register C assigned  the address of a[i]</p>
			
			<p class="P73"><span class="Subfigure">LOADIMM   REGD, -1           </span>;<span>           Register D assigned the constant  -1</span></p>
			
			<p class="P73"><span class="Subfigure">STOREIND  REGD, REGC           </span>;           a[i] = -1;</p>
			
			<p class="P73"><span class="Subfigure">LOAD            REGA, I                   </span>;</p>
			
			<p class="P73"><span class="Subfigure">LOADIMM   REGB, 1                   </span>;              </p>
			
			<p class="P73"><span class="Subfigure">ADD            REGC, REGA, REGB </span>;             </p>
			
			<p class="P73"><span class="Subfigure">STORE            REGC, I                   </span>;           i = i + 1;</p>
			
			<p class="P73"><span class="Subfigure">JUMP            LOOP                   </span>;  }</p>
			
			<p><span class="Subfigure">ENDLP HALT                                   </span>;  </p>
			-->
			
			<p class="Figure">
				(b) Assembly language code 
			</p>
			
			<p class="Figure">
				Figure 11.11:  Initializing all 30 elements of an array to -1
			</p>
			
			<p>
				The above algorithm for calculating the location of index position <span class="Ital">i</span> of an array can be translated into assembly language as follows:
			</p>
			
			<ol>
				<li>
					Load the base address of the array into register<span class="Subscript">x</span>
					
					<ul>
						<span class="Subfigure">LOAD         </span><span class="Ital">reg</span><span class="Subscript">x</span><span class="Ital"> </span>,<span class="Ital"> base_address_of_array</span>
					</ul>
				</li>
				<br/>
				<li>
					Load the value of subscript i (the offset) into register<span class="Subscript">y</span>
					
					<ul>
						<span class="Subfigure">LOAD         </span><span class="Ital">reg</span><span class="Subscript">y</span><span class="Ital"> </span>,<span class="Ital"> i</span>
					</ul>
				</li>
				<br/>
				<li>
					Add the offset to the base address giving the location of the <span class="Ital">i</span><span class="Superscript">th</span> element.
					
					<ul>
						<span class="Subfigure">ADD          </span><span class="Ital">reg</span><span class="Subscript">z</span><span class="Ital"> </span>,<span class="Ital"> reg</span><span class="Subscript">x</span><span class="Ital"> </span>,<span class="Ital"> reg</span><span class="Subscript">y</span>
					</ul>
				</li>
			</ol>
						
			<p>
				At the end of this process register<span class="Subscript">z</span> will contain the address of the array element at index position <span class="Ital">i</span>.
			</p>
			
			<p>
				Figure 11.11 presents a complete assembly language program for initializing all of the elements of a 30-element array to –1.  The figure also contains two high-level Watson JavaScript programs for accomplishing the same task – one using a “for” loop, the other a “while” loop.
			</p>
			
			<p class="Section">
				Exercises for Section 11.3.5
			</p>
			
			<ol>
				<li>
					Complete the following program, the purpose of which is to compute the sum of the items given in the first <span class="Subfigure">N</span> elements of an array and then store that total in the variable <span class="Subfigure">TOTAL</span>.  To solve this problem efficiently you will probably want to use the <span class="Subfigure">LOADIND</span> (Load Indirect) instruction, which loads a value into a register from a location specified by another register.
					
					<ul class="Blockcenter">
						<li><span class="Subfigure">A &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;.WORD &nbsp; &nbsp; 2        ; a[0] = 2;</span></li>
						<li><span class="Subfigure">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .WORD &nbsp; &nbsp; 4        ; a[1] = 4;</span></li>
						<li><span class="Subfigure">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .WORD &nbsp; &nbsp; 8        ; a[2] = 8;</span></li>
						<li><span class="Subfigure">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .WORD &nbsp; &nbsp; 16       ; a[3] = 16;</span></li>
						<li><span class="Subfigure">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .WORD &nbsp; &nbsp; 32       ; a[4] = 32;</span></li>
						<li><span class="Subfigure">TOTAL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .BLOCK &nbsp; &nbsp;1</span></li>
						<li><span class="Subfigure">N &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.WORD &nbsp; &nbsp; 5</span></li>
					</ul>
				</li>
				<br/>
				<li>
					Beginning with an uninitialized array of 12 elements, write an assembly language program to assign the value 10 to the element at index zero, 20 to the element at index one, 30 to the element at index two, and so forth.  Ending with the value 120 in the final element located at index eleven.  You must solve this problem using a loop construct.
				</li>
			</ol>
			
			<p class="Section">
				11.4  Data representation at the machine level
			</p>
			
			<p>
				The most basic unit of storage is the bit.  At any point in time, a bit can be in only one of two states: “0” or “1”.  Bits are generally implemented as two-state electronic devices (e.g., a current is flowing or not flowing, a voltage is high or low, a magnetic field is polarized in one direction or the opposite direction, etc.).  The symbol “0” is used to represent one of these states and the symbol “1” is used to represent the other.  It really doesn’t matter which symbol (the “0” or the “1”) represents which physical state (e.g., “high” or “low”).  All that is important is that the symbols be assigned consistently and that the two states be clearly distinguishable from each other.
			</p>
			
			<p>
				Sequences, or “patterns”, of bit values can be used to represent numbers (both positive and negative, integer and real), alphanumeric characters, images, sounds, and even program instructions. In fact, anything that can be stored in a computer must ultimately be stored as a pattern of bit values.  In this section we will look at how numbers, characters, and images can be represented at the machine level.  In section 11.5 we will turn our attention to the representation of program instructions.
			</p>
			
			<p>
				Before we examine the representation of these various kinds of data, it is important to understand the difference between a symbol and its referent.  A <span class="Ital">symbol</span> is the thing we use to represent an object.  The <span class="Ital">referent</span> is the actual thing or object the symbol represents.  This object can be either something abstract, like “happy”, or something concrete, like a particular person: “John Talton”.  
			</p>
			
			<p>
				To illustrate this idea, think about the number five.  This number, like all numbers, is an abstract concept.  You cannot point to “five” – although you can point to five books or five people, or five pennies.  The number five, this abstract concept, should not be confused with the symbol “5” which is often used to represent the number.  The symbol “5” is just a squiggly mark.  It is not the number five.
			</p>
			
			<p>
				It is also important to recognize the fact that many different symbols can be used to represent the same object.  For example, the number five can be represented by the Roman numeral “V”, the tally marks  “<del>||||</del>”, or the English word “five”.  
			</p>
			
			<p>
				Just as many different symbols can be used to represent one object or concept, a single symbol can have multiple meanings.  Think about the symbol “V”.  What does it mean?  Well, as we have just seen, it could be the Roman numeral for five, or it could be the letter of the English alphabet that follows “U”, or even the name of a cheesy 1980’s sci-fi series about lizard people trying to take over Earth.  
			</p>
			
			<p>
				Humans can generally infer the intended meaning of a symbol by noting the context in which the symbol appears.  When the context is unknown or unclear, the meaning of the symbol cannot be reliably determined.  This inability to determine the meaning of a symbol from the symbol itself applies to all symbols – even bit patterns.  Suppose someone gave you the following bit pattern and asked you what it meant.
			</p>
			
			<ul class="Blockcenter">
				<li><span class="Subfigure">0100 0100 0111 0010 0111 0101 0110 0111</span></li>
				<li><span class="Subfigure">0111 0011 0010 0000 0110 0001 0111 0010</span></li>
				<li><span class="Subfigure">0110 0101 0010 0000 0110 0010 0110 0001</span></li>
				<li><span class="Subfigure">0110 0100 0010 1110 0010 0000 0010 0000</span></li>
				<li><span class="Subfigure">0100 1111 0100 1011 0011 1111 0010 0000</span></li>
			</ul>
			
			<p>
				Without knowing the “type” of data you are looking at, it is impossible to interpret what it means.  It might be a sequence of numbers, a sequence of characters, part of a bitmapped image of a picture, or one of many other types of objects.  There is no way to tell what the referent is just by looking at the data itself.  We must also know the type of data we are looking at and the representation scheme used to encode that data.
			</p>
			
			<p>
				Whatever the conceptual properties of an object, if it is to be represented within a computer, a way must be found to represent the object as a sequence of 0’s and 1’s.  In the remainder of this section a number of data types are presented together with descriptions of how objects of each type can be encoded as patterns of bit values.
			</p>
			
			<p class="Section">
				11.4.1 Representing numbers at the machine level
			</p>
			
			<p>
				This section is concerned with developing methods for representing and manipulating numbers at the machine level.  We begin with a brief history and review of number systems.  This is followed by a more in-depth discussion of numeric bases and conversion between bases.  Next, binary arithmetic is discussed.  We then turn our attention to the representation of signed numbers.  Finally, we examine how very large and very small (fractional) values can be represented at the machine level.
			</p>
			
			<p class="Section">
				11.4.1.1 Number systems
			</p>
			
			<p>
				Today, virtually all civilizations use a base ten counting system.  However, this has not always been so. In primitive tally systems, for example, there is one stroke for each object being counted, as in <del>||||</del> <del>||||</del> || to represent twelve.  Some tally systems group strokes together – the one illustrated places five strokes in each group. 
			</p>
			
			<p>
				Most early systems attached little or no meaning to the order of the symbols used to represent a number. Roman numerals did use position, but only to indicate whether one value should be added to or subtracted from another value.  For example, the Roman numeral MMC stands for 2100 because “M” represents one thousand, “C” represents one hundred, and the positional rule states that when the symbols are arranged in order of decreasing value, all of the values should be added together.  Hence, the meaning of MMC is 1000 + 1000 + 100 = 2100.  On the other hand, MCM means 1900 because the positional rules states that when a symbol for a smaller value immediately precedes a symbol for a larger value, the smaller value is to be subtracted from the larger value.  So, MCM is 1000 + (1000 – 100) = 1900.  The year 1999 as a Roman numeral is written MCMXCIX, meaning 1000 + (1000 – 100) + (100 – 10) + (10 – 1).  
			</p>
			
			<p>
				Positional notation truly became useful only after the zero digit was introduced by the Arabs.  Our modern decimal number system is a base ten positional system.  It uses ten symbols, “0” through “9”.  We count by sequencing through these symbols: “0” for zero, “1” for one, “2” for two, …, and “9” for nine.  Once the last symbol is encountered, namely “9”, how do we represent the next number?  What we do is to replace the current symbol, “9”, with the first symbol in the series, “0”, and then increment the symbol immediately to the left of the current symbol by one.  Since base ten numbers are assumed to be preceded by  (usually unwritten) 0’s, the number nine can be written as “09”.  Hence, cycling “9” back to “0” and incrementing the leftmost “0” to “1” gives “10” as the base ten symbol for the number ten.  To continue counting, we cycle the rightmost digit through the symbols “0” through “9” again, producing “10” through “19” for the numbers ten through nineteen.  The number twenty can be represented by resetting the “9” to “0” and replacing the “1” with the next symbol in the sequence, “2”, giving “20”.
			</p>
			
			<p>
				Computer systems use base two, or binary, instead of base ten.  Counting in binary is similar to counting in base ten.  We still cycle through the sequence of symbols – incrementing the symbol to the left of the current symbol whenever the current symbol cycles back to the beginning of the sequence.  The only difference is that instead of ten symbols, “0” through “9”, there are only two symbols: “0” and “1”. We begin counting by sequencing through these symbols: “0” for zero, “1” for one, and then we have reached the symbol with the largest value.  Keeping in mind that the number one can be rewritten as “01”, we reset the rightmost symbol, “1”, to the first symbol in the sequence, “0”, and then increment the implied “0” immediately to the left to “1”, giving us “10”, the base two symbol for two.   
			</p>
			
			<p>
				Note carefully that the symbol “10” (pronounced “one” “zero”) when interpreted as a base two number refers to the number two, <span class="Ital">not</span> ten.  When discussing base two values you should <span class="Bolded">never</span> refer to the symbol “10” as “ten”, since that is not the value of the number represented by this symbol.
			</p>
			
			<p>
				Continuing with the example, the next number, three, can be represented in base two as “11” – we simply increment the right-most digit of “10” from “0” to “1”.  
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-12.png" alt="" class="Image">
			
			<p class="Figure">
				Figure 11.12: The numbers zero through eight in base ten and base two
			</p>
			
			<p>
				To generate the base two representation of four, we begin with three represented as “011” – remember it is ok to add 0’s to the left-hand side of a number symbol.  Next, we set the rightmost “1” digit back to “0” and attempt to increment the middle digit.  However, that digit is also at the end of the sequence, since it contains a “1”. So, we reset this digit to “0” as well and proceed to the third (leftmost) digit, which we increment from “0” to “1”.   The final result is “100”, which is the base two representation of the number four. 
			 </p>
			
			<p>
				This process for generating base two numbers can be continued indefinitely.  The base ten (decimal) and base two (binary) representations of the numbers zero through eight are shown in Figure 11.12.  In order to make the counting algorithm as clear as possible, leading 0’s are shown in the binary representations of zero through seven.
			</p>
			
			<p>
				Of course, we will need to develop a fast way to find out the number represented by a base two symbol, instead of “counting up to it”.  However, before we leave the notion of counting, let’s investigate one other base that is commonly used when discussing programs and data at the machine level.
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-13.png" alt="" class="Image">

			<p class="Figure">
				Figure 11.13: The numbers zero through twenty in base ten, two, and sixteen
			</p>
			
			<p>
				Base sixteen, or <span class="Ital">hexadecimal</span>, uses sixteen symbols: “0” through “9” for the numbers zero through nine, and “A” through “F” for the numbers ten through fifteen.  The number sixteen is written as “10” in base sixteen, since after the symbol “F” is encountered, it is necessary to cycle back to the beginning of the sequence, “0”.  When this occurs, the character immediately to the left of the current character (an understood “0”) is incremented to “1”, giving “10”.  Figure 11.13 illustrates the base ten, base two, and base sixteen representations of the numbers zero through twenty.
			</p>
			
			<p>
				In order to clearly distinguish which base a number-symbol is to be interpreted under, I will generally write the base: two, ten, or sixteen, as a subscript immediately following the digits of the number.  Hence, 11<span class="Subscript">two</span> is three, 11<span class="Subscript">ten</span> is eleven, and 11<span class="Subscript">sixteen</span> is seventeen.
			</p>
			
			<p class="Section">
				Exercises for Section 11.4.1.1
			</p>
			
			<ol>
				<li>
					Extend the table of Figure 11.13 from twenty to thirty-five in all three bases.
				</li>
			
				<li>
					Another base that is occasionally used in computing – especially when talking about older computer systems is octal, or base eight.  Octal uses eight symbols, 0-7.  Add an octal column to the table you produced in the previous problem.
				</li>
			</ol>
			
			<p class="Section">
				11.4.1.2 Numeric bases and base conversions
			</p>
			
			<p>Now that we have reviewed the concept of number systems and the idea of counting in a variety of bases, let’s look more carefully at what exactly a numeric “base” is.</p>
			
			<p>
				As you learned long ago in grade school, 123 is the way we normally write the number one hundred twenty three.  This is because the “1” is in the hundreds place, the “2” is in the tens place and the “3” is in the ones place.  Each digit is multiplied by the value of its position and the results are added together.  This process is illustrated below:
			</p>
			
			<!--illustration 1
			<table border="0" cellspacing="0" cellpadding="0" class="Table4">
			<colgroup><col width="68"/><col width="68"/><col width="68"/></colgroup><tr class="Table41"><td style="text-align:left;width:0.6097in; " class="Table4_A1"><p class="P43">1</p></td><td style="text-align:left;width:0.609in; " class="Table4_A1"><p class="P43">2</p></td><td style="text-align:left;width:0.6167in; " class="Table4_C1"><p class="P43">3</p></td></tr><tr class="Table41"><td style="text-align:left;width:0.6097in; " class="Table4_A2"><p class="P18">100</p></td><td style="text-align:left;width:0.609in; " class="Table4_B2"><p class="P18">10</p></td><td style="text-align:left;width:0.6167in; " class="Table4_C2"><p class="P18">1</p></td></tr><tr class="Table41"><td style="text-align:left;width:0.6097in; " class="Table4_A3"><p class="P40"><span class="T3">10 </span><span class="Superscript">2</span></p></td><td style="text-align:left;width:0.609in; " class="Table4_B3"><p class="P40"><span class="T3">10 </span><span class="Superscript">1</span></p></td><td style="text-align:left;width:0.6167in; " class="Table4_C3"><p class="P40"><span class="T3">10 </span><span class="Superscript">0</span></p></td></tr></table>
			
			<table border="0" cellspacing="0" cellpadding="0" class="Table5">
			<colgroup><col width="18"/><col width="24"/><col width="20"/><col width="35"/><col width="49"/><col width="35"/><col width="55"/><col width="29"/></colgroup><tr class="Table51"><td style="text-align:left;width:0.166in; " class="Table5_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.2167in; " class="Table5_A1"><p>(</p></td><td style="text-align:left;width:0.1819in; " class="Table5_A1"><p>1</p></td><td style="text-align:left;width:0.3125in; " class="Table5_A1"><p class="P60"></p></td><td style="text-align:left;width:0.4431in; " class="Table5_A1"><p class="P14">100</p></td><td style="text-align:left;width:0.3125in; " class="Table5_A1"><p>=</p></td><td style="text-align:left;width:0.4944in; " class="Table5_A1"><p class="P14">100</p></td><td style="text-align:left;width:0.259in; " class="Table5_H1"><p class="P14">)</p></td></tr><tr class="Table51"><td style="text-align:left;width:0.166in; " class="Table5_A1"><p>+</p></td><td style="text-align:left;width:0.2167in; " class="Table5_A1"><p>(</p></td><td style="text-align:left;width:0.1819in; " class="Table5_A1"><p>2</p></td><td style="text-align:left;width:0.3125in; " class="Table5_A1"><p class="P60"></p></td><td style="text-align:left;width:0.4431in; " class="Table5_A1"><p class="P14">10</p></td><td style="text-align:left;width:0.3125in; " class="Table5_A1"><p>=</p></td><td style="text-align:left;width:0.4944in; " class="Table5_A1"><p class="P14">20</p></td><td style="text-align:left;width:0.259in; " class="Table5_H1"><p class="P14">)</p></td></tr><tr class="Table51"><td style="text-align:left;width:0.166in; " class="Table5_A1"><p>+</p></td><td style="text-align:left;width:0.2167in; " class="Table5_A1"><p>(</p></td><td style="text-align:left;width:0.1819in; " class="Table5_A1"><p>3</p></td><td style="text-align:left;width:0.3125in; " class="Table5_A1"><p class="P60"></p></td><td style="text-align:left;width:0.4431in; " class="Table5_A1"><p class="P14">1</p></td><td style="text-align:left;width:0.3125in; " class="Table5_A1"><p>=</p></td><td style="text-align:left;width:0.4944in; " class="Table5_G3"><p class="P14">3</p></td><td style="text-align:left;width:0.259in; " class="Table5_H1"><p class="P14">)</p></td></tr><tr class="Table51"><td style="text-align:left;width:0.166in; " class="Table5_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.2167in; " class="Table5_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.1819in; " class="Table5_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.3125in; " class="Table5_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.4431in; " class="Table5_A1"><p class="P15"> </p></td><td style="text-align:left;width:0.3125in; " class="Table5_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.4944in; " class="Table5_G4"><p class="P14">123</p></td><td style="text-align:left;width:0.259in; " class="Table5_H1"><p class="P15"> </p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-1.png" alt="" class="Image">
			
			<p>
				The system we normally use for representing numbers is called the decimal number system.  In this system, the rightmost digit is referred to as being in the one’s or “units” position.  Immediately to the left of the units position is the ten’s position.  To the left of the ten’s position is the hundred’s position, then the thousand’s, then the ten thousand’s, etc.  The decimal number system is a “base ten” positional number system because the value of each position can be expressed as a power of the number ten.  The exponent that the base is raised to is given by the position minus one.  The leftmost position, or units position, is 10 <span class="Superscript">0</span>, the tens position is 10 <span class="Superscript">1</span>, the hundreds is 10 <span class="Superscript">2</span>, the thousands is 10 <span class="Superscript">3</span>, etc.  The value of each position is exactly ten times the value of the position immediately to its right.
			</p>
			
			<p>
				The other bases work similarly.  In the binary system, the base is two, so the values of the positions (given from right to left) are one (2<span class="Superscript">0</span>), two (2<span class="Superscript">1</span>), four (2<span class="Superscript">2</span>), eight (2<span class="Superscript">3</span>), sixteen (2<span class="Superscript">4</span>), thirty-two (2<span class="Superscript">5</span>), etc.  The value of each position in a base two system is two times the value of the position immediately to its right.  The number five is represented in base two as 101<span class="Subscript">two</span> since there is a one in the four’s position and a one in the units position, as is illustrated below:
			</p>
			
			<!--ill2
			<table border="0" cellspacing="0" cellpadding="0" class="Table6">
			<colgroup><col width="68"/><col width="68"/><col width="68"/></colgroup><tr class="Table61"><td style="text-align:left;width:0.6097in; " class="Table6_A1"><p class="P43">1</p></td><td style="text-align:left;width:0.609in; " class="Table6_A1"><p class="P43">0</p></td><td style="text-align:left;width:0.6167in; " class="Table6_C1"><p class="P43">1</p></td></tr><tr class="Table61"><td style="text-align:left;width:0.6097in; " class="Table6_A2"><p class="P18">4</p></td><td style="text-align:left;width:0.609in; " class="Table6_B2"><p class="P18">2</p></td><td style="text-align:left;width:0.6167in; " class="Table6_C2"><p class="P18">1</p></td></tr><tr class="Table61"><td style="text-align:left;width:0.6097in; " class="Table6_A3"><p class="P40"><span class="T3">2 </span><span class="Superscript">2</span></p></td><td style="text-align:left;width:0.609in; " class="Table6_B3"><p class="P40"><span class="T3">2 </span><span class="Superscript">1</span></p></td><td style="text-align:left;width:0.6167in; " class="Table6_C3"><p class="P40"><span class="T3">2 </span><span class="Superscript">0</span></p></td></tr></table>
			
			<table border="0" cellspacing="0" cellpadding="0" class="Table7">
			<colgroup><col width="18"/><col width="24"/><col width="20"/><col width="42"/><col width="42"/><col width="35"/><col width="27"/><col width="22"/></colgroup><tr class="Table71"><td style="text-align:left;width:0.166in; " class="Table7_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.2167in; " class="Table7_A1"><p>(</p></td><td style="text-align:left;width:0.1819in; " class="Table7_A1"><p>1</p></td><td style="text-align:left;width:0.375in; " class="Table7_A1"><p class="P60"></p></td><td style="text-align:left;width:0.3806in; " class="Table7_A1"><p class="P14">4</p></td><td style="text-align:left;width:0.3125in; " class="Table7_A1"><p>=</p></td><td style="text-align:left;width:0.2444in; " class="Table7_A1"><p class="P14">4</p></td><td style="text-align:left;width:0.1944in; " class="Table7_H1"><p class="P14">)</p></td></tr><tr class="Table71"><td style="text-align:left;width:0.166in; " class="Table7_A1"><p>+</p></td><td style="text-align:left;width:0.2167in; " class="Table7_A1"><p>(</p></td><td style="text-align:left;width:0.1819in; " class="Table7_A1"><p>0</p></td><td style="text-align:left;width:0.375in; " class="Table7_A1"><p class="P60"></p></td><td style="text-align:left;width:0.3806in; " class="Table7_A1"><p class="P14">2</p></td><td style="text-align:left;width:0.3125in; " class="Table7_A1"><p>=</p></td><td style="text-align:left;width:0.2444in; " class="Table7_A1"><p class="P14">0</p></td><td style="text-align:left;width:0.1944in; " class="Table7_H1"><p class="P14">)</p></td></tr><tr class="Table71"><td style="text-align:left;width:0.166in; " class="Table7_A1"><p>+</p></td><td style="text-align:left;width:0.2167in; " class="Table7_A1"><p>(</p></td><td style="text-align:left;width:0.1819in; " class="Table7_A1"><p>1</p></td><td style="text-align:left;width:0.375in; " class="Table7_A1"><p class="P60"></p></td><td style="text-align:left;width:0.3806in; " class="Table7_A1"><p class="P14">1</p></td><td style="text-align:left;width:0.3125in; " class="Table7_A1"><p>=</p></td><td style="text-align:left;width:0.2444in; " class="Table7_G3"><p class="P14">1</p></td><td style="text-align:left;width:0.1944in; " class="Table7_H1"><p class="P14">)</p></td></tr><tr class="Table71"><td style="text-align:left;width:0.166in; " class="Table7_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.2167in; " class="Table7_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.1819in; " class="Table7_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.375in; " class="Table7_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.3806in; " class="Table7_A1"><p class="P15"> </p></td><td style="text-align:left;width:0.3125in; " class="Table7_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.2444in; " class="Table7_G4"><p class="P14">5</p></td><td style="text-align:left;width:0.1944in; " class="Table7_H1"><p class="P15"> </p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-2.png" alt="" class="Image">
			
			<p>
				In the hexadecimal number system, the base is sixteen.  Hence, the values of the positions (again from right to left) are one (16<span class="Superscript">0</span>), sixteen (16<span class="Superscript">1</span>), two hundred fifty six (16<span class="Superscript">2</span>), four thousand ninety six (16<span class="Superscript">3</span>), etc.  The value of each position in this system is exactly sixteen times the value of the position immediately to its right.  The value of the base sixteen number 1A3<span class="Subscript">sixteen</span> is four hundred nineteen, since there is one in the two hundred and fifty six position, ten in the sixteen’s position, and three in the units position.  The calculations illustrating this result are given below.  Note that the computations themselves are shown in the decimal system, since that is the system we are most familiar with.
			</p>
			
			<!--ill3
			<table border="0" cellspacing="0" cellpadding="0" class="Table8">
			<colgroup><col width="68"/><col width="68"/><col width="68"/></colgroup><tr class="Table81"><td style="text-align:left;width:0.6097in; " class="Table8_A1"><p class="P43">1</p></td><td style="text-align:left;width:0.609in; " class="Table8_A1"><p class="P43">A</p></td><td style="text-align:left;width:0.6167in; " class="Table8_C1"><p class="P43">3</p></td></tr><tr class="Table81"><td style="text-align:left;width:0.6097in; " class="Table8_A2"><p class="P18">256</p></td><td style="text-align:left;width:0.609in; " class="Table8_B2"><p class="P18">16</p></td><td style="text-align:left;width:0.6167in; " class="Table8_C2"><p class="P18">1</p></td></tr><tr class="Table81"><td style="text-align:left;width:0.6097in; " class="Table8_A3"><p class="P40"><span class="T3">16 </span><span class="Superscript">2</span></p></td><td style="text-align:left;width:0.609in; " class="Table8_B3"><p class="P40"><span class="T3">16 </span><span class="Superscript">1</span></p></td><td style="text-align:left;width:0.6167in; " class="Table8_C3"><p class="P40"><span class="T3">16 </span><span class="Superscript">0</span></p></td></tr></table>
			
			<table border="0" cellspacing="0" cellpadding="0" class="Table9">
			<colgroup><col width="18"/><col width="18"/><col width="40"/><col width="21"/><col width="49"/><col width="35"/><col width="62"/><col width="21"/></colgroup><tr class="Table91"><td style="text-align:left;width:0.166in; " class="Table9_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.166in; " class="Table9_A1"><p>(</p></td><td style="text-align:left;width:0.3576in; " class="Table9_A1"><p>1</p></td><td style="text-align:left;width:0.1875in; " class="Table9_A1"><p class="P61"></p></td><td style="text-align:left;width:0.4431in; " class="Table9_A1"><p class="P14">256</p></td><td style="text-align:left;width:0.3125in; " class="Table9_A1"><p>=</p></td><td style="text-align:left;width:0.5625in; " class="Table9_A1"><p class="P14">256</p></td><td style="text-align:left;width:0.191in; " class="Table9_H1"><p class="P14">)</p></td></tr><tr class="Table91"><td style="text-align:left;width:0.166in; " class="Table9_A1"><p>+</p></td><td style="text-align:left;width:0.166in; " class="Table9_A1"><p>(</p></td><td style="text-align:left;width:0.3576in; " class="Table9_A1"><p>10</p></td><td style="text-align:left;width:0.1875in; " class="Table9_A1"><p class="P61"></p></td><td style="text-align:left;width:0.4431in; " class="Table9_A1"><p class="P14">16</p></td><td style="text-align:left;width:0.3125in; " class="Table9_A1"><p>=</p></td><td style="text-align:left;width:0.5625in; " class="Table9_A1"><p class="P14">160</p></td><td style="text-align:left;width:0.191in; " class="Table9_H1"><p class="P14">)</p></td></tr><tr class="Table91"><td style="text-align:left;width:0.166in; " class="Table9_A1"><p>+</p></td><td style="text-align:left;width:0.166in; " class="Table9_A1"><p>(</p></td><td style="text-align:left;width:0.3576in; " class="Table9_A1"><p>3</p></td><td style="text-align:left;width:0.1875in; " class="Table9_A1"><p class="P61"></p></td><td style="text-align:left;width:0.4431in; " class="Table9_A1"><p class="P14">1</p></td><td style="text-align:left;width:0.3125in; " class="Table9_A1"><p>=</p></td><td style="text-align:left;width:0.5625in; " class="Table9_G3"><p class="P14">3</p></td><td style="text-align:left;width:0.191in; " class="Table9_H1"><p class="P14">)</p></td></tr><tr class="Table91"><td style="text-align:left;width:0.166in; " class="Table9_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.166in; " class="Table9_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.3576in; " class="Table9_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.1875in; " class="Table9_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.4431in; " class="Table9_A1"><p class="P15"> </p></td><td style="text-align:left;width:0.3125in; " class="Table9_A1"><p class="P25"> </p></td><td style="text-align:left;width:0.5625in; " class="Table9_G4"><p class="P14">419</p></td><td style="text-align:left;width:0.191in; " class="Table9_H1"><p class="P15"> </p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-3.png" alt="" class="Image">
			
			<p>
				As a final example, Figure 11.14 illustrates the representation of the number “nineteen ninety nine” in all three of the bases we have discussed (base ten, base two, and base sixteen).
			</p>
			
			<p>
				One of the most common tasks we face when working with multiple bases is converting numbers from one base to another.  We have already seen how to convert from base sixteen and base two to base ten – simply multiply the value of each symbol by the value of its position and add the results together.  But how do we convert from base ten to base sixteen or to base two?  We also need to figure out how to convert from base two to base sixteen and from base sixteen to base two. 
			</p>
			
			<p>
				Converting from base two to base sixteen and from base sixteen to base two is easy.  In fact, the only reason computer scientists even use base sixteen is because it serves as convenient “shorthand” for base two.  Figure 11.15 illustrates the fact that each base sixteen digit can be represented by a group of exactly four base two digits.  
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-14pt1.png" alt="" class="Image">
			<img src="Images/AssemblyIMGS/fig11-14pt2.png" alt="" class="Image">
			<img src="Images/AssemblyIMGS/fig11-14pt3.png" alt="" class="Image">

			<p class="Figure">
				Figure 11.14:  Nineteen ninety nine – written in base ten, base two, and base sixteen
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-15.png" alt="" class="Image">

			<p class="Figure">
				Figure 11.15:  Hexadecimal digits and their binary equivalence’s
			</p>
			
			<p>
				To convert from base sixteen to base two, simply replace each base sixteen digit with its corresponding group of four binary digits.  For example, the rather imposing hexadecimal number 1AFC3<span class="Subscript">sixteen</span> can easily be converted its binary representation as illustrated in Figure 11.16
			</p>
			
			<p>
				Converting from base two to base sixteen is just as straightforward.  We scan the base two number from right to left replacing each group of four binary digits that we encounter with the equivalent hexadecimal digit. It is important that we group the digits of the base two representation from <span class="Ital">right to left</span> in case the number of digits is not evenly divisible by four.  If this occurs, we simply add leading 0’s until the number of digits is divisible by four.  Conversion of the bit pattern 11111001111<span class="Subscript">two</span> to its hexadecimal representation is represented in Figure 11.17
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-16.png" alt="" class="Image">
			
			<p class="Figure">
				Figure 11.16:  Conversion of a number from base sixteen to base two
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-17.png" alt="" class="Image">
			
			<p>                                            L                                                   R</p>
						
			<p class="Figure">
				Figure 11.17:  Conversion of a number from base two to base sixteen
			</p>
			
			<p>
				It is important that you understand that these conversions between binary and hexadecimal representations in no way change the actual number being represented, 7CF<span class="Subscript">sixteen</span> and 11111001111<span class="Subscript">two</span> both refer to the same number 1999<span class="Subscript">ten</span> as was illustrated in Figure 11.14
			</p>
			
			<p>
				We have now looked at conversion methods from base two (and base sixteen) to base ten (Figure 11.14), from base sixteen to base two (Figure 11.16), and from base two to base sixteen (Figure 11.17).   The only conversions involving decimal, hexadecimal, and binary that we have yet to cover are from base ten to base sixteen and from base ten to base two.  We really only need to look at base ten to base two conversion, since conversion between base two and sixteen is so trivial.  If you have a base ten number and want its base sixteen representation, you can apply a decimal to binary conversion algorithm and then change the base two result to its base sixteen representation via the grouping method described above.
			</p>
			
			<p>
				A number can be converted from decimal to binary by subtracting from it the largest power of two that is less than or equal to the number, repeating until a remainder of zero is reached.  The binary representation of the number is then formed by placing a “1” in the positions corresponding to each of the powers of two that were subtracted.  A “0” is placed in the positions corresponding to the powers of two that were not subtracted.  
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-18.png" alt="" class="Image">
			
			<p class="Figure">
				Figure 11.18:  Conversion of a number from base ten to base two 
			</p>
			
			<p>
				Given the decimal number 37, the largest power of two that can be subtracted is 32 = 2 <span class="Superscript">5</span>, leaving a remainder of five.  The largest power of two that can be subtracted from 5 is     4 = 2 <span class="Superscript">2</span>, which leaves a remainder of one.  Finally, the largest power of two that can be subtracted from 1 is 1=2 <span class="Superscript">0</span>, leaving a remainder of zero.  The base two representation of the number is thus formed by placing 1’s in the thirty-two’s, four’s, and units positions and 0’s in all other positions, giving 100101.  The conversion process for this number is illustrated in Figure 11.18.
			</p>
			
			<p class="Section">
				Exercises for Section 11.4.1.2
			</p>
			
			<ol>
				<li>
					Convert the following numbers from base two to base ten.
					<img src="Images/AssemblyIMGS/ex11-4-1-2-num1.png" alt="" class="Image">
					
			<!--table of stuff
			<table border="0" cellspacing="0" cellpadding="0" class="Table24">
			<colgroup><col width="105"/><col width="104"/><col width="125"/><col width="125"/></colgroup><tr class="Table241"><td style="text-align:left;width:0.95in; " class="Table24_A1"><p class="P12">a.</p></td><td style="text-align:left;width:0.9375in; " class="Table24_A1"><p class="P12">1</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">i.</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">1100</p></td></tr><tr class="Table241"><td style="text-align:left;width:0.95in; " class="Table24_A1"><p class="P12">b.</p></td><td style="text-align:left;width:0.9375in; " class="Table24_A1"><p class="P12">10</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">j.</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">1010</p></td></tr><tr class="Table241"><td style="text-align:left;width:0.95in; " class="Table24_A1"><p class="P12">c.</p></td><td style="text-align:left;width:0.9375in; " class="Table24_A1"><p class="P12">100</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">k.</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">10 1010</p></td></tr><tr class="Table241"><td style="text-align:left;width:0.95in; " class="Table24_A1"><p class="P12">d.</p></td><td style="text-align:left;width:0.9375in; " class="Table24_A1"><p class="P12">1000</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">l.</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">1010 1010</p></td></tr><tr class="Table241"><td style="text-align:left;width:0.95in; " class="Table24_A1"><p class="P12">e.</p></td><td style="text-align:left;width:0.9375in; " class="Table24_A1"><p class="P12">1 0000</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">m.</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">101 0101</p></td></tr><tr class="Table241"><td style="text-align:left;width:0.95in; " class="Table24_A1"><p class="P12">f.</p></td><td style="text-align:left;width:0.9375in; " class="Table24_A1"><p class="P12">10 0000</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">n.</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">0011 1111</p></td></tr><tr class="Table241"><td style="text-align:left;width:0.95in; " class="Table24_A1"><p class="P12">g.</p></td><td style="text-align:left;width:0.9375in; " class="Table24_A1"><p class="P12">100 0000</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">o.</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">0110 1010</p></td></tr><tr class="Table241"><td style="text-align:left;width:0.95in; " class="Table24_A1"><p class="P12">h.</p></td><td style="text-align:left;width:0.9375in; " class="Table24_A1"><p class="P12">1000 0000</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12">p.</p></td><td style="text-align:left;width:1.125in; " class="Table24_A1"><p class="P12"> 0111</p></td></tr></table>
				-->
				</li>
				<li>
					Convert the following numbers from base sixteen to base ten. 
					<img src="Images/AssemblyIMGS/ex11-4-1-2-num2.png" alt="" class="Image">
			<!--table of stuff
			<table border="0" cellspacing="0" cellpadding="0" class="Table25">
			<colgroup><col width="105"/><col width="104"/><col width="125"/><col width="125"/></colgroup><tr class="Table251"><td style="text-align:left;width:0.95in; " class="Table25_A1"><p class="P12">a.</p></td><td style="text-align:left;width:0.9375in; " class="Table25_A1"><p class="P12">1</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">i.</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">AA</p></td></tr><tr class="Table251"><td style="text-align:left;width:0.95in; " class="Table25_A1"><p class="P12">b.</p></td><td style="text-align:left;width:0.9375in; " class="Table25_A1"><p class="P12">10</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">j.</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">A1A</p></td></tr><tr class="Table251"><td style="text-align:left;width:0.95in; " class="Table25_A1"><p class="P12">c.</p></td><td style="text-align:left;width:0.9375in; " class="Table25_A1"><p class="P12">100</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">k.</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">1CAB</p></td></tr><tr class="Table251"><td style="text-align:left;width:0.95in; " class="Table25_A1"><p class="P12">d.</p></td><td style="text-align:left;width:0.9375in; " class="Table25_A1"><p class="P12">1000</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">l.</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">ABBA</p></td></tr><tr class="Table251"><td style="text-align:left;width:0.95in; " class="Table25_A1"><p class="P12">e.</p></td><td style="text-align:left;width:0.9375in; " class="Table25_A1"><p class="P12">12 </p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">m.</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">F1</p></td></tr><tr class="Table251"><td style="text-align:left;width:0.95in; " class="Table25_A1"><p class="P12">f.</p></td><td style="text-align:left;width:0.9375in; " class="Table25_A1"><p class="P12">21</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">n.</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">101</p></td></tr><tr class="Table251"><td style="text-align:left;width:0.95in; " class="Table25_A1"><p class="P12">g.</p></td><td style="text-align:left;width:0.9375in; " class="Table25_A1"><p class="P12">37</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">o.</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">DAD</p></td></tr><tr class="Table251"><td style="text-align:left;width:0.95in; " class="Table25_A1"><p class="P12">h.</p></td><td style="text-align:left;width:0.9375in; " class="Table25_A1"><p class="P12">A1</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">p.</p></td><td style="text-align:left;width:1.125in; " class="Table25_A1"><p class="P12">007</p></td></tr></table>
				-->
				</li>
				<li>
					Convert the following numbers from base sixteen to base two.
					<img src="Images/AssemblyIMGS/ex11-4-1-2-num3.png" alt="" class="Image">
			<!--table of stuff
			<table border="0" cellspacing="0" cellpadding="0" class="Table26">
			<colgroup><col width="105"/><col width="104"/><col width="125"/><col width="125"/></colgroup><tr class="Table261"><td style="text-align:left;width:0.95in; " class="Table26_A1"><p class="P12">a.</p></td><td style="text-align:left;width:0.9375in; " class="Table26_A1"><p class="P12">1</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">i.</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">AA</p></td></tr><tr class="Table261"><td style="text-align:left;width:0.95in; " class="Table26_A1"><p class="P12">b.</p></td><td style="text-align:left;width:0.9375in; " class="Table26_A1"><p class="P12">10</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">j.</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">A1A</p></td></tr><tr class="Table261"><td style="text-align:left;width:0.95in; " class="Table26_A1"><p class="P12">c.</p></td><td style="text-align:left;width:0.9375in; " class="Table26_A1"><p class="P12">100</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">k.</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">1CAB</p></td></tr><tr class="Table261"><td style="text-align:left;width:0.95in; " class="Table26_A1"><p class="P12">d.</p></td><td style="text-align:left;width:0.9375in; " class="Table26_A1"><p class="P12">1000</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">l.</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">ABBA</p></td></tr><tr class="Table261"><td style="text-align:left;width:0.95in; " class="Table26_A1"><p class="P12">e.</p></td><td style="text-align:left;width:0.9375in; " class="Table26_A1"><p class="P12">12 </p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">m.</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">F1</p></td></tr><tr class="Table261"><td style="text-align:left;width:0.95in; " class="Table26_A1"><p class="P12">f.</p></td><td style="text-align:left;width:0.9375in; " class="Table26_A1"><p class="P12">21</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">n.</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">101</p></td></tr><tr class="Table261"><td style="text-align:left;width:0.95in; " class="Table26_A1"><p class="P12">g.</p></td><td style="text-align:left;width:0.9375in; " class="Table26_A1"><p class="P12">37</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">o.</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">DAD</p></td></tr><tr class="Table261"><td style="text-align:left;width:0.95in; " class="Table26_A1"><p class="P12">h.</p></td><td style="text-align:left;width:0.9375in; " class="Table26_A1"><p class="P12">A1</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">p.</p></td><td style="text-align:left;width:1.125in; " class="Table26_A1"><p class="P12">007</p></td></tr></table>
				-->
				</li>
				<li>
					Convert the following numbers from base two to base sixteen.
					<img src="Images/AssemblyIMGS/ex11-4-1-2-num4.png" alt="" class="Image">
			<!--table of stuff
			<table border="0" cellspacing="0" cellpadding="0" class="Table27">
			<colgroup><col width="105"/><col width="104"/><col width="125"/><col width="125"/></colgroup><tr class="Table271"><td style="text-align:left;width:0.95in; " class="Table27_A1"><p class="P12">a.</p></td><td style="text-align:left;width:0.9375in; " class="Table27_A1"><p class="P12">1</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">i.</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">1100</p></td></tr><tr class="Table271"><td style="text-align:left;width:0.95in; " class="Table27_A1"><p class="P12">b.</p></td><td style="text-align:left;width:0.9375in; " class="Table27_A1"><p class="P12">10</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">j.</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">1010</p></td></tr><tr class="Table271"><td style="text-align:left;width:0.95in; " class="Table27_A1"><p class="P12">c.</p></td><td style="text-align:left;width:0.9375in; " class="Table27_A1"><p class="P12">100</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">k.</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">10 1010</p></td></tr><tr class="Table271"><td style="text-align:left;width:0.95in; " class="Table27_A1"><p class="P12">d.</p></td><td style="text-align:left;width:0.9375in; " class="Table27_A1"><p class="P12">1000</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">l.</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">1010 1010</p></td></tr><tr class="Table271"><td style="text-align:left;width:0.95in; " class="Table27_A1"><p class="P12">e.</p></td><td style="text-align:left;width:0.9375in; " class="Table27_A1"><p class="P12">1 0000</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">m.</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">101 0101</p></td></tr><tr class="Table271"><td style="text-align:left;width:0.95in; " class="Table27_A1"><p class="P12">f.</p></td><td style="text-align:left;width:0.9375in; " class="Table27_A1"><p class="P12">10 0000</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">n.</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">0011 1111</p></td></tr><tr class="Table271"><td style="text-align:left;width:0.95in; " class="Table27_A1"><p class="P12">g.</p></td><td style="text-align:left;width:0.9375in; " class="Table27_A1"><p class="P12">100 0000</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">o.</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">0110 1010</p></td></tr><tr class="Table271"><td style="text-align:left;width:0.95in; " class="Table27_A1"><p class="P12">h.</p></td><td style="text-align:left;width:0.9375in; " class="Table27_A1"><p class="P12">1000 0000</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12">p.</p></td><td style="text-align:left;width:1.125in; " class="Table27_A1"><p class="P12"> 0111</p></td></tr></table>
				-->
				</li>
				<li>
					Convert the following numbers from base ten to base two.
					<img src="Images/AssemblyIMGS/ex11-4-1-2-num5.png" alt="" class="Image">
			<!--table of stuff
			<table border="0" cellspacing="0" cellpadding="0" class="Table28">
			<colgroup><col width="105"/><col width="104"/><col width="125"/><col width="125"/></colgroup><tr class="Table281"><td style="text-align:left;width:0.95in; " class="Table28_A1"><p class="P12">a.</p></td><td style="text-align:left;width:0.9375in; " class="Table28_A1"><p class="P12">1</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">i.</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">67</p></td></tr><tr class="Table281"><td style="text-align:left;width:0.95in; " class="Table28_A1"><p class="P12">b.</p></td><td style="text-align:left;width:0.9375in; " class="Table28_A1"><p class="P12">10</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">j.</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">150</p></td></tr><tr class="Table281"><td style="text-align:left;width:0.95in; " class="Table28_A1"><p class="P12">c.</p></td><td style="text-align:left;width:0.9375in; " class="Table28_A1"><p class="P12">100</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">k.</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">2001</p></td></tr><tr class="Table281"><td style="text-align:left;width:0.95in; " class="Table28_A1"><p class="P12">d.</p></td><td style="text-align:left;width:0.9375in; " class="Table28_A1"><p class="P12">1000</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">l.</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">42</p></td></tr><tr class="Table281"><td style="text-align:left;width:0.95in; " class="Table28_A1"><p class="P12">e.</p></td><td style="text-align:left;width:0.9375in; " class="Table28_A1"><p class="P12">12 </p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">m.</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">1984</p></td></tr><tr class="Table281"><td style="text-align:left;width:0.95in; " class="Table28_A1"><p class="P12">f.</p></td><td style="text-align:left;width:0.9375in; " class="Table28_A1"><p class="P12">21</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">n.</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">101</p></td></tr><tr class="Table281"><td style="text-align:left;width:0.95in; " class="Table28_A1"><p class="P12">g.</p></td><td style="text-align:left;width:0.9375in; " class="Table28_A1"><p class="P12">37</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">o.</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">1492</p></td></tr><tr class="Table281"><td style="text-align:left;width:0.95in; " class="Table28_A1"><p class="P12">h.</p></td><td style="text-align:left;width:0.9375in; " class="Table28_A1"><p class="P12">123</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">p.</p></td><td style="text-align:left;width:1.125in; " class="Table28_A1"><p class="P12">007</p></td></tr></table>
				-->
			</li>
				<li>
					Convert the following numbers from base ten to base sixteen.
					<img src="Images/AssemblyIMGS/ex11-4-1-2-num6.png" alt="" class="Image">
			<!--table of stuff
			<table border="0" cellspacing="0" cellpadding="0" class="Table29">
			<colgroup><col width="105"/><col width="104"/><col width="125"/><col width="125"/></colgroup><tr class="Table291"><td style="text-align:left;width:0.95in; " class="Table29_A1"><p class="P12">a.</p></td><td style="text-align:left;width:0.9375in; " class="Table29_A1"><p class="P12">1</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">i.</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">67</p></td></tr><tr class="Table291"><td style="text-align:left;width:0.95in; " class="Table29_A1"><p class="P12">b.</p></td><td style="text-align:left;width:0.9375in; " class="Table29_A1"><p class="P12">10</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">j.</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">150</p></td></tr><tr class="Table291"><td style="text-align:left;width:0.95in; " class="Table29_A1"><p class="P12">c.</p></td><td style="text-align:left;width:0.9375in; " class="Table29_A1"><p class="P12">100</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">k.</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">2001</p></td></tr><tr class="Table291"><td style="text-align:left;width:0.95in; " class="Table29_A1"><p class="P12">d.</p></td><td style="text-align:left;width:0.9375in; " class="Table29_A1"><p class="P12">1000</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">l.</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">42</p></td></tr><tr class="Table291"><td style="text-align:left;width:0.95in; " class="Table29_A1"><p class="P12">e.</p></td><td style="text-align:left;width:0.9375in; " class="Table29_A1"><p class="P12">12 </p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">m.</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">1984</p></td></tr><tr class="Table291"><td style="text-align:left;width:0.95in; " class="Table29_A1"><p class="P12">f.</p></td><td style="text-align:left;width:0.9375in; " class="Table29_A1"><p class="P12">21</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">n.</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">101</p></td></tr><tr class="Table291"><td style="text-align:left;width:0.95in; " class="Table29_A1"><p class="P12">g.</p></td><td style="text-align:left;width:0.9375in; " class="Table29_A1"><p class="P12">37</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">o.</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">1492</p></td></tr><tr class="Table291"><td style="text-align:left;width:0.95in; " class="Table29_A1"><p class="P12">h.</p></td><td style="text-align:left;width:0.9375in; " class="Table29_A1"><p class="P12">123</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">p.</p></td><td style="text-align:left;width:1.125in; " class="Table29_A1"><p class="P12">007</p></td></tr></table>
				-->
				</li>
			</ol>
			
			<p class="Section">
				11.4.1.3 Binary arithmetic
			</p>
			
			<p>
				So far we have learned how to represent unsigned numbers in base ten, base two, and base sixteen.  We have also studied ways of converting numbers between these three bases.  We now turn our attention to the question of how arithmetic operations, such as addition and multiplication, can be performed on unsigned binary numbers.<span class="Footnote" title="Footnote: We’ll hold off on subtraction until we discuss ways of representing negative numbers in the next part of this section."><a href="#ftn4" id="body_ftn4">[4]</a></span>
			</p>
			
			<p>
				Let’s begin by examining binary addition of single digit numbers.   First of all, zero plus zero equals zero, which is represented in binary as: 
			</p>
			
			<p class="Subfigure">
				0 + 0 = 0
			</p>
			
			<p>
				Zero plus one and one plus zero both equal one.  These expressions are represented as:
			</p>
			
			<p class="Subfigure">
				0 + 1 = 1
			</p>
			
			<p class="Subfigure">
				1 + 0 = 1
			</p>
			
			<p>
				Finally, one plus one equals two.  But, two cannot be represented as a single binary digit.  Instead, we record a zero in the one’s position and carry a one over to the two’s position.
			</p>
			
			<p>
				This situation can be represented as:
			</p>
			
			<p class="Subfigure">
				1 + 1 = 0  [carry 1]
			</p>
			
			<p>
				Multi-digit binary addition uses the same strategy employed in decimal addition.  One works right to left from the units column to the most significant digit making sure that the carry from the previous column is added to the current column.  Because the carry digit for a particular column may be “1” at the same time the corresponding digits of both of the numbers being added are also “1”, it is possible to encounter “one plus one plus one equal three” while performing addition.  Since 11<span class="Subscript">two</span> equals three, “1”should be placed in the current position and another “1” carried over to the position immediately to the left of the current position.  This situation can be represented as:
			</p>
			
			<p class="Subfigure">
				1 + 1 + 1 = 1 [carry 1]
			</p>
			
			<p>
				Figure 11.19 illustrates two separate binary addition operations.  Part (a) of the figure presents the addition of 38<span class="Subscript">ten</span> + 15<span class="Subscript">ten</span> = 53<span class="Subscript">ten</span> written in both its binary and decimal form.  Part (b) of the figure involves slightly larger numbers, but the principle is the same.  The expression 43<span class="Subscript">ten</span> + 58<span class="Subscript">ten</span> = 101<span class="Subscript">ten</span> is shown in both its binary and decimal form.
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-19a.png" alt="" class="Image">
			
			<p class="Figure">
				Part (a) – Thirty-eight plus fifteen
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-19b.png" alt="" class="Image">
			
			<p class="Figure">
				Part (b) – Forty-three plus fifty-eight
			</p>
			
			<p class="Figure">
				Figure 11.19:  Addition in base two and base ten
			</p>
			
			<p>
				Binary multiplication is also fairly simple.  Zero times zero equals zero, as does zero times one and one times zero.  One times one equals one.  These expressions can be represented in base two as:
			</p>
			
			<p class="Subfigure">
				0 &#215; 0 = 0
			</p>
			
			<p class="Subfigure">
				0 &#215; 1 = 0
			</p>
			
			<p class="Subfigure">
				1 &#215; 0 = 0
			</p>
			
			<p class="Subfigure">
				1 &#215; 1 = 1
			</p>
			
			<p>
				Notice that none of these four expressions generate a carry and only one generates a result other than zero.  As we will see below, these features lead to binary multiplication being easy to perform, in fact easier to perform than decimal multiplication.
			</p>
			
			<p>
				Multiplication of multi-digit binary numbers works in a manner similar to multiplication of decimal numbers.  As we all learned in grade school, multiplication problems are solved by adding together several partial products.  A partial product is formed by multiplying a single digit of the bottom number times the entire top number.  For example, given the base ten multiplication problem 472 &#215; 104, we would solve it in the following way.
			</p>
			
			<!--ill4
			<table border="0" cellspacing="0" cellpadding="0" class="Table32">
			<colgroup><col width="49"/><col width="49"/><col width="49"/><col width="49"/><col width="49"/></colgroup><tr class="Table321"><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p class="P19"> </p></td><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p class="P19"> </p></td><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p>4</p></td><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p>7</p></td><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p>2</p></td></tr><tr class="Table321"><td style="text-align:left;width:0.4438in; " class="Table32_A2"><p class="P19"> </p></td><td style="text-align:left;width:0.4438in; " class="Table32_A2"><p class="P19"> </p></td><td style="text-align:left;width:0.4438in; " class="Table32_A2"><p>1</p></td><td style="text-align:left;width:0.4438in; " class="Table32_A2"><p>0</p></td><td style="text-align:left;width:0.4438in; " class="Table32_A2"><p>4</p></td></tr><tr class="Table321"><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p class="P19"> </p></td><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p>1</p></td><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p>8</p></td><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p>8</p></td><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p>8</p></td></tr><tr class="Table321"><td style="text-align:left;width:0.4438in; " class="Table32_A2"><p>4</p></td><td style="text-align:left;width:0.4438in; " class="Table32_A2"><p>7</p></td><td style="text-align:left;width:0.4438in; " class="Table32_A2"><p>2</p></td><td style="text-align:left;width:0.4438in; " class="Table32_A2"><p class="P19"> </p></td><td style="text-align:left;width:0.4438in; " class="Table32_A2"><p class="P19"> </p></td></tr><tr class="Table321"><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p>4</p></td><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p>9</p></td><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p>0</p></td><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p>8</p></td><td style="text-align:left;width:0.4438in; " class="Table32_A1"><p>8</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-4.png" alt="" class="Image">
			
			<p>
				The first partial product is given by multiplying 4 times 472, which is 1888.  The second partial product is computed as 0 times 472, which is 0.  Normally we do not write down zero partial products.  The final partial product is 1 times 472.   Notice that we write this partial product so that its rightmost digit is directly under the digit of the second number that we multiplied by (i.e., 1). We then add the partial products, column by column from right to left, in order to obtain the final answer, 49,088 in this case.  
			</p>
			
			<p>
				We apply this same strategy to perform binary multiplication.  Figure 11.20 illustrates two separate binary multiplication operations.  Part (a) of the figure presents 19<span class="Subscript">ten</span> &#215; 5<span class="Subscript">ten</span> = 95<span class="Subscript">ten</span> (10011<span class="Subscript">two</span> &#215; 101<span class="Subscript">two</span> = 1011111<span class="Subscript">two</span>) in both binary and decimal notations.
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-20a.png" alt="" class="Image">

			<p class="Figure">
				Part (a) – Nineteen times five
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-20b.png" alt="" class="Image">

			<p class="Figure">
				Part (b) – One hundred forty-three times nineteen
			</p>
			
			<p class="Figure">
				Figure 11.20:  Multiplication in base two and base ten
			</p>
			
			<p>
				Again we form partial products by multiplying the top number by each of the digits of the bottom number.  Since the rightmost digit of the second number is “1”, the first partial product is given by 1 times 10011, or 10011.  The rightmost digit of this partial product is aligned with the rightmost digit of the second number.  We do not record the partial product for zero times something, so multiplying the first number by the second digit of the second number, “0”, doesn’t generate anything.  The final partial product is computed as 1 times 10011 where the rightmost digit of this result is aligned beneath the third digit of the second number. The partial products are then added to obtain the final result, 1011111<span class="Subscript">two</span>.
			</p>
			
			<p>
				As we have just seen, in binary multiplication the formation of the partial products is very easy since we are only multiplying by “1” ( in which case we copy the top number into the proper position ) or “0” ( in which case we do nothing ).  The only “difficult” steps in this process are making sure we align the partial products correctly and compute the sum of those products accurately.
			</p>
			
			<p>
				Part (b) of Figure 11.20 illustrates binary multiplication on somewhat larger numbers. We copy the top number as a partial product everywhere there is a 1 digit in the second number, each time making sure we align the partial product so that the least significant digit is directly underneath the 1 we are multiplying by.  We get the final result by adding the partial products together.
			</p>
			
			<p>
				When adding together the partial products it is important that we handle the carry values properly.  Because there is no limit on the size of the numbers to be multiplied, it is possible that there will be a large number of partial products.  This situation can lead to carry values that extend over multiple columns.  To illustrate, if, when summing partial products, we encounter a column of five 1’s, we would add 1 + 1 + 1 + 1 + 1 to get 101<span class="Subscript">two.</span>  We would then need to write a “1” in the current column and carry “10”; placing the “0” in the column immediately to the left of the current column and the “1” immediately to the left of that column.  This is no different from the situation we encounter when adding up a long series of decimal numbers.  If the current column of digits added to one hundred and one, we would place a “1” in the current column, carry a “0” to the next column, and carry “1” to the column after that.
			</p>
			
			<p>
				Now let’s take a closer look at the summation of the partial products in Part (b) of Figure 11.20.  The rightmost column of partial products offers no problem.  It is simply “1” plus nothing, giving a result of “1” with no carry.  The second column requires us to add 1 + 1 resulting in a “0” with “1” carried over to the third column.  Column three is interesting and is illustrated below:
			</p>
			
			<!--ill5
			<table border="0" cellspacing="0" cellpadding="0" class="Table35">
			<colgroup><col width="45"/><col width="45"/><col width="45"/><col width="45"/><col width="45"/></colgroup><tr class="Table351"><td style="text-align:left;width:0.4021in; " class="Table35_A1"><p class="P47">1</p></td><td style="text-align:left;width:0.4028in; " class="Table35_A1"><p class="P47">0</p></td><td style="text-align:left;width:0.4021in; " class="Table35_A1"><p class="P47">1</p></td><td style="text-align:left;width:0.4028in; " class="Table35_A1"><p class="P48"> </p></td><td style="text-align:left;width:0.4028in; " class="Table35_A1"><p class="P48"> </p></td></tr><tr class="Table351"><td style="text-align:left;width:0.4021in; " class="Table35_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4028in; " class="Table35_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4021in; " class="Table35_C2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table35_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table35_E2"><p class="Subfigure">1</p></td></tr><tr class="Table351"><td style="text-align:left;width:0.4021in; " class="Table35_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table35_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4021in; " class="Table35_C2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table35_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table35_E3"><p class="P44"> </p></td></tr><tr class="Table351"><td style="text-align:left;width:0.4021in; " class="Table35_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table35_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4021in; " class="Table35_C2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table35_D4"><p class="P44"> </p></td><td style="text-align:left;width:0.4028in; " class="Table35_E4"><p class="P44"> </p></td></tr><tr class="Table351"><td style="text-align:left;width:0.4021in; " class="Table35_A5"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table35_B5"><p class="P44"> </p></td><td style="text-align:left;width:0.4021in; " class="Table35_C5"><p class="P44"> </p></td><td style="text-align:left;width:0.4028in; " class="Table35_D5"><p class="P44"> </p></td><td style="text-align:left;width:0.4028in; " class="Table35_E5"><p class="P44"> </p></td></tr><tr class="Table351"><td style="text-align:left;width:0.4021in; " class="Table35_A6"><p class="P44"> </p></td><td style="text-align:left;width:0.4028in; " class="Table35_B6"><p class="P44"> </p></td><td style="text-align:left;width:0.4021in; " class="Table35_C6"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4028in; " class="Table35_D6"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4028in; " class="Table35_E6"><p class="Subfigure">1</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-5.png" alt="" class="Image">
			
			<p>
				The sum of the digits in column three, including the carry, is four, 100<span class="Subscript">two</span>.  Hence, a “0” is written in column three, a “0” is carried to column four and a “1” to column five.
			</p>
			
			<p>
				Column four contains three 1’s giving us a sum of 11<span class="Subscript">two</span>.  Hence, we write a “1” in column four and carry a “1” to column five. Note that the “1” we just carried to column five joins the carry of “1” already in that column.
			</p>
			
			<!--ill6
			<table border="0" cellspacing="0" cellpadding="0" class="Table36">
			<colgroup><col width="45"/><col width="45"/><col width="45"/><col width="45"/><col width="45"/></colgroup><tr class="Table361"><td style="text-align:left;width:0.4021in; " class="Table36_A1"><p class="P47">1</p><p class="P47">1</p></td><td style="text-align:left;width:0.4028in; " class="Table36_A1"><p class="P48"> </p><p class="P47">0</p></td><td style="text-align:left;width:0.4021in; " class="Table36_A1"><p class="P48"> </p><p class="P47">1</p></td><td style="text-align:left;width:0.4028in; " class="Table36_A1"><p class="P48"> </p></td><td style="text-align:left;width:0.4028in; " class="Table36_A1"><p class="P48"> </p></td></tr><tr class="Table361"><td style="text-align:left;width:0.4021in; " class="Table36_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4028in; " class="Table36_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4021in; " class="Table36_C2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table36_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table36_E2"><p class="Subfigure">1</p></td></tr><tr class="Table361"><td style="text-align:left;width:0.4021in; " class="Table36_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table36_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4021in; " class="Table36_C2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table36_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table36_E3"><p class="P44"> </p></td></tr><tr class="Table361"><td style="text-align:left;width:0.4021in; " class="Table36_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table36_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4021in; " class="Table36_C2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table36_D4"><p class="P44"> </p></td><td style="text-align:left;width:0.4028in; " class="Table36_E4"><p class="P44"> </p></td></tr><tr class="Table361"><td style="text-align:left;width:0.4021in; " class="Table36_A5"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table36_B5"><p class="P44"> </p></td><td style="text-align:left;width:0.4021in; " class="Table36_C5"><p class="P44"> </p></td><td style="text-align:left;width:0.4028in; " class="Table36_D5"><p class="P44"> </p></td><td style="text-align:left;width:0.4028in; " class="Table36_E5"><p class="P44"> </p></td></tr><tr class="Table361"><td style="text-align:left;width:0.4021in; " class="Table36_A6"><p class="P44"> </p></td><td style="text-align:left;width:0.4028in; " class="Table36_B6"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4021in; " class="Table36_C6"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4028in; " class="Table36_D6"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4028in; " class="Table36_E6"><p class="Subfigure">1</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-6.png" alt="" class="Image">
			
			<p>
				Column five now contains a total of five 1’s (including the two carries).  Since five is written in binary as 101<span class="Subscript">two</span>, we write a “1” in column five, carry a “0” into column six and a “1” into column seven.  The current state of the summation of partial products after adding the contents of column five is illustrated below:
			</p>
			
			<!--ill7
			<table border="0" cellspacing="0" cellpadding="0" class="Table37">
			<colgroup><col width="45"/><col width="45"/><col width="45"/><col width="45"/><col width="45"/><col width="45"/><col width="45"/></colgroup><tr class="Table371"><td style="text-align:left;width:0.4021in; " class="Table37_A1"><p class="P48"> </p><p class="P47">1</p></td><td style="text-align:left;width:0.4021in; " class="Table37_A1"><p class="P48"> </p><p class="P47">0</p></td><td style="text-align:left;width:0.4021in; " class="Table37_A1"><p class="P47">1</p><p class="P47">1</p></td><td style="text-align:left;width:0.4028in; " class="Table37_A1"><p class="P48"> </p><p class="P47">0</p></td><td style="text-align:left;width:0.4021in; " class="Table37_A1"><p class="P48"> </p><p class="P47">1</p></td><td style="text-align:left;width:0.4028in; " class="Table37_A1"><p class="P48"> </p></td><td style="text-align:left;width:0.4028in; " class="Table37_A1"><p class="P48"> </p></td></tr><tr class="Table371"><td style="text-align:left;width:0.4021in; " class="Table37_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4021in; " class="Table37_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4021in; " class="Table37_C2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4028in; " class="Table37_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4021in; " class="Table37_E2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table37_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table37_G2"><p class="Subfigure">1</p></td></tr><tr class="Table371"><td style="text-align:left;width:0.4021in; " class="Table37_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4021in; " class="Table37_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4021in; " class="Table37_C2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table37_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4021in; " class="Table37_E2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table37_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table37_G3"><p class="P44"> </p></td></tr><tr class="Table371"><td style="text-align:left;width:0.4021in; " class="Table37_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4021in; " class="Table37_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4021in; " class="Table37_C2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table37_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4021in; " class="Table37_E2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table37_F4"><p class="P44"> </p></td><td style="text-align:left;width:0.4028in; " class="Table37_G4"><p class="P44"> </p></td></tr><tr class="Table371"><td style="text-align:left;width:0.4021in; " class="Table37_A5"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4021in; " class="Table37_B5"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4021in; " class="Table37_C5"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table37_D5"><p class="P44"> </p></td><td style="text-align:left;width:0.4021in; " class="Table37_E5"><p class="P44"> </p></td><td style="text-align:left;width:0.4028in; " class="Table37_F5"><p class="P44"> </p></td><td style="text-align:left;width:0.4028in; " class="Table37_G5"><p class="P44"> </p></td></tr><tr class="Table371"><td style="text-align:left;width:0.4021in; " class="Table37_A6"><p class="P44"> </p></td><td style="text-align:left;width:0.4021in; " class="Table37_B6"><p class="P44"> </p></td><td style="text-align:left;width:0.4021in; " class="Table37_C6"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4028in; " class="Table37_D6"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4021in; " class="Table37_E6"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4028in; " class="Table37_F6"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4028in; " class="Table37_G6"><p class="Subfigure">1</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-7.png" alt="" class="Image">
			
			<p>
				The remainder of the computation is carried out in a similar manner, always being careful to handle the carries properly.  The final result of the computation can be seen in Part (b) of Figure 11.20.
			</p>
			
			<p class="Section">
				Exercises for Section 11.4.1.3
			</p>
			
			<ol>
				<li>
					Add the following pairs of binary numbers. 
				<img src="Images/AssemblyIMGS/ex11-4-1-3-num1.png" alt="" class="Image">
			<!--table of stuff
			<table border="0" cellspacing="0" cellpadding="0" class="Table38">
			<colgroup><col width="105"/><col width="194"/><col width="69"/><col width="194"/></colgroup><tr class="Table381"><td style="text-align:left;width:0.95in; " class="Table38_A1"><p class="P12">a.</p></td><td style="text-align:left;width:1.75in; " class="Table38_A1"><p>1010 + 1010</p></td><td style="text-align:left;width:0.625in; " class="Table38_A1"><p class="P12">d.</p></td><td style="text-align:left;width:1.75in; " class="Table38_A1"><p class="P12">1001 0111 + 1101 0110</p></td></tr><tr class="Table381"><td style="text-align:left;width:0.95in; " class="Table38_A1"><p class="P12">b.</p></td><td style="text-align:left;width:1.75in; " class="Table38_A1"><p>1111 0000 + 0000 1111</p></td><td style="text-align:left;width:0.625in; " class="Table38_A1"><p class="P12">e.</p></td><td style="text-align:left;width:1.75in; " class="Table38_A1"><p>0001 1111 + 1</p></td></tr><tr class="Table381"><td style="text-align:left;width:0.95in; " class="Table38_A1"><p class="P12">c.</p></td><td style="text-align:left;width:1.75in; " class="Table38_A1"><p>10 + 1111</p></td><td style="text-align:left;width:0.625in; " class="Table38_A1"><p class="P12">f.</p></td><td style="text-align:left;width:1.75in; " class="Table38_A1"><p>1011 1011 + 0011 0100</p></td></tr></table>
				-->
				</li>
				<br/>
				<li>
					Multiply the following pairs of binary numbers. 
					<img src="Images/AssemblyIMGS/ex11-4-1-3-num2.png" alt="" class="Image">
			<!--table of stuff		
			<table border="0" cellspacing="0" cellpadding="0" class="Table39">
			<colgroup><col width="105"/><col width="194"/><col width="69"/><col width="194"/></colgroup><tr class="Table391"><td style="text-align:left;width:0.95in; " class="Table39_A1"><p class="P12">a.</p></td><td style="text-align:left;width:1.75in; " class="Table39_A1"><p>1010 &#215;1010</p></td><td style="text-align:left;width:0.625in; " class="Table39_A1"><p class="P12">d.</p></td><td style="text-align:left;width:1.75in; " class="Table39_A1"><p><span class="T3">1001 1100 </span>&#215;<span class="T3"> 0110 0110</span></p></td></tr><tr class="Table391"><td style="text-align:left;width:0.95in; " class="Table39_A1"><p class="P12">b.</p></td><td style="text-align:left;width:1.75in; " class="Table39_A1"><p><span class="T3">10 </span>&#215;<span class="T3"> 11 1111</span></p></td><td style="text-align:left;width:0.625in; " class="Table39_A1"><p class="P12">e.</p></td><td style="text-align:left;width:1.75in; " class="Table39_A1"><p><span class="T3">11 </span>&#215;<span class="T3"> 1001 1011</span></p></td></tr><tr class="Table391"><td style="text-align:left;width:0.95in; " class="Table39_A1"><p class="P12">c.</p></td><td style="text-align:left;width:1.75in; " class="Table39_A1"><p><span class="T3">10011 </span>&#215;<span class="T3"> 11 0111</span></p></td><td style="text-align:left;width:0.625in; " class="Table39_A1"><p class="P12">f.</p></td><td style="text-align:left;width:1.75in; " class="Table39_A1"><p>1001 1011 &#215; 11</p></td></tr></table>
				-->
				</li>
			</ol>
			
			<p class="Section">
				11.4.1.4 Signed numbers 
			</p>
			
			<p>
				So far all of the numbers we have looked at have been unsigned and assumed to be positive.  In order to be able to handle negative numbers, we need a way to represent the sign of a number. We first examine two methods of historical interest and then explore two’s complement, the method in common use today.
			</p>
			
			<p>
				An early attempt to handle signed numbers was to add a special sign bit to the left of each number.  A zero in the sign bit was used for positive numbers and a one in the sign bit for negative numbers. The representations of positive five and negative five in <span class="Ital">signed magnitude</span> notation are shown below.  These representations assume that three bits are reserved for the magnitude of a number and one bit for its sign.
			</p>
			
			<!--ill8
			<table border="0" cellspacing="0" cellpadding="0" class="Table40">
			<colgroup><col width="59"/><col width="55"/><col width="57"/><col width="57"/><col width="42"/><col width="83"/></colgroup><tr class="Table401"><td colspan="4" style="text-align:left;width:0.5347in; " class="Table40_A1"><h2 class="Heading_20_2"><a id="a__Signed_magnitude_binary"></a>Signed magnitude binary</h2></td><td style="text-align:left;width:0.375in; " class="Table40_E1"><p class="P11"> </p></td><td style="text-align:left;width:0.75in; " class="Table40_A1"><p>Decimal</p></td></tr><tr class="Table401"><td style="text-align:left;width:0.5347in; " class="Table40_A2"><p>Sign</p></td><td colspan="3" style="text-align:left;width:0.4993in; " class="Table40_A2"><h2 class="Heading_20_2"><a id="a__Magnitude"></a>Magnitude</h2></td><td style="text-align:left;width:0.375in; " class="Table40_E2"><p class="P11"> </p></td><td style="text-align:left;width:0.75in; " class="Table40_F2"><p class="P11"> </p></td></tr><tr class="Table403"><td style="text-align:left;width:0.5347in; " class="Table40_A3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.4993in; " class="Table40_A3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5174in; " class="Table40_A3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5174in; " class="Table40_A3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table40_E2"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table40_F3"><p>+5</p></td></tr><tr class="Table403"><td style="text-align:left;width:0.5347in; " class="Table40_A3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.4993in; " class="Table40_A3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5174in; " class="Table40_A3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5174in; " class="Table40_A3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table40_E2"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table40_F3"><p>-5</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-8.png" alt="" class="Image">
			
			<p>
				Signed magnitude notation works, provided that the sign bit is treated separately from the magnitude of the number and guides how arithmetic operations are performed.  However, arithmetic in this notation is difficult and results in some anomalies, such as two representations for zero (+0 is 0000 and -0 is 1000).  
			</p>
			
			<p>
				Arithmetic becomes easier if we write a negative number as the complement of the corresponding positive number.  The complement of a binary number is formed by writing a “0” wherever there is a “1” in the original number and a “1” wherever there is a “0” in the original number.  As with signed magnitude notation, the leftmost bit still indicates the sign of the number – “0” for positive numbers and “1” for negative.  Complementing a binary number in this way to represent signed values is sometimes referred to as <span class="Ital">one’s complement</span> notation.  The one’s complement representation of positive five and negative five are presented below. 
			</p>
			
			<!--ill9
			<table border="0" cellspacing="0" cellpadding="0" class="Table41">
			<colgroup><col width="57"/><col width="57"/><col width="57"/><col width="57"/><col width="42"/><col width="83"/></colgroup><tr class="Table411"><td colspan="4" style="text-align:left;width:0.516in; " class="Table41_A1"><h2 class="Heading_20_2"><a id="a__One’s_complement_binary"></a>One’s complement binary</h2></td><td style="text-align:left;width:0.375in; " class="Table41_E1"><p class="P11"> </p></td><td style="text-align:left;width:0.75in; " class="Table41_A1"><p>Decimal</p></td></tr><tr class="Table412"><td style="text-align:left;width:0.516in; " class="Table41_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5167in; " class="Table41_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.516in; " class="Table41_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5167in; " class="Table41_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table41_E2"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table41_F2"><p>+5</p></td></tr><tr class="Table412"><td style="text-align:left;width:0.516in; " class="Table41_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5167in; " class="Table41_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.516in; " class="Table41_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5167in; " class="Table41_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.375in; " class="Table41_E3"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table41_F2"><p>-5</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-9.png" alt="" class="Image">
			
			<p>
				Although the arithmetic for one’s complement numbers is much easier than for signed magnitude, the anomaly of two representations for zero (0000 for +0 and 1111 for -0) still exists.
			</p>
			
			<p>
				Two’s complement is a variation of one’s complement.  To change the sign of a<span class="Ital"> two’s complement</span> binary number, perform the following three steps:
			</p>
			
			<ol>
				<li>
					Write down the binary representation for the original number
				</li>
				
				<li>
					Complement all the bits (replace 1’s with 0’s and 0’s with 1’s)
				</li>
				
				<li>
					Add one to the result.
				</li>
			</ol>
			
			<p>
				Here are positive five and negative five written in two’s complement notation.
			</p>
			
			<!--ill10
			<table border="0" cellspacing="0" cellpadding="0" class="Table42">
			<colgroup><col width="56"/><col width="56"/><col width="56"/><col width="56"/><col width="42"/><col width="83"/></colgroup><tr class="Table421"><td colspan="4" style="text-align:left;width:0.5083in; " class="Table42_A1"><h2 class="Heading_20_2"><a id="a__Two’s_complement_binary"></a>Two’s complement binary</h2></td><td style="text-align:left;width:0.375in; " class="Table42_E1"><p class="P11"> </p></td><td style="text-align:left;width:0.75in; " class="Table42_A1"><p>Decimal</p></td></tr><tr class="Table422"><td style="text-align:left;width:0.5083in; " class="Table42_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5083in; " class="Table42_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5083in; " class="Table42_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.509in; " class="Table42_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table42_E2"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table42_F2"><p>+5</p></td></tr><tr class="Table422"><td style="text-align:left;width:0.5083in; " class="Table42_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5083in; " class="Table42_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5083in; " class="Table42_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.509in; " class="Table42_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table42_E3"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table42_F2"><p>-5</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-10.png" alt="" class="Image">
			
			<p>
				While the idea of two’s complement notation may seem a little strange at first, it has does have a unique representation for zero (0000, given four bits) and straightforward arithmetic operations.  Notice that for positive numbers, all three representations (signed magnitude, one’s complement, and two’s complement) have the same pattern as unsigned numbers.  
			</p>
			
			<p>
				Figure 11.21 presents the sixteen signed numbers that can be represented using two’s complement notation and four bits of storage.  Notice that the numbers range from negative eight to positive seven.  In two’s complement notation the range of numbers that can be represented given a fixed number of bits will always include one more negative value than positive value.  This is because the representation of zero includes a “0” in the leftmost bit position – thus taking up one of the “positive” slots. 
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-21.png" alt="" class="Image">

			<p class="Figure">
				Figure 11.21:  Four-bit, two’s complement signed numbers
			</p>
			
			<p>
				For <span class="Ital">n</span> bits of storage the range of numbers that can be represented in two’s complement notation extends from negative 2 <span class="Superscript">n -1</span> to positive 2 <span class="Superscript">n - 1</span> –1.  In figure 11.21 four bits of storage were used, so the range of numbers was from negative 2 <span class="Superscript">4-1</span> ( i.e., - 2 <span class="Superscript">3</span> =  -8 ) to positive 2 <span class="Superscript">4-1 </span>- 1 ( i.e.,  2 <span class="Superscript">3</span>- 1  = 8 –1 = 7 ).  Most modern PCs use a “word” size of thirty-two bits to represent integers.  Thus, they are capable of representing values in the range negative 2 <span class="Superscript">31</span> to positive 2 <span class="Superscript">31</span>-1, or -2,147,483,648 to 2,147,483,647.  Older computers used sixteen-bit words and were thus limited to representing integers in the range negative 2 <span class="Superscript">15</span> to positive 2<span class="Superscript"> 15</span> – 1, or -32,768 to 32,767.
			</p>
			
			<p>
				In order to understand why two’s complement is the preferred method for representing signed numbers at the machine level, we will look at a number of addition problems involving both positive and negative numbers.  As we will see, what makes two’s complement so great is that the sign of a number can essentially be ignored when performing addition since positive and negative numbers are treated in an identical manner.  An added bonus is that we get the subtraction operations for “free” once we have addition, since a problem such as X – Y can be recast as the two step process: (1) swap the sign of Y, then (2) add X and Y.
			</p>
			
			<p>
				We begin by examining the summation of numbers with opposite signs. First up is the sum of +2 and –3, which should add to –1.  The two’s complement binary representation of +2 is 0010, assuming four bits of storage.  The two’s complement representation of –3, also assuming four bits of storage, is 1101. (Remember, start with +3 in base two, 0011, complement the bits to get 1100, then add 1 to get 1101.)  Adding these two values together gives 1111, or -1. (The “1” in the leftmost column tells us the number is negative.  It’s magnitude can be determined by complementing each bit (giving 0000) and adding one (giving 0001). The addition of +2 and –3 is illustrated below.
			</p>
			
			<!--ill11
			<table border="0" cellspacing="0" cellpadding="0" class="Table44">
			<colgroup><col width="56"/><col width="56"/><col width="56"/><col width="56"/><col width="42"/><col width="83"/></colgroup><tr class="Table441"><td colspan="4" style="text-align:left;width:0.5083in; " class="Table44_A1"><h2 class="Heading_20_2"><a id="a__Two’s_complement_binary"></a>Two’s complement binary</h2></td><td style="text-align:left;width:0.375in; " class="Table44_E1"><p class="P11"> </p></td><td style="text-align:left;width:0.75in; " class="Table44_E1"><p>Decimal</p></td></tr><tr class="Table442"><td style="text-align:left;width:0.5083in; " class="Table44_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5083in; " class="Table44_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5083in; " class="Table44_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.509in; " class="Table44_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.375in; " class="Table44_E2"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table44_F2"><p>+2</p></td></tr><tr class="Table442"><td style="text-align:left;width:0.5083in; " class="Table44_A3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5083in; " class="Table44_A3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5083in; " class="Table44_A3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.509in; " class="Table44_A3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table44_E3"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table44_F3"><p>-3</p></td></tr><tr class="Table442"><td style="text-align:left;width:0.5083in; " class="Table44_A4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5083in; " class="Table44_A4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5083in; " class="Table44_A4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.509in; " class="Table44_A4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table44_E4"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table44_F4"><p>-1</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-11.png" alt="" class="Image">
			
			<p>
				Next, we look at the addition of –2 and +3.  The four-bit two’s complement binary representation of –2 is 1110.  The representation of +3 is 0011.  Adding these two values together gives +1 or 0001 in binary two’s complement, as is illustrated below.
			</p>
			
			<!--ill12
			<table border="0" cellspacing="0" cellpadding="0" class="Table45">
			<colgroup><col width="57"/><col width="57"/><col width="57"/><col width="57"/><col width="57"/><col width="42"/><col width="83"/></colgroup><tr class="Table451"><td style="text-align:left;width:0.5146in; " class="Table45_A1"/><td colspan="4" style="text-align:left;width:0.5153in; " class="Table45_B1"><h2 class="Heading_20_2"><a id="a__Two’s_complement_binary"></a>Two’s complement binary</h2></td><td style="text-align:left;width:0.375in; " class="Table45_A1"/><td style="text-align:left;width:0.75in; " class="Table45_A1"><p>Decimal</p></td></tr><tr class="Table452"><td style="text-align:left;width:0.5146in; " class="Table45_A2"><p class="P44"> </p></td><td style="text-align:left;width:0.5153in; " class="Table45_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5146in; " class="Table45_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5153in; " class="Table45_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5174in; " class="Table45_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.375in; " class="Table45_F2"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table45_G2"><p>-2</p></td></tr><tr class="Table452"><td style="text-align:left;width:0.5146in; " class="Table45_A2"><p class="P44"> </p></td><td style="text-align:left;width:0.5153in; " class="Table45_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5146in; " class="Table45_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5153in; " class="Table45_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5174in; " class="Table45_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table45_F3"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table45_G3"><p>+3</p></td></tr><tr class="Table452"><td style="text-align:left;width:0.5146in; " class="Table45_A4"><p class="P45">1</p></td><td style="text-align:left;width:0.5153in; " class="Table45_B4"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5146in; " class="Table45_B4"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5153in; " class="Table45_B4"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5174in; " class="Table45_B4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table45_F4"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table45_G4"><p>+1</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-12.png" alt="" class="Image">
			
			<p>
				Note that this particular addition of two four-bit numbers results in a carry to the fifth bit.  This carry is <span class="Ital">ignored</span>.  In order to reinforce the fact that this bit is discarded, it is shown in italics.
			</p>
			
			<p>
				We now turn our attention to addition problems involving numbers of like sign.  Here is an illustration of the addition of two positive numbers: +2 and +3.
			</p>
			
			<!--ill13
			<table border="0" cellspacing="0" cellpadding="0" class="Table46">
			<colgroup><col width="56"/><col width="56"/><col width="56"/><col width="56"/><col width="42"/><col width="83"/></colgroup><tr class="Table461"><td colspan="4" style="text-align:left;width:0.5083in; " class="Table46_A1"><h2 class="Heading_20_2"><a id="a__Two’s_complement_binary"></a>Two’s complement binary</h2></td><td style="text-align:left;width:0.375in; " class="Table46_E1"><p class="P11"> </p></td><td style="text-align:left;width:0.75in; " class="Table46_E1"><p>Decimal</p></td></tr><tr class="Table462"><td style="text-align:left;width:0.5083in; " class="Table46_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5083in; " class="Table46_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5083in; " class="Table46_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.509in; " class="Table46_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.375in; " class="Table46_E2"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table46_F2"><p>+2</p></td></tr><tr class="Table462"><td style="text-align:left;width:0.5083in; " class="Table46_A3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5083in; " class="Table46_A3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5083in; " class="Table46_A3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.509in; " class="Table46_A3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table46_E3"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table46_F3"><p>+3</p></td></tr><tr class="Table462"><td style="text-align:left;width:0.5083in; " class="Table46_A4"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5083in; " class="Table46_A4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5083in; " class="Table46_A4"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.509in; " class="Table46_A4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table46_E4"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table46_F4"><p>+5</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-13.png" alt="" class="Image">
			
			<p>
				To show that the system handles the addition of negative numbers properly, consider the problem: –2 plus –3 equals –5.
			</p>
			
			<!--ill14
			<table border="0" cellspacing="0" cellpadding="0" class="Table47">
			<colgroup><col width="57"/><col width="57"/><col width="57"/><col width="57"/><col width="57"/><col width="42"/><col width="83"/></colgroup><tr class="Table471"><td style="text-align:left;width:0.5146in; " class="Table47_A1"/><td colspan="4" style="text-align:left;width:0.5153in; " class="Table47_B1"><h2 class="Heading_20_2"><a id="a__Two’s_complement_binary"></a>Two’s complement binary</h2></td><td style="text-align:left;width:0.375in; " class="Table47_A1"/><td style="text-align:left;width:0.75in; " class="Table47_A1"><p>Decimal</p></td></tr><tr class="Table472"><td style="text-align:left;width:0.5146in; " class="Table47_A2"><p class="P44"> </p></td><td style="text-align:left;width:0.5153in; " class="Table47_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5146in; " class="Table47_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5153in; " class="Table47_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5174in; " class="Table47_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.375in; " class="Table47_F2"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table47_G2"><p>-2</p></td></tr><tr class="Table472"><td style="text-align:left;width:0.5146in; " class="Table47_A2"><p class="P44"> </p></td><td style="text-align:left;width:0.5153in; " class="Table47_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5146in; " class="Table47_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5153in; " class="Table47_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5174in; " class="Table47_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table47_F3"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table47_G3"><p>-3</p></td></tr><tr class="Table472"><td style="text-align:left;width:0.5146in; " class="Table47_A4"><p class="P45">1</p></td><td style="text-align:left;width:0.5153in; " class="Table47_B4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5146in; " class="Table47_B4"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5153in; " class="Table47_B4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5174in; " class="Table47_B4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table47_F4"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table47_G4"><p>-5</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-14.png" alt="" class="Image">
			
			<p>
				Notice that while we get a correct answer, this problem generated a carry bit that is discarded.
			</p>
			
			<p>
				One problem that can arise when representing numeric values via a fixed number of bits is the problem of overflow.  <span class="Ital">Overflow</span> occurs when the value that is to be stored is outside the range of permissible values (in other words the value is too large to fit in the available space). The only way around overflow is to add more bits to the representation, thus increasing the range of permissible values.   The best we can do absent this is to detect when overflow occurs. 
			</p>
			
			<p>
				Two’s complement notation makes it easy to spot when overflow occurs. Overflow occurs when two numbers of the same sign are added together and the result has the opposite sign.  Here are two examples.
			</p>
			
			<!--ill15
			<table border="0" cellspacing="0" cellpadding="0" class="Table48">
			<colgroup><col width="57"/><col width="57"/><col width="57"/><col width="57"/><col width="57"/><col width="42"/><col width="83"/></colgroup><tr class="Table481"><td style="text-align:left;width:0.5146in; " class="Table48_A1"/><td colspan="4" style="text-align:left;width:0.5153in; " class="Table48_B1"><h2 class="Heading_20_2"><a id="a__Two’s_complement_binary"></a>Two’s complement binary</h2></td><td style="text-align:left;width:0.375in; " class="Table48_A1"/><td style="text-align:left;width:0.75in; " class="Table48_A1"><p>Decimal</p></td></tr><tr class="Table482"><td style="text-align:left;width:0.5146in; " class="Table48_A2"><p class="P44"> </p></td><td style="text-align:left;width:0.5153in; " class="Table48_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5146in; " class="Table48_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5153in; " class="Table48_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5174in; " class="Table48_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.375in; " class="Table48_F2"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table48_G2"><p>+4</p></td></tr><tr class="Table482"><td style="text-align:left;width:0.5146in; " class="Table48_A2"><p class="P44"> </p></td><td style="text-align:left;width:0.5153in; " class="Table48_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5146in; " class="Table48_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5153in; " class="Table48_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5174in; " class="Table48_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table48_F3"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table48_G3"><p>+5</p></td></tr><tr class="Table482"><td style="text-align:left;width:0.5146in; " class="Table48_A2"><p class="P46"> </p></td><td style="text-align:left;width:0.5153in; " class="Table48_B4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5146in; " class="Table48_B4"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5153in; " class="Table48_B4"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5174in; " class="Table48_B4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table48_F4"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table48_G4"><p>? –7 ?</p></td></tr></table>
			
			<table border="0" cellspacing="0" cellpadding="0" class="Table49">
			<colgroup><col width="57"/><col width="57"/><col width="57"/><col width="57"/><col width="57"/><col width="42"/><col width="83"/></colgroup><tr class="Table491"><td style="text-align:left;width:0.5146in; " class="Table49_A1"/><td colspan="4" style="text-align:left;width:0.5153in; " class="Table49_B1"><h2 class="Heading_20_2"><a id="a__Two’s_complement_binary"></a>Two’s complement binary</h2></td><td style="text-align:left;width:0.375in; " class="Table49_A1"/><td style="text-align:left;width:0.75in; " class="Table49_A1"><p>Decimal</p></td></tr><tr class="Table492"><td style="text-align:left;width:0.5146in; " class="Table49_A2"><p class="P44"> </p></td><td style="text-align:left;width:0.5153in; " class="Table49_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5146in; " class="Table49_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5153in; " class="Table49_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5174in; " class="Table49_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.375in; " class="Table49_F2"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table49_G2"><p>-4</p></td></tr><tr class="Table492"><td style="text-align:left;width:0.5146in; " class="Table49_A2"><p class="P44"> </p></td><td style="text-align:left;width:0.5153in; " class="Table49_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5146in; " class="Table49_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5153in; " class="Table49_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5174in; " class="Table49_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table49_F3"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table49_G3"><p>-5</p></td></tr><tr class="Table492"><td style="text-align:left;width:0.5146in; " class="Table49_A4"><p class="P45">1</p></td><td style="text-align:left;width:0.5153in; " class="Table49_B4"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.5146in; " class="Table49_B4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5153in; " class="Table49_B4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.5174in; " class="Table49_B4"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.375in; " class="Table49_F4"><p class="P19"> </p></td><td style="text-align:left;width:0.75in; " class="Table49_G4"><p>? +7 ?</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-15.png" alt="" class="Image">
			
			<p>
				Overflow in two’s complement can be spotted when the sign bits of both numbers being added are the same, yet the sign bit of the answer is different.  Note that overflow can only occur when adding numbers of like sign.  It can never occur when numbers of opposite signs are added. 
			</p>
			
			<p>
				When we detect overflow the answer is incorrect, as shown above by the question marks, and must be discarded.  There is no way to get the correct answer if the number of bits available does not allow us to express that answer.  There is no way to express +9 or -9, the correct results, using a four-bit two’s complement number, since both are outside the range of permissible values. 
			</p>
			
			<p class="Section">
				Exercises for Section 11.4.1.4
			</p>
			
			<ol>
				<li>
					Add each of the following pairs of 8-bit two’s complement numbers.  Indicate which problems, if any, generate an overflow condition. 
					
					<img src="Images/AssemblyIMGS/ex11-4-1-4-num1.png" alt="" class="Image">
			<!--table of stuff
			<table border="0" cellspacing="0" cellpadding="0" class="Table50">
			<colgroup><col width="40"/><col width="115"/><col width="93"/><col width="104"/></colgroup><tr class="Table501"><td style="text-align:left;width:0.3625in; " class="Table50_A1"><p>a.  </p></td><td style="text-align:left;width:1.0375in; " class="Table50_A1"><p>1010 1010</p></td><td style="text-align:left;width:0.8375in; " class="Table50_A1"><p class="P12">d.  </p></td><td style="text-align:left;width:0.9375in; " class="Table50_A1"><p>0011 0000</p></td></tr><tr class="Table501"><td style="text-align:left;width:0.3625in; " class="Table50_A1"><p class="P19"> </p></td><td style="text-align:left;width:1.0375in; " class="Table50_B2"><p>0000 0010</p></td><td style="text-align:left;width:0.8375in; " class="Table50_A1"><p class="P13"> </p></td><td style="text-align:left;width:0.9375in; " class="Table50_B2"><p>0100 0000</p></td></tr><tr class="Table501"><td style="text-align:left;width:0.3625in; " class="Table50_A1"><p class="P19"> </p></td><td style="text-align:left;width:1.0375in; " class="Table50_B3"><p class="P19"> </p></td><td style="text-align:left;width:0.8375in; " class="Table50_A1"><p class="P13"> </p></td><td style="text-align:left;width:0.9375in; " class="Table50_B3"><p class="P19"> </p></td></tr><tr class="Table501"><td style="text-align:left;width:0.3625in; " class="Table50_A1"><p>b.  </p></td><td style="text-align:left;width:1.0375in; " class="Table50_A1"><p>1111 0000</p></td><td style="text-align:left;width:0.8375in; " class="Table50_A1"><p class="P12">e.  </p></td><td style="text-align:left;width:0.9375in; " class="Table50_A1"><p>0011 0000</p></td></tr><tr class="Table501"><td style="text-align:left;width:0.3625in; " class="Table50_A1"><p class="P19"> </p></td><td style="text-align:left;width:1.0375in; " class="Table50_B2"><p>1111 1100</p></td><td style="text-align:left;width:0.8375in; " class="Table50_A1"><p class="P13"> </p></td><td style="text-align:left;width:0.9375in; " class="Table50_B2"><p>0101 0000</p></td></tr><tr class="Table501"><td style="text-align:left;width:0.3625in; " class="Table50_A1"><p class="P19"> </p></td><td style="text-align:left;width:1.0375in; " class="Table50_B3"><p class="P19"> </p></td><td style="text-align:left;width:0.8375in; " class="Table50_A1"><p class="P13"> </p></td><td style="text-align:left;width:0.9375in; " class="Table50_B3"><p class="P19"> </p></td></tr><tr class="Table501"><td style="text-align:left;width:0.3625in; " class="Table50_A1"><p>c.  </p></td><td style="text-align:left;width:1.0375in; " class="Table50_A1"><p>1000 1111</p></td><td style="text-align:left;width:0.8375in; " class="Table50_A1"><p class="P12">f.  </p></td><td style="text-align:left;width:0.9375in; " class="Table50_A1"><p>1000 1111</p></td></tr><tr class="Table501"><td style="text-align:left;width:0.3625in; " class="Table50_A1"><p class="P19"> </p></td><td style="text-align:left;width:1.0375in; " class="Table50_B2"><p>1000 1111</p></td><td style="text-align:left;width:0.8375in; " class="Table50_A1"><p class="P13"> </p></td><td style="text-align:left;width:0.9375in; " class="Table50_B2"><p>0001 0000</p></td></tr></table>
				-->
				</li>
				<br/>
				<li>
					Translate each of the above addition problems, along with its answer, from base two to base ten. 
				</li>
			</ol>
			
			<p class="Section">
				11.4.1.5  Floating point numbers
			</p>
			
			<p>
				Most modern personal computers are based on a word size of thirty-two bits.  Using two’s complement notation, they can conveniently manipulate numbers in the range of –2 billion to +2 billion.<span class="Footnote" title="Footnote: Well, as pointed out earlier, actually -2,147,483,648 to 2,147,483,647"><a href="#ftn5" id="body_ftn5">[5]</a></span>  Many times we humans need our computers to work with numbers far outside of this relatively narrow range.  For example, scientific applications often need to represent very large or very small quantities, such as Avogadro’s number, 6.02 x 10 <span class="Superscript">23  </span> molecules/mole.  Even a program designed to make projections about the national debt of the United States, which is measured in trillions of dollars, will be forced to work with numbers outside of the range provided by the 32-bit two’s complement representation.
			</p>
			
			<p>
				In addition to the problem of being limited to a relatively narrow range of values, the two’s complement binary notation we studied cannot represent fractions – making it impossible to express concepts like ½ and 75%.
			</p>
			
			<p>
				Floating point notation, which is closely related to exponential notation, addresses both of these problems.  As you will recall from high school math or science classes, exponential notation is often used to express very large or very small numbers.  For example, the speed of light can be expressed as:  3.0 &#215; 10 <span class="Superscript">8</span> meters/second.
			</p>
			
			<p>
				The two components necessary to express a number in exponential notation are called the mantissa (3.0 in the above number) and the exponent (8 in the above number).  These values are expressed in base ten, so the exponent is expressed in terms of base ten as well.  Essentially the exponent tells us the number of positions that the decimal point should be moved to the right or left.  Positive exponents cause the decimal point to move right.  Negative exponents cause the decimal point to move left.  Hence, the representation for the speed of light translates to a “3” followed by eight 0’s – three hundred million meters per second.  Fractions can also be expressed in this system.  For example:
			</p>
			
			<p class="Subfigure">
				1/1,000  =  1.0 &#215; 10 <span class="Superscript">–3   </span>=  0.001
			</p>
			
			<p>
				Floating point notation is the “machine-level” equivalent of exponential notation. Floating point numbers include signed representations of both the mantissa and exponent.  Since the representations of both will be in base two, two will also be considered the base of the exponent.  
			</p>
			
			<p>
				Here is the number fifty-six expressed using one possible 32-bit floating point representation:
			</p>
			
			<!--ill16
			<table border="0" cellspacing="0" cellpadding="0" class="Table51">
			<colgroup><col width="24"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="24"/></colgroup><tr class="Table511"><td style="text-align:left;width:0.2132in; " class="Table51_A1"><p>+-</p></td><td colspan="7" style="text-align:left;width:0.1903in; " class="Table51_A1"><h2 class="Heading_20_2"><a id="a__Exponent"></a>Exponent</h2></td><td colspan="24" style="text-align:left;width:0.1896in; " class="Table51_I1"><h2 class="Heading_20_2"><a id="a__Mantissa"></a>Mantissa</h2></td></tr><tr class="Table512"><td style="text-align:left;width:0.2132in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2153in; " class="Table51_f2"><p class="Subfigure">1</p></td></tr><tr class="Table512"><td style="text-align:left;width:0.2132in; " class="Table51_A1"><p class="P53">32</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">31</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">30</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">29</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">28</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">27</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">26</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">25</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">24</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">23</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">22</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">21</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">20</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">19</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">18</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">17</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">16</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">15</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">14</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">13</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">12</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">11</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">10</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">9</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">8</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">7</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">6</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">5</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">4</p></td><td style="text-align:left;width:0.1903in; " class="Table51_A1"><p class="P53">3</p></td><td style="text-align:left;width:0.1896in; " class="Table51_A1"><p class="P53">2</p></td><td style="text-align:left;width:0.2153in; " class="Table51_I1"><p class="P53">1</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-16.png" alt="" class="Image">
			
			<p>
				The leading bit (bit 32) of this representation signifies the sign of the number (0 for positive, 1 for negative).  The next seven bits (bits 31 – 25) represent the exponent in two’s complement notation (remember the exponent can be positive or negative).  The final twenty-four bits are the mantissa expressed as an unsigned number.  The number represented in this example is 111  &#215;  two <span class="T19">11</span> which in decimal notation becomes 7  &#215;  2 <span class="T19">3  </span>= 7 &#215; 8  =  56.  
			</p>
			
			<p>
				Another way of thinking about this example is to view the exponent as specifying the number of 0’s that are to follow the bit pattern supplied by the mantissa.  In this case, we have “111” followed by three 0’s or “111000” which is 32 + 16 + 8 = 56.
			</p>
			
			<p>
				Here is an example of a number that is outside the range of values that can be stored using a 32-bit two’s complement notation.  The number is 11 &#215; two <span class="Superscript">100000 </span>  which in decimal notation is 3 &#215;  2 <span class="Superscript">32</span> = 12,884,901,888.
			</p>
			
			<!--ill17
			<table border="0" cellspacing="0" cellpadding="0" class="Table52">
			<colgroup><col width="24"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="24"/></colgroup><tr class="Table521"><td style="text-align:left;width:0.2132in; " class="Table52_A1"><p>+-</p></td><td colspan="7" style="text-align:left;width:0.1903in; " class="Table52_A1"><h2 class="Heading_20_2"><a id="a__Exponent"></a>Exponent</h2></td><td colspan="24" style="text-align:left;width:0.1896in; " class="Table52_I1"><h2 class="Heading_20_2"><a id="a__Mantissa"></a>Mantissa</h2></td></tr><tr class="Table522"><td style="text-align:left;width:0.2132in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table52_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table52_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2153in; " class="Table52_f2"><p class="Subfigure">1</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-17.png" alt="" class="Image">
			
			<p>
				Another way of thinking about the number represented by this bit pattern is as “11” followed by thirty-two 0’s.  
			</p>
			
			<p>
				As a final example, consider the representation of - 0.75 as a floating point number.
			</p>
			
			<!--ill18
			<table border="0" cellspacing="0" cellpadding="0" class="Table53">
			<colgroup><col width="24"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="21"/><col width="24"/></colgroup><tr class="Table531"><td style="text-align:left;width:0.216in; " class="Table53_A1"><p>+-</p></td><td colspan="7" style="text-align:left;width:0.1903in; " class="Table53_A1"><h2 class="Heading_20_2"><a id="a__Exponent"></a>Exponent</h2></td><td colspan="24" style="text-align:left;width:0.1896in; " class="Table53_I1"><h2 class="Heading_20_2"><a id="a__Mantissa"></a>Mantissa</h2></td></tr><tr class="Table532"><td style="text-align:left;width:0.216in; " class="Table53_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1903in; " class="Table53_A2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.1896in; " class="Table53_A2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2153in; " class="Table53_f2"><p class="Subfigure">1</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-18.png" alt="" class="Image">
			
			<p>
				The “1” in the leftmost bit signifies that the number is negative.  The exponent 1111110 is also negative due the “1” in its leftmost bit.  The magnitude of the exponent is two (Complement the bits to get 0000001 and add one, giving 0000010  =  two).  The magnitude of the mantissa is 11 = three.  So, the value is -3 &#215;  2 <span class="Superscript">-2  </span>= -3 &#215; 0.25 = -0.75.
			</p>
			
			<p>
				Another way of thinking about the number in this example is to view it as “<span class="Subfigure">&#x25B4;</span>11” where the symbol “<span class="Subfigure">&#x25B4;</span>” specifies the “binary point” (the binary equivalent of the decimal point).  The columns to the right of the binary point are ½’s column, the ¼’s column, the 1/8’s column, 1/16’s column, and so forth.  The number “<span class="Subfigure">&#x25B4;</span>11” would then be interpreted as having a “1” in the ½’s place plus a “1” in the ¼’s place, giving ¾ or 0.75.  Under this interpretation, the mantissa always has an implied binary point immediately to its right.  The exponent specifies the number of positions to the right (for positive exponents) or to the left (for negative exponents) the point should be moved.  Hence, in this case the exponent moves the binary point two places to the left giving “<span class="Subfigure">&#x25B4;</span>11”.  The binary number is then interpreted in the following way:
			</p>
			
			<!--ill19
			<table border="0" cellspacing="0" cellpadding="0" class="Table54">
			<colgroup><col width="76"/><col width="76"/><col width="76"/><col width="76"/><col width="24"/><col width="86"/><col width="86"/></colgroup><tr class="Table541"><td style="text-align:left;width:0.6833in; " class="Table54_A1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.6833in; " class="Table54_A1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.6833in; " class="Table54_A1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.6833in; " class="Table54_A1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2167in; " class="Table54_E1"><p class="P44"> </p></td><td style="text-align:left;width:0.7708in; " class="Table54_A1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.7778in; " class="Table54_G1"><p class="Subfigure">1</p></td></tr><tr class="Table541"><td style="text-align:left;width:0.6833in; " class="Table54_A2"><p>8</p></td><td style="text-align:left;width:0.6833in; " class="Table54_B2"><p>4</p></td><td style="text-align:left;width:0.6833in; " class="Table54_C2"><p>2</p></td><td style="text-align:left;width:0.6833in; " class="Table54_D2"><p>1</p></td><td style="text-align:left;width:0.2167in; " class="Table54_E2"><div class="P62"></div></td><td style="text-align:left;width:0.7708in; " class="Table54_F2"><p>1/2</p></td><td style="text-align:left;width:0.7778in; " class="Table54_G2"><p>1/4</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-19.png" alt="" class="Image">
			
			<p>
				It is interesting to note that some fractions that can be expressed precisely in decimal notation, such as 1/10 = 0.1, do not have an exact floating point representation.  This is due to the fact that floating point numbers are represented using base two.  One-tenth can be approximated by the fraction “<span class="Subfigure">&#x25B4;</span>0001 1001 1001 1001…” in base two (where “1001” repeats indefinitely), but it can never be represented exactly.  This result should not be surprising. After all, many factions, such as 1/3, cannot be represented exactly as decimal values.  This is one reason why computed results that involve fractions are not always 100% accurate.  They sometimes suffer from round off error as a result of the base ten to base two conversion process.
			</p>
			
			<p class="Section">
				Exercises for Section 11.4.1.5
			</p>
			
			<ol>
				<li>
					Translate the following 32-bit floating point numbers to decimal notation
					<br/>
					<br/>
					<ul class="Blockcenter">
						<li><span class="Subfigure">a. &nbsp; 0111 1101 0000 0000 0000 0000 0100 0011</span></li>
						<li><span class="Subfigure">b. &nbsp; 0000 0011 0000 0000 0000 0000 0100 0011</span></li>
					</ul>
				</li>
				<br/>
				<li>
					Translate the following decimal numbers to 32-bit floating point representation.  If a value cannot be represented exactly, approximate it as closely as possible. 
					<img src="Images/AssemblyIMGS/ex11-4-1-5-num2.png" alt="" class="Image">
					
			<!--table of stuff		
			<table border="0" cellspacing="0" cellpadding="0" class="Table56">
			<colgroup><col width="72"/><col width="65"/><col width="160"/><col width="83"/></colgroup><tr class="Table561"><td style="text-align:left;width:0.6486in; " class="Table56_A1"><p class="P13"> </p><p class="P12">a.  </p></td><td style="text-align:left;width:0.5861in; " class="Table56_A1"><p class="P13"> </p><p class="P12">2.25</p></td><td style="text-align:left;width:1.4375in; " class="Table56_A1"><p class="P13"> </p><p class="P12">d.  </p></td><td style="text-align:left;width:0.75in; " class="Table56_A1"><p class="P13"> </p><p class="P12">-10</p></td></tr><tr class="Table561"><td style="text-align:left;width:0.6486in; " class="Table56_A1"><p class="P13"> </p><p class="P12">b.  </p></td><td style="text-align:left;width:0.5861in; " class="Table56_A1"><p class="P13"> </p><p class="P12">-2.25</p></td><td style="text-align:left;width:1.4375in; " class="Table56_A1"><p class="P13"> </p><p class="P12">e.  </p></td><td style="text-align:left;width:0.75in; " class="Table56_A1"><p class="P13"> </p><p class="P12">150.1</p></td></tr><tr class="Table561"><td style="text-align:left;width:0.6486in; " class="Table56_A1"><p class="P13"> </p><p class="P12">c.  </p></td><td style="text-align:left;width:0.5861in; " class="Table56_A1"><p class="P13"> </p><p class="P12">10</p></td><td style="text-align:left;width:1.4375in; " class="Table56_A1"><p class="P13"> </p><p class="P12">f.  </p></td><td style="text-align:left;width:0.75in; " class="Table56_A1"><p class="P13"> </p><p class="P12">75.5</p></td></tr></table>
			-->
				</li>
			</ol>
			
			<p class="Section">
				11.4.2  Characters
			</p>
			
			<p>
				We now turn our attention to representing characters at the machine level.  One of the most popular methods of representing character data in a computer is to use the ASCII character set.  The basic idea behind ASCII (the American Standard Code for Information Interchange), and all other character sets, is to associate particular bit patterns with individual characters.
			</p>
			
			<p>
				There are 128 symbols in the ASCII character set.  These are numbered from 0 to 127      ( 7F<span class="Subscript">sixteen</span>  or  0111 1111<span class="Subscript">two</span> ).  ASCII characters are grouped together in the following way:
			</p>
			
			<!--ill20
			<table border="0" cellspacing="0" cellpadding="0" class="Table57">
			<colgroup><col width="289"/><col width="90"/><col width="118"/><col width="167"/></colgroup><tr class="Table571"><td rowspan="2" style="text-align:left;width:2.6in; " class="Table57_A1"><p class="P54"> </p><h2 class="Heading_20_2"><a id="a__Character_Group"></a>Character Group</h2></td><td colspan="3" style="text-align:left;width:0.8125in; " class="Table57_B1"><p>Range</p></td></tr><tr class="Table571"><td style="text-align:left;width:0.8125in; " class="Table57_B2"><p>Decimal</p></td><td style="text-align:left;width:1.0625in; " class="Table57_B2"><p>Hexadecimal</p></td><td style="text-align:left;width:1.5069in; " class="Table57_D2"><p>Binary</p></td></tr><tr class="Table573"><td style="text-align:left;width:2.6in; " class="Table57_A1"><p>Control characters</p></td><td style="text-align:left;width:0.8125in; " class="Table57_B3"><p>0 - 31</p></td><td style="text-align:left;width:1.0625in; " class="Table57_B3"><p class="P132">00 – 1F</p></td><td style="text-align:left;width:1.5069in; " class="Table57_B1"><p class="P126">0000 0000 – 0001 1111</p></td></tr><tr class="Table573"><td style="text-align:left;width:2.6in; " class="Table57_A4"><h1 class="Heading_20_1"><a id="a__Punctuation"></a>Punctuation</h1></td><td style="text-align:left;width:0.8125in; " class="Table57_B4"><p>32 - 47</p></td><td style="text-align:left;width:1.0625in; " class="Table57_B4"><p>20 – 2F</p></td><td style="text-align:left;width:1.5069in; " class="Table57_D4"><p class="P126">0010 0000 – 0010 1111</p></td></tr><tr class="Table573"><td style="text-align:left;width:2.6in; " class="Table57_A4"><p>Digits:  0  1  2  3  4  5  6  7  8  9</p></td><td style="text-align:left;width:0.8125in; " class="Table57_B4"><p>48 - 57</p></td><td style="text-align:left;width:1.0625in; " class="Table57_B4"><p>30 – 39</p></td><td style="text-align:left;width:1.5069in; " class="Table57_D4"><p class="Figure">0011 0000 – 0011 1001</p></td></tr><tr class="Table573"><td style="text-align:left;width:2.6in; " class="Table57_A4"><p>Punctuation:  :   ;   &lt;   =   &gt;   ?</p></td><td style="text-align:left;width:0.8125in; " class="Table57_B4"><p>58 - 64</p></td><td style="text-align:left;width:1.0625in; " class="Table57_B4"><p>3A – 40</p></td><td style="text-align:left;width:1.5069in; " class="Table57_D4"><p class="Figure">0011 1010 – 0100 0000</p></td></tr><tr class="Table573"><td style="text-align:left;width:2.6in; " class="Table57_A4"><p>Upper case letters:  “A” through “Z”</p></td><td style="text-align:left;width:0.8125in; " class="Table57_B4"><p>65 - 90</p></td><td style="text-align:left;width:1.0625in; " class="Table57_B4"><p>41 – 5A</p></td><td style="text-align:left;width:1.5069in; " class="Table57_D4"><p class="Figure">0100 0001 – 0101 1010</p></td></tr><tr class="Table573"><td style="text-align:left;width:2.6in; " class="Table57_A4"><h1 class="Heading_20_1"><a id="a__Punctuation________^__"></a>Punctuation:  [   \   ]   ^   _</h1></td><td style="text-align:left;width:0.8125in; " class="Table57_B4"><p>91 - 96</p></td><td style="text-align:left;width:1.0625in; " class="Table57_B4"><p>5B – 60</p></td><td style="text-align:left;width:1.5069in; " class="Table57_D4"><p class="Figure">0101 1011 – 0110 0000</p></td></tr><tr class="Table573"><td style="text-align:left;width:2.6in; " class="Table57_A4"><p>Lower case letters:  “a” through “z”</p></td><td style="text-align:left;width:0.8125in; " class="Table57_B4"><p>97 - 122</p></td><td style="text-align:left;width:1.0625in; " class="Table57_B4"><p>61 – 7A</p></td><td style="text-align:left;width:1.5069in; " class="Table57_D4"><p class="Figure">0110 0001 – 0111 1010</p></td></tr><tr class="Table573"><td style="text-align:left;width:2.6in; " class="Table57_A4"><p>Punctuation: {   |   }   ~</p></td><td style="text-align:left;width:0.8125in; " class="Table57_B4"><p>123 - 126</p></td><td style="text-align:left;width:1.0625in; " class="Table57_B4"><p>7B – 7E</p></td><td style="text-align:left;width:1.5069in; " class="Table57_D4"><p class="Figure">0111 1011 – 0111 1110</p></td></tr><tr class="Table573"><td style="text-align:left;width:2.6in; " class="Table57_A2"><p>Control character: Delete</p></td><td style="text-align:left;width:0.8125in; " class="Table57_B2"><p>127</p></td><td style="text-align:left;width:1.0625in; " class="Table57_B2"><p>7F</p></td><td style="text-align:left;width:1.5069in; " class="Table57_D2"><p class="Figure">0111 1111</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-20.png" alt="" class="Image">
			
			<p>
				where “Control characters” refer to “nonprinting” characters such as return, line feed, and form feed; and  “Punctuation” refers to any printable character that is not a digit or letter.  
			</p>
			
			<p>
				Figure 11.22 contains a table illustrating the binary and hexadecimal representations of all of the printable ASCII characters.  These range from the space character at position 32  (20<span class="Subscript"> sixteen</span> or 0010 0000 <span class="Subscript">two</span>), to the tilde, “~”, at position 126 (7E<span class="Subscript"> sixteen</span> or 0111 1110<span class="Subscript"> two</span>).
			</p>
			
			<p>
				The ASCII code for a character may be found in the table by locating the row and column in which the character appears.  The row specifies the high-order hexadecimal digit (or high-order four binary digits) and the column specifies the low-order hexadecimal digit    (or low-order four binary digits).  For example, the ASCII code for “H” is 48<span class="Subscript"> sixteen</span> since it appears on the row labeled “4” and in the column labeled “8”.  This same character expressed as a binary number is 0100 1000<span class="Subscript">two</span>.   To see this, you could either directly convert 48 <span class="Subscript">sixteen</span> to 0100 1000<span class="Subscript"> two</span> or you could perform the table lookup using the binary values rather than the hexadecimal values.  To determine the decimal version of the ASCII value, you must perform the conversion from base two (or base sixteen) to base ten using the algorithm discussed in Section 11.4.1. In the case of “H” the decimal representation is 72 <span class="Subscript">ten</span> (4 * 16 + 8 * 1).
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-22.png" alt="" class="Image">
			
			<p class="Figure">
				Figure 11.22:  The printable ASCII Characters
			</p>
			
			<p>
				While any assignment of bit patterns to characters would accomplish the primary task of enabling computers to store character data, a lot of thought went into the design of ASCII.  For example, upper case and lower case characters differ in ASCII by exactly one bit (e.g., “A” is 0100 0001 and “a” is 0110 0001).  Hence, any lower case character can be changed to upper case by simply setting bit six to “0”.  Conversion from upper case to lower case is just as easy – set bit six to “1”.
			</p>
			
			<p>
				Ok, time out for a second.  This concept of mapping characters to bit patterns may make sense, but isn’t it true that when you type something into your computer, like an email message or a term paper, you type characters on a keyboard and see characters on the screen – not ASCII codes?  What gives?
			</p>
			
			<p>
				What gives is that the ASCII codes are hidden from the computer user.  When you type “yo” on your keyboard, you first hit a key marked “y” – which causes the keyboard circuitry to generate the ASCII code “0111 1001”.  Next you strike the key marked “o” causing the keyboard circuitry to generate the ASCII code “0110 1111”.  The display circuitry built into your computer’s video card, in turn displays the character “y” when it receives the ASCII code “0111 1001” and “o” when it receives the ASCII bit pattern “0110 1111”.  Hence, the user never sees the ASCII codes.  From his or her perspective, “yo” was typed on the keyboard and displayed on the screen.
			</p>
			
			<p>
				It is interesting to note what happens when you hold down the shift key as you strike the “y”.  What the shift key actually does (for the keys marked with letters of the alphabet) is set bit six to “0”.  Thus, the combination of “shift” and “y” produces “0101 1001” which is the ASCII code for “Y”
			</p>
			
			<p class="Section">
				Exercises for Section 11.4.2
			</p>
			
			<ol>
				<li>
					Translate the following text into its ASCII representation.
				
					<p class="Subfigure">
						I will not eat them in the rain.
					</p>
				</li>

			
				<li>
					Translate the following ASCII text into the English alphabet.
					
					<p class="Subfigure">
						43  69  6E  64  79  20  4C  6F  75  20  57  68  6F
					</p>
				</li>
			</ol>
			
			<p class="Section">
				11.4.3  Images
			</p>
			
			<p>
				As you may recall from your study of computer graphics in Chapter 6, digital images are composed of a large number of basic picture elements called pixels.  Each pixel represents the particular brightness and color value of a tiny dot that is to be displayed on a screen or drawn on paper.  By arranging pixels into two-dimensional grids, an image can be formed.
			</p>
			
			<p>
				Digital images are most often represented within the computer as bit maps. A bit map is a two-dimensional array of values, where each value corresponds directly to a pixel’s intensity or color.  The simplest digital images are monochrome (black and white) images that use one bit per pixel, “1” for black and “0” for white, or vice versa.  Images that incorporate multiple colors or shades of gray require multiple bits per pixel.  For example, an image that uses four shades of gray (black, dark gray, light gray, white) would require two bits per pixel.  These bit values might map to the pixel “color” as “00” for black, “01” for dark gray, “10” for light gray, and “11” for white.  Full color digital images (capable of displaying millions of colors) require twenty-four or more bits per pixel.
			</p>
			
			<p>
				Figure 11.23 presents a digital image and the bit map that underlies it.  The image is very simple, containing the word “Hi” drawn as black letters on a white background.  The “resolution” of the image is eleven pixels per line by nine lines.  Each pixel represents one of only two colors, “1” is used for black and “0” for white. In order to help clarify the meaning of the bit map, the pixel grid lines are shown in the figure.  In reality, these lines would not be displayed.  They simply mark the boundaries of each pixel.
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-23.png" alt="" class="Image">
			
			<p class="Figure">
				Figure 11.23:  A monochrome image and its underlying bit map.
			</p>
			
			<p>
				Although we presented the bit map in Figure 11.23 in its two-dimensional form, as we have seen, computer memory is really a one-dimensional structure.  So, the bit map would actually be stored in a form similar to the following:
			</p>
			
			<p class="Subfigure">
				0000000000001000100000010001000100100010000001111100010010001000100100010001001000100010 00000000000
			</p>
			
			<p>
				As long as we know where the image begins and the dimensions of the image (the number of pixels per line and the number of lines per image) we will be able to reconstruct the image.
			</p>
			
			<p>
				Finally, it should be noted that this sequence of 1’s and 0’s can be interpreted in many ways.  As we have just seen, when interpreted as a two-dimensional bit map of size 11 by 9 where a 0 is a light area and a 1 is a dark area, it is a graphical image of the word “Hi”.<span class="Footnote" title="Footnote: Which is, of course, quite different from the ASCII representation of the characters “H” and “i”."><a href="#ftn6" id="body_ftn6">[6]</a></span>  This same bit pattern would have an entirely different meaning if interpreted as a sequence of unsigned numbers, a sequence of signed numbers, a sequence of floating point numbers, a sequence of ASCII characters, or a sequence of program instructions.  Thus, determining the meaning of a symbol, or sequence of symbols, requires that you know the type of data being represented and how it is encoded.
			</p>
			
			<p class="Section">
				Exercises for Section 11.4.3
			</p>
			
			<ol>
				<li>
					Interpret the bit pattern of Figure 11.23 as a sequence of 8-bit unsigned integers.   Ignore any extra bits that may occur at the end of the pattern.
				</li>
				<br/>
				<li>
					Interpret the bit pattern of Figure 11.23 as a sequence of 8-bit two’s complement numbers.  Ignore any extra bits that may occur at the end of the pattern.
				</li>
				<br/>
				<li>
					Interpret the bit pattern of Figure 11.23 as a sequence of 16-bit unsigned integers.   Ignore any extra bits that may occur at the end of the pattern.
				</li>
				<br/>
				<li>
					Interpret the bit pattern of Figure 11.23 as a sequence of 16-bit two’s complement numbers.  Ignore any extra bits that may occur at the end of the pattern.
				</li>
				<br/>
				<li>
					Interpret the bit pattern of Figure 11.23 as a sequence of 32-bit floating point numbers.  Ignore any extra bits that may occur at the end of the pattern.
				</li>
			</ol>
			
			<p class="Section">
				11.5  Machine language 
			</p>
			
			<p>
				This section is concerned with software at its lowest level – the machine level of 1’s and 0’s.  The particular machine language we will examine is the Watson Virtual Machine language.
			</p>
			
			<p>
				Let’s begin by reviewing the architecture of the Watson VM and filling in some details that were omitted when the machine was first introduced in Section 11.2.  Referring back to Figure 11.1, we see that the Watson VM consists of 256 words of memory together with a CPU that holds sixteen general-purpose registers, a program counter, an instruction register, and various status bits.
			</p>
			
			<p>
				The reason why there are only 256 words of memory (labeled 0-255) in this machine is that addresses are limited to exactly eight bits.  Thus, the range of valid addresses extends from 0000 0000<span class="Subscript">two</span> to 1111 1111<span class="Subscript">two</span> ( 0 to FF<span class="Subscript">sixteen</span> or 0 to 255<span class="Subscript">ten</span>, when interpreted as unsigned binary numbers).  Since the program counter is a special-purpose register that is used to hold the address of the next instruction, its size is limited to eight bits – the width of an address.
			</p>
			
			<p>
				The word size used in the Watson VM for both main memory and the general-purpose registers is sixteen bits.  This means that the range of values that can be represented by a register or single word of memory is –2<span class="Superscript">15</span> to 2<span class="Superscript">15</span> –1 ( -32,768 to 32,767 ) when using two’s complement notation.
			</p>
			
			<p>
				Since a word of memory can hold a program instruction as well as data, the size of each Watson Virtual Machine instruction is sixteen bits.  This is also the size of the instruction register located in the CPU.  Finally, the status bit registers, as their names imply, are each one bit long. 
			</p>
			
			<p class="Section">
				11.5.1 The Watson Virtual Machine instruction set 
			</p>
			
			<p>
				The general format of Watson VM language instructions is given in Figure 11.24.  The leftmost four bits of the sixteen-bit instruction (bits 13-16) contain the operation code.  Each instruction recognized by the machine has a unique operation code, or op-code.  Since Watson VM op-codes are four bits long, the Watson VM language can consist of at most sixteen different instructions.  In fact, the Watson Virtual Machine language contains exactly sixteen instructions.
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-24.png" alt="" class="Image">

			<p class="Figure">
				Figure 11.24: The format of a Watson Virtual Machine instruction
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-25.png" alt="" class="Image">

			<p class="Figure">
				Figure 11.25: The Watson Virtual Machine instruction set
			</p>
			
			<p>
				Following the four-bit op-code, the final twelve bits of each instruction specify the operands (data) on which the operation is to take place.  How these bits are interpreted depends on the particular op-code specified in bits 13-16.  However, bits 9-12 generally specify a register number, while bits 1-8 specify either an 8-bit address, an 8-bit value, or two additional registers (one in bits 5-8 and the other in bits 1-4).
			</p>
			
			<p>
				Figure 11.25 illustrates the sixteen instructions that make up the Watson machine language.  The op-code, assembly language equivalent, and a description of behavior is presented for each instruction.  The general behavior of many of these instructions should already be familiar to you, since each machine language statement has a corresponding Watson assembly language statement and most of these were discussed in Section 11.3.  We’ll now fill in some of the low-level details that were omitted earlier.
			</p>
			
			<p>
				The op-code for the <span class="Subfigure">LOADIMM</span> statement is “0000”.  This op-code is followed by a four-bit register designation and an eight-bit two’s complement value.  <span class="Subfigure">LOADIMM</span> loads the specified register with the specified value.  Thus, the machine language statement:
			</p>
			
			<p class="Subfigure">
				0000 1010 0100 0001
			</p>
			
			<p>
				means load register A (1010<span class="Subscript">two</span>) with the value 0100 0001<span class="Subscript">two</span> ( 41<span class="Subscript">sixteen</span> or 65<span class="Subscript">ten </span>).
			</p>
			
			<p>
				Since there are only eight bits available in the <span class="Subfigure">LOADIMM</span> statement with which to specify a value, the range of possible values is limited to -2<span class="Superscript">7</span> to 2<span class="Superscript">7</span> –1 ( -128<span class="Subscript"> ten</span> to +127 <span class="Subscript">ten </span>).  However, the register in which the value is to be stored is sixteen bits long, so it is important that the machine load the specified value into the low-order bits of the register.  Furthermore, if the value is negative, the high-order eight bits must be set to 1’s.  Assuming a positive value, the high-order bits of the register are set to 0’s.  Thus, loading “0100 0001” into register A sets the register to “0000 0000 0100 0001”.  Loading -65<span class="Subscript">ten</span> (1011 1111<span class="Subscript">two</span>) into register A would set it to “1111 1111 1011 1111”.
			</p>
			
			<p>
				The formats of the <span class="Subfigure">LOAD</span> and <span class="Subfigure">STORE</span> statements are very similar: an op-code, followed by a register, followed by an 8-bit address.  The op-code for <span class="Subfigure">LOAD</span> is “0001” so the machine language statement 
			</p>
			
			<p class="Subfigure">
				0001 1011 0000 0001
			</p>
			
			<p>
				is interpreted to mean copy into register B (1011<span class="Subscript">two</span>) the value held at memory address one (0000 0001<span class="Subscript">two</span>).<span class="Footnote" title="Footnote: Memory address 0000 0001two is the second location in memory. The first location is labeled memory address 0000 0000two."><a href="#ftn7" id="body_ftn7">[7]</a></span>  The op-code for <span class="Subfigure">STORE</span> is “0010”, so 
			</p>
			
			<p class="Subfigure">
				0010 1100 0000 0000
			</p>
			
			<p>
				copies the current value of register C (1100<span class="Subscript">two</span>) into memory location zero (0000 0000<span class="Subscript">two</span>).
			</p>
			
			<p>
				<span class="Subfigure">LOADIND</span> and <span class="Subfigure">STOREIND</span><span class="T3"> also have similar formats.  Following the op-code (in bits 13-16) are two register numbers (one in bits 9-12 and one in bits 5-8).  Bits 1-4 are unused in these statements and are ignored by the machine.  Thus, they can take on any value.  For consistency, however, these last four bits are normally set to “0000”.  </span>
			</p>
			
			<p>
				The op-code for <span class="Subfigure">LOADIND</span> is “0011”.  So,
			</p>
			
			<p class="Subfigure">
				0011 1101 1110 0000
			</p>
			
			<p>
				specifies that the value located at the address held in register E (1110<span class="Subscript">two</span>) should be placed into register D (1101<span class="Subscript">two</span>).  If register E contained  “0000 0000 0000 0010”, the value stored at memory location two would be loaded into register D.
			</p>
			
			<p>
				Because addresses are only eight bits in length while registers are sixteen bits, the high-order eight bits of the register contents are ignored when determining the address it represents.  Hence, if register E held the bit pattern “1111 1111 0000 0010”, the address would still be interpreted as location two.  Of course, for clarity, it is best to insure that these high-order bits are set to 0’s.
			</p>
			
			<p>
				The op-code for <span class="Subfigure">STOREIND</span> is “0100”, so the bit pattern
			</p>
			
			<p class="Subfigure">
				0100 1101 1110 0000
			</p>
			
			<p>
				is interpreted as a command to store the contents of register D (1101<span class="Subscript">two</span>) into the address indicated by register E (1110<span class="Subscript">two</span>).  As with <span class="Subfigure">LOADIND</span>, the last four bits of the <span class="Subfigure">STOREIND</span> instruction are ignored.  The high-order eight bits of the contents of the second register, E in this case, are ignored as well.  So, if register D held the value ten and register E held the value one hundred, this statement would place a ten (0000 0000 0000 1010<span class="Subscript">two</span>) into memory location one hundred (0110 0100<span class="Subscript">two</span>).
			</p>
			
			<p>
				The next two statements listed in Figure 11.25 are the arithmetic instructions <span class="Subfigure">ADD</span> and <span class="Subfigure">SUBTRACT</span>.  Both of these statements have a similar form: an op-code followed by three registers.  The first register (indicated by bits 9-12) will hold the result of the arithmetic operation.  The second and third registers (bits 5-8 and 1-4) provide the inputs.  Input values are assumed to be in two’s complement binary notation; outputs are generated in this notation as well.
			</p>
			
			<p>
				The op-code for addition is “0101” and for subtraction is “0110”.  Hence, the statement
			</p>
			
			<p class="Subfigure">
				0101 0101 0110 0111
			</p>
			
			<p>
				will add the contents of register 6 (0110<span class="Subscript">two</span>) and register 7 (0111<span class="Subscript">two</span>) and place the result into register 5 (0101<span class="Subscript">two</span>).  Similarly, the statement
			</p>
			
			<p class="Subfigure">
				0110 0000 0001 0010
			</p>
			
			<p>
				will subtract the contents of register 2 (0010<span class="Subscript">two</span>) from register 1 (0001<span class="Subscript">two</span>) and place the result into register 0 (0000<span class="Subscript">two</span>).
			</p>
			
			<p>
				The next three Watson machine language instructions implement the logical operations “and”, “or”, and “not”.  Because these statements operate on the bit-level, their function was not discussed in Section 11.3.  Basically, the “and” operation produces a “1” (meaning “true”) when both its first <span class="Ital">and</span> second input are “1” – otherwise (when either or both inputs are “0”) it produces a “0”.  The “or” operation produces a “1” (“true”) when either its first <span class="Ital">or</span> second input is “1” – otherwise (when both inputs are “0”) it produces a “0’.  The “not” operation simply inverts, or complements, its input bit.  Given a “1” it produces “0”.  Given a “0” it produces “1”.  The behavior of each of these three operators is summarized in Figure 11.26.
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-26.png" alt="" class="Image">

			<p class="Figure">
				Figure 11.26:  The logical operators “and”, “or”, and “not”
			</p>
			
			<p>
				The op-codes for the <span class="Subfigure">AND</span>, <span class="Subfigure">OR</span>, and <span class="Subfigure">NOT</span> instructions are “0111”, “1000”, and “1001”, respectively.  The formats for <span class="Subfigure">AND</span> and <span class="Subfigure">OR</span> are similar to the formats for the arithmetic instructions: a result register and two input registers follow the op-code.  Hence, the instruction
			</p>
			
			<p class="Subfigure">
				0111 1010 1011 1100
			</p>
			
			<p>
				is interpreted to mean: “apply the ‘and’ operator to the contents of registers B (1011<span class="Subscript">two</span>) and C (1100<span class="Subscript">two</span>) with the result being stored in register A(1010<span class="Subscript">two</span>).”  Similarly, 
			</p>
			
			<p class="Subfigure">
				1000 0000 0001 0010
			</p>
			
			<p>
				means “apply the ‘or’ operator to the contents of registers 1 (0001<span class="Subscript">two</span>) and 2 (0010<span class="Subscript">two</span>) with the result being stored in register 0 (0000<span class="Subscript">two</span>).”
			</p>
			
			<p>
				Both <span class="Subfigure">AND</span> and <span class="Subfigure">OR</span> apply their respective logical operators in a “bitwise” manner.  In other words, the bit values in position <span class="Ital">x</span> of the two inputs are “anded” or “ored” to generate the corresponding bit value in position <span class="Ital">x</span> of the output.  Given the <span class="Subfigure">OR</span> instruction above, together with the following values in registers 1 and 2, the result in register 0 would be computed as shown.
			</p>
			
			<!--ill21
			<table border="0" cellspacing="0" cellpadding="0" class="Table64">
			<colgroup><col width="42"/><col width="60"/><col width="18"/><col width="28"/><col width="28"/><col width="28"/><col width="28"/><col width="28"/><col width="28"/><col width="28"/><col width="28"/><col width="28"/><col width="28"/><col width="28"/><col width="28"/><col width="28"/><col width="28"/><col width="28"/><col width="29"/></colgroup><tr class="Table641"><td style="text-align:left;width:0.3819in; " class="Table64_A1"><p class="P11"> </p></td><td style="text-align:left;width:0.5438in; " class="Table64_A1"><p>Reg 1</p></td><td style="text-align:left;width:0.166in; " class="Table64_A1"><p class="P44"> </p></td><td style="text-align:left;width:0.2486in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2576in; " class="Table64_S1"><p class="Subfigure">0</p></td></tr><tr class="Table641"><td style="text-align:left;width:0.3819in; " class="Table64_A1"><p>OR</p></td><td style="text-align:left;width:0.5438in; " class="Table64_B2"><p>Reg 2</p></td><td style="text-align:left;width:0.166in; " class="Table64_A1"><p class="P44"> </p></td><td style="text-align:left;width:0.2486in; " class="Table64_D2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2576in; " class="Table64_S2"><p class="Subfigure">1</p></td></tr><tr class="Table641"><td style="text-align:left;width:0.3819in; " class="Table64_A1"><p class="P11"> </p></td><td style="text-align:left;width:0.5438in; " class="Table64_B3"><p>Reg 0</p></td><td style="text-align:left;width:0.166in; " class="Table64_A1"><p class="P44"> </p></td><td style="text-align:left;width:0.2486in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2507in; " class="Table64_D1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2576in; " class="Table64_S1"><p class="Subfigure">1</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-21.png" alt="" class="Image">
			
			<p>
				To convince yourself that this answer is correct, simply look up the output specified by the “or” table for the given inputs, on a column-by-column basis.  For example, the rightmost column of registers 1 and 2 specify a “0” and a “1” which produce a “1” according to the “or” table.  Hence, a “1” is placed in the rightmost column of register 0.  The other columns are processed similarly.
			</p>
			
			<p>
				The <span class="Subfigure">NOT</span> instruction is even simpler than <span class="Subfigure">AND</span> and <span class="Subfigure">OR</span>.  After the op-code, two registers are specified: a result register in bits 9-12 and an input register in bits 5-8.  Bits 1-4 are unused by this instruction.  The <span class="Subfigure">NOT</span> instruction
			</p>
			
			<p class="Subfigure">
				1001 1111 1010 0000
			</p>
			
			<p>
				stores into register F (1111<span class="Subscript">two</span>) the complement of the value held in register A (1010<span class="Subscript">two</span>).  If register A contained the bit pattern “0000 0000 0000 0000” this instruction would place “1111 1111 1111 1111” into register F.  Note that <span class="Subfigure">NOT</span> simply applies the “not” table of Figure 11.26 in a bitwise manner to the contents of the input register to determine the pattern to be stored in the output register.
			</p>
			
			<p>
				Now that we understand what the logical operators do, it is important to spend a moment showing how they can be used to solve problems.  Here are two examples.
			</p>
			
			<p>
				Changing the sign of a two’s complement number involves complementing the bits of the number and then adding one. Since the <span class="Subfigure">NOT</span> instruction implements the complement operation, it makes sign conversion very easy.
			</p>
			
			<p>
				Upper and lower letters of the alphabet differ by exactly one bit in their ASCII representations.  For example, an upper case “A” is “0100 0001” while a lower case “a” is “0110 0001”.  Any lower case character can be changed to upper case by simply setting bit six to “0”.  Conversely, any upper case character can be converted to lower case by setting bit to “1”.
			</p>
			
			<p>
				The <span class="Subfigure">AND</span> and <span class="Subfigure">OR</span> instructions can be used to change the case of ASCII characters. By “anding” an ASCII character code with the bit pattern “1101 1111”, a lower case character can be converted to its corresponding upper case character.  For example: 
			</p>
			
			<!--ill22
			<table border="0" cellspacing="0" cellpadding="0" class="Table65">
			<colgroup><col width="70"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="65"/></colgroup><tr class="Table651"><td style="text-align:left;width:0.6326in; " class="Table65_A1"><p class="P38"> </p></td><td style="text-align:left;width:0.2903in; " class="Table65_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table65_B1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2903in; " class="Table65_B1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table65_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table65_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2903in; " class="Table65_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table65_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table65_B1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table65_J1"><p class="P44"> </p></td><td style="text-align:left;width:0.5833in; " class="Table65_K1"><p class="Subfigure">a</p></td></tr><tr class="Table651"><td style="text-align:left;width:0.6326in; " class="Table65_A1"><p>AND</p></td><td style="text-align:left;width:0.2903in; " class="Table65_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table65_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2903in; " class="Table65_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table65_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table65_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2903in; " class="Table65_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table65_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table65_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table65_J2"><p class="P44"> </p></td><td style="text-align:left;width:0.5833in; " class="Table65_A1"><p class="P44"> </p></td></tr><tr class="Table651"><td style="text-align:left;width:0.6326in; " class="Table65_A1"><p class="P19"> </p></td><td style="text-align:left;width:0.2903in; " class="Table65_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table65_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2903in; " class="Table65_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table65_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table65_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2903in; " class="Table65_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table65_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table65_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table65_J3"><p class="P44"> </p></td><td style="text-align:left;width:0.5833in; " class="Table65_K1"><p class="Subfigure">A</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-22.png" alt="" class="Image">
			
			<p>
				Note that this procedure does not modify characters that are already in upper case, as can be seen in the following example.
			</p>
			
			<!--ill23
			<table border="0" cellspacing="0" cellpadding="0" class="Table66">
			<colgroup><col width="70"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="65"/></colgroup><tr class="Table661"><td style="text-align:left;width:0.6326in; " class="Table66_A1"><p class="P38"> </p></td><td style="text-align:left;width:0.2903in; " class="Table66_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table66_B1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2903in; " class="Table66_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table66_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table66_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2903in; " class="Table66_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table66_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table66_B1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table66_J1"><p class="P44"> </p></td><td style="text-align:left;width:0.5833in; " class="Table66_K1"><p class="Subfigure">A</p></td></tr><tr class="Table661"><td style="text-align:left;width:0.6326in; " class="Table66_A1"><p>AND</p></td><td style="text-align:left;width:0.2903in; " class="Table66_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table66_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2903in; " class="Table66_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table66_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table66_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2903in; " class="Table66_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table66_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table66_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table66_J2"><p class="P44"> </p></td><td style="text-align:left;width:0.5833in; " class="Table66_A1"><p class="P44"> </p></td></tr><tr class="Table661"><td style="text-align:left;width:0.6326in; " class="Table66_A1"><p class="P19"> </p></td><td style="text-align:left;width:0.2903in; " class="Table66_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table66_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2903in; " class="Table66_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table66_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table66_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2903in; " class="Table66_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table66_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table66_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table66_J3"><p class="P44"> </p></td><td style="text-align:left;width:0.5833in; " class="Table66_K1"><p class="Subfigure">A</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-23.png" alt="" class="Image">
			
			<p>
				To change a character from upper case to lower case, its ASCII code can be “ored” with the bit pattern “0010 0000”.  To illustrate:
			</p>
			
			<!--ill24
			<table border="0" cellspacing="0" cellpadding="0" class="Table67">
			<colgroup><col width="70"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="65"/></colgroup><tr class="Table671"><td style="text-align:left;width:0.6326in; " class="Table67_A1"><p class="P38"> </p></td><td style="text-align:left;width:0.2903in; " class="Table67_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table67_B1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2903in; " class="Table67_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table67_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table67_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2903in; " class="Table67_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table67_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table67_B1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table67_J1"><p class="P44"> </p></td><td style="text-align:left;width:0.5833in; " class="Table67_K1"><p class="Subfigure">A</p></td></tr><tr class="Table671"><td style="text-align:left;width:0.6326in; " class="Table67_A1"><p>OR</p></td><td style="text-align:left;width:0.2903in; " class="Table67_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table67_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2903in; " class="Table67_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table67_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table67_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2903in; " class="Table67_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table67_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table67_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table67_J2"><p class="P44"> </p></td><td style="text-align:left;width:0.5833in; " class="Table67_A1"><p class="P44"> </p></td></tr><tr class="Table671"><td style="text-align:left;width:0.6326in; " class="Table67_A1"><p class="P19"> </p></td><td style="text-align:left;width:0.2903in; " class="Table67_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table67_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2903in; " class="Table67_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table67_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table67_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2903in; " class="Table67_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table67_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table67_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table67_J3"><p class="P44"> </p></td><td style="text-align:left;width:0.5833in; " class="Table67_K1"><p class="Subfigure">a</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-24.png" alt="" class="Image">
			
			<p>
				If the character is already in lower case, this operation will have no effect on the character.
			</p>
			
			<!--ill25
			<table border="0" cellspacing="0" cellpadding="0" class="Table68">
			<colgroup><col width="70"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="32"/><col width="65"/></colgroup><tr class="Table681"><td style="text-align:left;width:0.6326in; " class="Table68_A1"><p class="P38"> </p></td><td style="text-align:left;width:0.2903in; " class="Table68_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table68_B1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2903in; " class="Table68_B1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table68_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table68_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2903in; " class="Table68_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table68_B1"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table68_B1"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table68_J1"><p class="P44"> </p></td><td style="text-align:left;width:0.5833in; " class="Table68_K1"><p class="Subfigure">a</p></td></tr><tr class="Table681"><td style="text-align:left;width:0.6326in; " class="Table68_A1"><p>OR</p></td><td style="text-align:left;width:0.2903in; " class="Table68_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table68_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2903in; " class="Table68_B2"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table68_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table68_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2903in; " class="Table68_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table68_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table68_B2"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table68_J2"><p class="P44"> </p></td><td style="text-align:left;width:0.5833in; " class="Table68_A1"><p class="P44"> </p></td></tr><tr class="Table681"><td style="text-align:left;width:0.6326in; " class="Table68_A1"><p class="P19"> </p></td><td style="text-align:left;width:0.2903in; " class="Table68_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table68_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.2903in; " class="Table68_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table68_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table68_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.2903in; " class="Table68_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table68_B3"><p class="Subfigure">0</p></td><td style="text-align:left;width:0.291in; " class="Table68_B3"><p class="Subfigure">1</p></td><td style="text-align:left;width:0.291in; " class="Table68_J3"><p class="P44"> </p></td><td style="text-align:left;width:0.5833in; " class="Table68_K1"><p class="Subfigure">a</p></td></tr></table>
			-->
			
			<img src="Images/AssemblyIMGS/ill11-25.png" alt="" class="Image">
			
			<p>
				Returning to our tour of the Watson Virtual Machine instruction set, the next two instructions implement the “shift” operators.  Like the logic operators, the shift instructions were not covered at the assembly level in Section 11.3.
			</p>
			
			<p>
				The <span class="Subfigure">ASL</span>, or “arithmetic shift left”, command uses op-code 1010.  The <span class="Subfigure">ASR</span>, or “arithmetic shift right”, command uses op-code 1011.  The purpose of these commands is to move, or shift, the bit values of a register some number of positions either to the left or to the right.  These shifts are called “arithmetic” shifts because they are designed to respect the sign of the number being shifted, when it is interpreted using two’s complement binary notation.  The format of both shift commands is an op-code in bits 13-16, a destination register number in bits 9-12, a source register number in bits 5-8, and a four-bit unsigned number in bits 1-4.  This number specifies how many positions the bits of the source register are to be shifted in order to produce the value to be stored in the destination register.
			</p>
			
			<p>
				Assume a value of four is stored in register F.  This value would be represented as the two’s complement number “0000 0000 0000 0100”.  Shifting this number one position to the left and storing the result in register 0, via the statement:
			</p>
			
			<p class="Subfigure">
				1010 0000 1111 0001
			</p>
			
			<p>
				will cause register 0 to take on the value “0000 0000 0000 1000” or eight.  Shifting the contents of register 0 over one additional position to the left and storing that result in register 1, would cause “0000 0000 0001 0000” or sixteen to be stored into register 1.  In fact, for each position that a bit pattern is shifted to the left, the number it represents is doubled.  So, shifting a pattern three positions to the left multiples the number by eight  (2 &#215;2 &#215;2).
			</p>
			
			<p>
				Shifting a value to the right has the opposite effect.  The number represented by the bit pattern is divided by two for each position to the left it is shifted.  Assuming that register F contains the pattern “0000 0000 0000 0100” or four, the statement:
			</p>
			
			<p class="Subfigure">
				1011 0000 1111 0001
			</p>
			
			<p>
				places the bit pattern “0000 0000 0000 0010” or two into register 0.
			</p>
			
			<p>
				For negative numbers the same principle applies: shifting left by one position doubles the number, shifting right one position halves it.  In order for these semantics to be implemented properly, arithmetic shifts must respect the sign bit.  When shifting right, if the sign bit is “1” as in “1000” (-8) then 1’s must be added on the left, giving “1100” (-4) when shifted right once, and “1110” (-2) when shifted left twice.   If the sign bit is “0” then 0’s must be added on the left when shifting right.
			</p>
			
			<p>
				The last four instructions in the Watson Virtual Machine language are concerned with determining which instruction will be executed next.  These commands and their op-codes are:
			</p>
			
			<ul class="Blockcenter">
				<li><span class="Subfigure">COMPARE       1100</span></li>
				<li><span class="Subfigure">BRANCH        1101</span></li>
				<li><span class="Subfigure">JUMP          1110</span></li>
				<li><span class="Subfigure">HALT          1111</span></li>
			</ul>
			
			<p>
				The <span class="Subfigure">HALT</span> command has no operands.  It consists solely of the op-code “1111” in bits 13-16.  The other 12 bits of the instruction are ignored – but usually set to zero for clarity.  When executed, <span class="Subfigure">HALT</span> causes the program to terminate.
			</p>
			
			<p>
				The <span class="Subfigure">JUMP</span>> command consists of the op-code “1110” in the standard location, bits 13-16, and an 8-bit address in bits 1-8.  Bits 9-12 are unused, but normally set to zero.  The <span class="Subfigure">JUMP</span> instruction causes program control to be transferred to the instruction stored at the indicated memory address.  For example, the instruction
			</p>
			
			<p class="Subfigure">
				1110 0000 0010 0000
			</p>
			
			<p>
				will cause the statement stored at memory location 32 (0010 0000<span class="Subscript">two</span>) to be executed next.  The <span class="Subfigure">JUMP</span> accomplishes this feat by loading the 8-bit address contained in the instruction into the program counter.  Recall that the program counter is a special-purpose register that always contains the address of the next instruction to be executed.  The Watson VM consults this register to determine which instruction should be fetched from memory and placed into the instruction register.
			</p>
			
			<p>
				The final two instructions, <span class="Subfigure">COMPARE</span> and <span class="Subfigure">BRANCH</span> usually, but not always, appear together in machine (and assembly) language programs.  The purpose of the <span class="Subfigure">COMPARE</span> instruction, as its name implies, is to compare the values of two numbers that are written in two’s complement notation.  The statement consists of the op-code “1100” in bits 13-16, followed by two input registers in bits 5-8 and 1-4.  Bits 9-12 are unused. The statement
			</p>
			
			<p class="Subfigure">
				1100 0000 1110 1111
			</p>
			
			<p>
				compares the contents of the registers E and F, setting the machine’s status bits accordingly.
			</p>
			
			<p>
				The <span class="Subfigure">COMPARE</span> statement works by subtracting the contents of the register specified in bits 1-4 from the contents of the register specified in bits 5-8.  The result of this subtraction, surprisingly, is discarded; which explains why bits 9-12 of the instruction are unused – there is no need to specify a “destination register” in which to store the result.  Although it may seem odd to perform a subtraction and then discard the “answer”, <span class="Subfigure">COMPARE</span> accomplishes its goal of setting the status bits.
			</p>
			
			<p>
				The arithmetic instructions, <span class="Subfigure">ADD</span> and <span class="Subfigure">SUBTRACT,</span> also set the machine’s status bits.  So, instead of comparing the contents of two registers via <span class="Subfigure">COMPARE</span>, the same effect could be achieved by directly using <span class="Subfigure">SUBTRACT</span> and placing its result into an unused register whose value would be subsequently ignored.  Using <span class="Subfigure">COMPARE</span>, however, is better since the intention of the programmer, to compare two values, is much clearer.
			</p>
			
			<p>
				The <span class="Subfigure">BRANCH</span> statement examines the contents of the status bit registers and, if the specified condition is true, loads the program counter with the 8-bit address of the next instruction to be executed.  The format of this statement is: the op-code “1101” in bits 13-16,  a 4-bit condition code in bits 9-12, and an 8-bit address in bits 1-8.
			</p>
			
			<p>
				There are ten different condition codes that are recognized by the <span class="Subfigure">BRANCH</span> statement.  These are presented in Figure 11.27.  The first six conditions (<span class="Subfigure">EQ</span>, <span class="Subfigure">NE</span>, <span class="Subfigure">LT</span>, <span class="Subfigure">LE</span>, <span class="Subfigure">GT</span>, <span class="Subfigure">GE</span>) were discussed in Section 11.3.  The final four conditions (<span class="Subfigure">CARY</span>, <span class="Subfigure">NEG</span>, <span class="Subfigure">ZERO</span>, <span class="Subfigure">OVER</span>) were not discussed because they are not used as frequently and an understanding of their function requires some knowledge of data representation at the machine level.  Even though these four conditions were not mentioned in the assembly-level discussion of the <span class="Subfigure">BRANCH</span> instruction, statements such as:
			</p>
			
			<p class="Subfigure">
				BRANCH OVER, ERROR
			</p>
			
			<p>are perfectly legal.  (This particular statement branches to the instruction labeled “error” in the event an overflow occurred.)</p>
			
			<img src="Images/AssemblyIMGS/fig11-27.png" alt="" class="Image">

			<p class="Figure">
				Figure 11.27:  The <span class="Subfigure">BRANCH</span> statement condition codes
			</p>
			
			<p>
				Looking at the table of Figure 11.27, we see that <span class="Subfigure">CARY</span> (code 0110) checks to see whether the last arithmetic (or compare) statement produced a carry – thus causing the “carry” status bit to be set to “1”.  <span class="Subfigure">NEG</span> (code 0111), <span class="Subfigure">ZERO</span> (code 1000), and <span class="Subfigure">OVER</span> (code 1001), each work in a similar manner.  <span class="Subfigure">NEG</span> checks to see whether the “Negative” status bit has been set to “1” – indicating that the last number produced by an arithmetic (or compare) statement had a “1” in its sign bit.  <span class="Subfigure">ZERO</span> checks to see whether the “Zero” status bit is set to “1”  – indicating that the result of the last arithmetic (or compare) statement was zero. <span class="Subfigure">OVER</span> determines whether an overflow occurred by determining whether the “Overflow” status bit is set to “1”.
			</p>
			
			<p>
				The condition code EQ (0000) is used to determine whether the results of a <span class="Subfigure">COMPARE</span> indicate that two numbers are equal.  Since <span class="Subfigure">COMPARE</span> is just a subtract, the inputs are equal if subtracting the second number from the first yields zero.  Thus, <span class="Subfigure">EQ</span> checks to see whether the “Zero” status bit is set to “1”.  This means that both <span class="Subfigure">EQ</span> (code 0000) and <span class="Subfigure">ZERO</span> (code 1000) do exactly the same thing – check the “Zero” status bit to see if it is “1”.  While only one code is strictly necessary, having two ways of referring to this operation can lead to programs that are easier for humans to understand.
			</p>
			
			<p>
				<span class="Subfigure">NE</span>, which stands for “not equal” and has a condition code of 0001, checks for the opposite condition as equal.  Hence, it checks to determine whether the “Zero” bit has been reset to “0” – indicating that the last result produced by an arithmetic statement (or compare) was not zero.  This makes sense, since the result of a subtraction or comparison will not be zero if the numbers are not equal.
			</p>
			
			<p>
				<span class="Subfigure">LT</span> works by determining whether the result of the last <span class="Subfigure">COMPARE</span> (or arithmetic operation) was negative.  This is accomplished by checking whether the “Negative” bit has been set to one.  If the first of two numbers is smaller than the second, the result of a comparison or subtraction will be negative.  Note that as was the case with <span class="Subfigure">EQ</span> and <span class="Subfigure">ZERO</span>, the codes for <span class="Subfigure">LT</span> and <span class="Subfigure">NEG</span> do the same thing.
			</p>
			
			<p>
				The opposite of <span class="Subfigure">LT</span> (less than) is <span class="Subfigure">GE</span> (greater than or equal to).  The code 0101 is used to represent <span class="Subfigure">GE</span>.  This condition is true when the “Negative” status bit contains a “0”, meaning “false”.  The reason for this is that the first of two numbers must be greater than or equal to the second if the result of a subtraction or comparison operation is not negative.
			</p>
			
			<p>
				The final two conditions, <span class="Subfigure">LE</span> (code 0011) and <span class="Subfigure">GT</span> (code 0100), each involve a test of two separate status bits.  <span class="Subfigure">LE</span> is true when either the “Negative” bit <span class="Ital">or</span> the “Zero” bit is set to “1” or both are “1”.  <span class="Subfigure">GT</span> is true when both the “Negative” bit  <span class="Ital">and</span> the “Zero” bit are reset to “0”.
			</p>
			
			<p class="Section">
				11.5.2  Assembly language to machine language translation
			</p>
			
			<p>
				Now that we are familiar with the Watson Virtual Machine language instruction set, we can examine the process of translating programs from the assembly level to the machine level.
			</p>
			
			<p>
				There are eighteen commands in the Watson assembly language.  There are sixteen commands in the Watson Virtual Machine language.  Referring back Figure 11.2 for an overview of the assembly language and Figure 11.25 for an overview of the machine language, we can see that with the exception of the <span class="Subfigure">.WORD</span> and <span class="Subfigure">.BLOCK</span> commands, every assembly language instruction maps to exactly one machine language instruction.  Thus the process of translation between these two levels is straightforward and can be automated.
			</p>
			
			<p>
				The programs that automatically translate assembly language programs to machine language are called “assemblers”.  Essentially, assemblers construct or “assemble” each of the machine language instructions of a program from the corresponding instruction in the assembly language version of the program.  Figure 11.28 illustrates the relationship between assembly language and machine language with an example program first shown in Figure 11.3.
			</p>
			
			<img src="Images/AssemblyIMGS/fig11-28.png" alt="" class="Image">

			<p class="Figure">
				Figure 11.28: Machine and assembly language versions of the same program
			</p>
			
			<p>
				The translation process from assembly language to machine language is described below for the Watson Virtual Machine.  While the process is simplified somewhat from what goes on in “real” systems, it should be sufficient to give you a feel for what happens when an assembly language program is translated to machine code and loaded into memory for execution.
			</p>
			
			<p>
				Beginning at some starting address (address zero in the Watson VM), reserve memory as specified by the <span class="Subfigure">.BLOCK</span> and <span class="Subfigure">.WORD</span> commands.  Perform the initializations required by the <span class="Subfigure">.WORD</span> commands.  Also note labels associated with each word, block, and command as they are encountered.  For example, <span class="Subfigure">TOTAL</span>, <span class="Subfigure">ABC</span>, and <span class="Subfigure">XYZ</span> are labels in the program of Figure 11.28.  After processing each of the <span class="Subfigure">.WORD</span> and <span class="Subfigure">.BLOCK</span> commands the “data segment” of your machine language program will be complete.
			</p>
			
			<p>
				The executable instructions of a machine language program will immediately follow its data segment.  For each assembly language instruction, use the table of Figure 11.25 to produce a machine language equivalent.  Instruction names at the assembly level are mapped to op-codes at the machine level.  References to registers at the assembly level are mapped to 4-bit unsigned register numbers.  Labels at the assembly level are replaced with the address associated with that label at the machine level. And so forth.
			</p>
			
			<p>
				At the conclusion of this process, the machine language equivalent of the assembly language program will be held in the main memory of the Watson Virtual Machine.  In order to begin program execution, the program counter is loaded with the address of the first executable machine language instruction – the first instruction following the data segment.
			</p>
			
			<p class="Section">
				11.5.3  Program execution
			</p>
			
			<p>
				We now address the final piece of the puzzle concerning machine language programs by illustrating how the machine actually goes about executing a program. At the machine level, all a computer ever does is perform the following task, known as the instruction cycle, over and over.  
			</p>
			
			<p>
				The <span class="Ital">instruction cycle</span> consists of five steps:
			</p>
			
			<ol>
				<li>
					Fetch the next instruction from memory.  To do so, load into the instruction register the bit pattern found at the address held in the program counter.
				</li>
				<br/>
				<li>
					Increment the program counter by one so that it points to the next instruction in the current sequence. 
				</li>
				<br/>
				<li>
					Decode the current instruction.  This involves correctly identifying the various parts of an instruction based on its op-code.
				</li>
				<br/>
				<li>
					Execute the instruction.  Operand values are routed to the appropriate arithmetic and logic hardware.  Results are computed and routed to their appropriate destinations.  Appropriate destinations include the general-purpose registers, special purpose registers such as the program counter (in the case of <span class="Subfigure">BRANCH</span> and <span class="Subfigure">JUMP</span>instructions) and main memory.
				</li>
				<br/>
				<li>
					Return to Step 1.
				</li>
			</ol>
			
			<p>
				That’s all a computer ever does.
			</p>
			
			<p>
				To execute the program of Figure 11.28 a three (0000 0011<span class="Subscript">two</span>) must first be loaded into the Watson Virtual Machine program counter.  The reason for this is that the first executable instruction of the program is located at memory address three.
			</p>
			
			<p>
				As the program runs, the machine will faithfully execute the instruction cycle.  First, the instruction “0001 1101 0000 0001” will be loaded into the instruction register.  The program counter will then be incremented from three to four.  Next, the instruction is decoded to mean “load into register D the value stored at memory location one”.  The value at location one will then be loaded into register D.  Since location one was initialized to a two as part of the construction of the program’s data segment, that value will be copied into register D.  Having completed the execution of the current instruction, the machine will return to step one of the instruction cycle.
			</p>
			
			<p>
				At this point, the Watson Virtual Machine copies into the instruction register the statement held at memory location four.  The program counter is then incremented to five, so that it points to the next instruction in the current sequence.  The contents of the instruction register “0001 1110 0000 0010” are then decoded to mean “load into register E the value stored at memory location two”.  This instruction is then executed – placing the value three into register E.  Next, the machine returns to the first step in the instruction cycle.
			</p>
			
			<p>
				The instruction cycle repeats itself on statement after statement, until a <span class="Subfigure">HALT</span> instruction is executed (or the instruction cycle is interrupted by outside influences – such as someone hitting the reset button or tripping over the power cord).
			</p>
			
			<p>
				And so, that’s it.  We have arrived at the bare machine that lies underneath the many layers of software.  There is no magic.  No smoke and mirrors.  Just a simple – but very fast – machine running through the instruction cycle over and over, tens or hundreds of millions of times each second. 
			</p>
			
			<p class="Section">
				Exercises for Section 11.5
			</p>
			
			<ol>
				<li>
					Translate the program of Figure 11.4 from the assembly language level to the machine language level.
				</li>
				<br/>
				<li>
					Trace through the program of Figure 11.4 outlining the actions taken during each pass through the instruction cycle.  Be sure to clearly indicate any changes made to the values held in registers or main memory locations.
				</li>
				<br/>
				<li>
					Translate the program of Figure 11.5 from the assembly language level to the machine language level.
				</li>
				<br/>
				<li>
					Given the following machine language program, reassemble it into a Watson assembly language program.  Note that the program is assumed to be stored at the top of memory, beginning in location zero, and the first executable statement occurs on the <span class="Ital">second</span> line of code.
					<br/>
					<br/>
					<img src="Images/AssemblyIMGS/ex11-5-num4.png" alt="" class="Image">
					
			<!--table of stuff
			<table border="0" cellspacing="0" cellpadding="0" class="Table71">
			<colgroup><col width="63"/><col width="63"/><col width="63"/><col width="64"/></colgroup><tr class="Table711"><td style="text-align:left;width:0.5653in; " class="Table71_A1"><p class="Subfigure">0000</p></td><td style="text-align:left;width:0.566in; " class="Table71_A1"><p class="Subfigure">0000</p></td><td style="text-align:left;width:0.5653in; " class="Table71_A1"><p class="Subfigure">0000</p></td><td style="text-align:left;width:0.5729in; " class="Table71_D1"><p class="Subfigure">1010</p></td></tr><tr class="Table711"><td style="text-align:left;width:0.5653in; " class="Table71_A1"><p class="Subfigure">0001</p></td><td style="text-align:left;width:0.566in; " class="Table71_A1"><p class="Subfigure">1010</p></td><td style="text-align:left;width:0.5653in; " class="Table71_A1"><p class="Subfigure">0000</p></td><td style="text-align:left;width:0.5729in; " class="Table71_D1"><p class="Subfigure">0000</p></td></tr><tr class="Table711"><td style="text-align:left;width:0.5653in; " class="Table71_A1"><p class="Subfigure">1010</p></td><td style="text-align:left;width:0.566in; " class="Table71_A1"><p class="Subfigure">1010</p></td><td style="text-align:left;width:0.5653in; " class="Table71_A1"><p class="Subfigure">1010</p></td><td style="text-align:left;width:0.5729in; " class="Table71_D1"><p class="Subfigure">0001</p></td></tr><tr class="Table711"><td style="text-align:left;width:0.5653in; " class="Table71_A1"><p class="Subfigure">0010</p></td><td style="text-align:left;width:0.566in; " class="Table71_A1"><p class="Subfigure">1010</p></td><td style="text-align:left;width:0.5653in; " class="Table71_A1"><p class="Subfigure">0000</p></td><td style="text-align:left;width:0.5729in; " class="Table71_D1"><p class="Subfigure">0000</p></td></tr><tr class="Table711"><td style="text-align:left;width:0.5653in; " class="Table71_A1"><p class="Subfigure">1111</p></td><td style="text-align:left;width:0.566in; " class="Table71_A1"><p class="Subfigure">0000</p></td><td style="text-align:left;width:0.5653in; " class="Table71_A1"><p class="Subfigure">0000</p></td><td style="text-align:left;width:0.5729in; " class="Table71_D1"><p class="Subfigure">0000</p></td></tr></table>
				-->
				</li>
				<br/>
				<li>
					Describe what the program of problem 4 does.  Do so using a single English sentence that even your grandmother could understand.
				</li>
			</ol>
		
			<br/>
			<!-- Footnotes -->
			<hr/>
			<p class="Section">
				Footnotes
			</p>
		
			<p class="Footnote"><span class="footnodeNumber"><a class="Footnote_20_Symbol" id="ftn1" href="#body_ftn1">[1]</a></span> Represented as two’s complement binary numbers.  See Section 11.4.1 for details.</p>
			
			<p class="Footnote"><span class="footnodeNumber"><a class="Footnote_20_Symbol" id="ftn2" href="#body_ftn2">[2]</a></span> It should be noted that true JavaScript, as well as many other common programming languages, like Java and C++, do support the ability to declare and initialize variables in a single statement.</p>
			
			<p class="Footnote"><span class="footnodeNumber"><a class="Footnote_20_Symbol" id="ftn3" href="#body_ftn3">[3]</a></span> There are other, more efficient, ways of solving this problem that will become apparent during the discussion of data representation and manipulation in Section 11.4.1.3.</p>
			
			<p class="Footnote"><span class="footnodeNumber"><a class="Footnote_20_Symbol" id="ftn4" href="#body_ftn4">[4]</a></span> We’ll hold off on subtraction until we discuss ways of representing negative numbers in the next part of this section.</p>
			
			<p class="Footnote"><span class="footnodeNumber"><a class="Footnote_20_Symbol" id="ftn5" href="#body_ftn5">[5]</a></span> Well, as pointed out earlier, actually -2,147,483,648 to 2,147,483,647</p>
			
			<p class="Footnote"><span class="footnodeNumber"><a class="Footnote_20_Symbol" id="ftn6" href="#body_ftn6">[6]</a></span> Which is, of course, quite different from the ASCII representation of the characters “H” and “i”.</p>
			
			<p class="Footnote"><span class="footnodeNumber"><a class="Footnote_20_Symbol" id="ftn7" href="#body_ftn7">[7]</a></span> Memory address 0000 0001<span class="Subscript">two</span> is the second location in memory.  The first location is labeled memory address 0000 0000<span class="Subscript">two</span>.</p>
		
			<p class="Emphasized">
				<a href="#tippytop">Return to top</a>
			</p>
			<!-- End Main content -->
			<nav>
				<p>
					--
				</p>
				<p>
					<a href="index.html">Home</a>
				</p>
				<p>
					<a href="mailto:someone@example.com?Subject=Hello%20again" target="_top"> Contact</a>
				</p>
			</nav>
		</div>
	</body>
</html>
