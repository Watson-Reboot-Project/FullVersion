<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">

		<!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame
		Remove this if you use the .htaccess -->
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

		<title>Watson</title>

		<!-- Google fonts -->
    <link href='http://fonts.googleapis.com/css?family=Exo+2' rel='stylesheet' type='text/css'>
		<!-- CSS files -->
	    <link href = "../lib/images/favicon.ico" rel="icon" type="image/png">
		<link href="../lib/css/bootstrap.css" rel="stylesheet">
		<link href="../lib/css/styles.css" rel="stylesheet">
		<link href="../lib/css/generalmedia.css" rel="stylesheet">
		
    <!-- Java Script files -->
    <script type="text/javascript" src="../lib/js/jquery-1.10.2.min.js"></script>
    <script type="text/javascript" src="../lib/js/bootstrap.min.js"></script>
		<script type="text/javascript" src="../lib/js/master.js"></script>
		<script type="text/javascript" src="../lib/js/Numbering.js"></script>
		<script type="text/javascript" src="../lib/js/Miscellaneous.js"></script>
		<script type="text/javascript" src="../lib/js/nav.js"></script>

		<meta name="viewport" content="width=device-width; initial-scale=1.0">

	</head>

	<body>
		<!-- Navbar -->
		<div id="includedContentForPage"></div>
		<!-- End Navbar -->
		
		<div id="wrapper" class="page-wrapper">
			<a id="tippytop"></a>
			<!-- Header division -->

			<!-- Navbar -->
			<div id="includedContentForPage"></div>
			<!-- End Navbar -->

			<!-- Main content -->
			<p class="Section">
				<span class="contentNum scienceFour2"></span>
			</p>
	
			<p>
				Now that we have talked about some of the many things computers are used for, the question that naturally arises is “How are computers able to accomplish all of these different tasks?”  The first thing to understand is that computer systems are composed of two major components: hardware and software.  <span class="Bolded">Hardware</span> consists of the actual electronic components that make up a computer.  
			</p>
	
			<p>
				Unlike hardware, computer software is completely abstract.  It has no physical existence.  You cannot see, hear, touch, smell, or taste software.  Although it has no physical existence, software is real – as real as the color red, or the number five, or the concept of beauty.  One way to think of software is as “codified thought.”  
			</p>
	
			<p>
				More formally, <span class="Bolded">software</span> consists of computer programs and the data on which they act.  <span class="Bolded">Computer programs</span> are algorithms expressed in a form that is executable by computers.  As mentioned earlier, an <span class="Bolded">algorithm</span> is a detailed sequence of steps that specifies how to solve a problem or accomplish some task.  So, computer programs are just sequences of instructions that a computer can follow to solve a problem or accomplish a task.  
			</p>
	
			<p>
				It is important to note that the terms “program” and “algorithm” are not synonymous.  A description of how to sort a list of numbers is an algorithm.  For example, here is the selection sort algorithm:
			</p>
	
			<ul class="Blockcenter">
				<li>
					Step 1:  Remove the smallest item from the input list.
				</li>
	
				<li>
					Step 2:  Append this smallest item to the end of an output list.
				</li>
	
				<ul class="Subblockcenter">
					<li>
						(This output list will be empty when you first begin.)
					</li>
				</ul>
	
				<li>
					Step 3:  Repeat the above two steps until the input list is empty.
				</li>
			</ul>

			<p>
				This sorting procedure is not a computer program, since it is written in English, rather than being expressed in a form that can be recognized by a computer.  
			</p>

			<p>
				Algorithms, including procedures for searching and sorting, are discussed in Chapter <span class="contentNum algorithms false"></span>.  Chapter <span class="contentNum graphics false"></span> continues our exploration of algorithms by introducing a language for drawing simple graphical images.  A Watson lab is included so that you can write programs in this language in order to create drawings and animation sequences.
			</p>

			<p>
				Computer programs must be written in programming languages, such as Java, C++, JavaScript, or Visual BASIC.  <span class="Bolded">Programming languages</span> are formal systems for precisely specifying algorithms and their associated data structures in a form that can be recognized by a computer.  By “formal” we mean these languages are based on sets of rules that dictate how instructions must be formed and interpreted.  Programming languages are designed in such a way as to eliminate the ambiguity for which natural languages, such as English, are notorious.
			</p>

			<p>
				Computer programs operate on data.  <span class="Bolded">Data</span> are the symbols, usually characters, or groups of characters, used to represent information that has meaning to people.  The words and pictures making up this book are data.  The meaning they convey to you as you read them is information.  One of the fascinating aspects of computers is that they have the ability to manipulate symbols without needing to understand the meaning of those symbols.  My word processing program allows me to edit this text, even though it cannot read English and has no notion of the meaning of these words.  
			</p>
	
			<p>
				Computer programs read input data, manipulate that data in some way, and produce output.  A program of any complexity will need ways of organizing, or structuring, that data.  Hence, an understanding of data structures is critical to understanding computer software.  A <span class="Bolded">data structure</span> is a collection of data together with a group of operations that manipulate that data in certain predefined ways.  For example, the <span class="Bolded">queue</span> is a standard data structure that models a waiting line.  It supports two basic operations enqueue and dequeue.  “Enqueue” adds an item to the end of the waiting line.  “Dequeue” removes an item from the front of the waiting line.  Chapter <span class="contentNum structures false"></span> examines a variety of data structures, including stacks, queues, lists, and trees.  The Watson lab associated with that chapter will allow you to directly experiment with the behavior of a number of these data structures. 
			</p>

			<p>
				Chapters <span class="contentNum javascript false"></span> and <span class="contentNum objects false"></span>  continue the study of software by examining the major types, or paradigms, of programming languages.  A <span class="Bolded">paradigm</span> is a way of thinking about a problem or modeling a problem solution.  There are at least three identifiable programming paradigms: the imperative paradigm, the functional paradigm, and the logical paradigm.  Some computer scientists view object-oriented programming as a fourth paradigm.  Others prefer to view objects as an extension to the imperative, functional, and logical paradigms.  Regardless, all four of these approaches are covered in the text – the imperative approach in Chapter <span class="contentNum javascript false"></span>, the functional, logical, and object-oriented approaches in Chapter <span class="contentNum objects false"></span>.  A Watson lab has been constructed for the imperative paradigm.  This lab will help you gain additional insight into writing computer programs.
			</p>

			<p>
				The vast majority of programs are written in imperative languages.  C++, Java, JavaScript, Perl, BASIC, Fortran, C, Pascal, Ada, Modula-2, and COBOL are all imperative languages.  The <span class="Bolded">imperative paradigm</span> derives its name from the fact that statements in imperative languages take the form of commands.  In English, imperative sentences, such as “eat your vegetables” or “take out the trash” are commands where the subject is understood to be “you” – “You take out the trash.”  Imperative programming languages are similar in that each statement is a command instructing the computer to perform some action.  An example of a statement written in the Watson Imperative Language is:
			</p>
	
			<p class="Subfigure">
				write( “What’s up Doc?”);
			</p>
	
			<p>
				which instructs the computer to write the phrase “What’s up Doc?” on the display screen.
			</p>

			<p>
				The <span class="Bolded">functional paradigm</span> is patterned after the mathematical concept of a function.  A <span class="Bolded">function</span> defines a mapping from inputs (i.e., the domain) to outputs (i.e., the range) in which a particular input sequence always maps to the same output.  Addition is an example of a function.  Simple addition takes a sequence of two numbers as input and produces a single number as output (e.g., 5 + 4 equals 9).  Notice that since addition is a function, the same input sequence always produces the same output.  This means, for example, that 5 + 4 must always equal 9 and never anything else.  While a particular input sequence must always generate the same output, it is often true that a function will map many different input sequences to the same output.  So, while 5 + 4 must always equal 9, so can 6 + 3 and 7 + 2 and 993 + -984.  Another key characteristic of functions is that they always return one, and only one, result.
			</p>

			<p>
				In the functional paradigm, statements are functions to be evaluated.  This is different from the imperative paradigm in which statements are commands to be executed.  As a result, functional programs tend to take on the form of nested expressions, rather than sequences of commands.  Another difference between imperative and functional programs is that imperative languages generally store the results of computations in declared variables.  Functional languages avoid the use of declared variables.  Instead, values are computed as needed.  An example will help to illuminate these differences.
			</p>

			<!-- Format -->
			<ul class="Blockcenter">
				<li><span class="Subfigure">read (tempc);</span></li>
				<li><span class="Subfigure">tempf = (1.8 * tempc) + 32;</span></li>
				<li><span class="Subfigure">write(tempf);</span></li>
			</ul>
			<p class="Figure">(a) A code fragment written in the imperative style </p>
			<ul class="Blockcenter">
				<li><span class="Subfigure">(write(add (multiply 1.8 (read)) 32))</span></li>
			</ul>
			<p class="Figure">(b) A code fragment written in the functional style</p>
	
			<p class="Figure">
				<span class="figNum paradigms"></span> Examples of the functional and imperative paradigms
			</p>

			<p>
				<!--Figure--> <span class="figNum paradigms"></span> illustrates two implementations of an algorithm for converting temperature readings from Celsius to Fahrenheit.  Part (a) contains an imperative version of the algorithm while part (b) contains a functional version of the same algorithm.  Both code fragments do the same thing: read a temperature; multiply that temperature by 1.8; add 32 to the result; and then display the final answer.  
			</p>
	
			<p>
				Don’t worry if some of the details of this example elude you.  Chapters <span class="contentNum javascript false"></span> and <span class="contentNum objects false"></span> discuss imperative and functional programming much more thoroughly.  At this point all you need to recognize is that the various paradigms can produce quite different programs, even if those programs are based on the same underlying algorithm.
			</p>

			<p>
				Lisp is an example of a programming language that belongs to the functional paradigm.  Surprisingly, even though Lisp is functional, its major use is not to perform mathematical computations.  Instead, Lisp is mainly used for what is called symbolic processing.  That is to say, Lisp is good for manipulating symbols, such as words, that represent concepts and ideas.  For this reason, Lisp is often used in the study of artificial intelligence, which attempts to build computer programs capable of displaying “human-like” intelligence.  
			</p>

			<p>
				The logical paradigm, exemplified by the language Prolog, is another alternative to the standard imperative paradigm.  The <span class="Bolded">logical paradigm</span> is a style of programming based on predicate logic.  Programs written in this paradigm strive not to be simple encodings of algorithms, but instead to be precise statements of the problem to be solved.  <span class="Bolded">Predicate logic</span> is a formal system for deriving logically valid conclusions from a consistent set of facts and rules.  Since the system is formal, the process of reasoning can be automated using techniques such as resolution theorem proving.  Like Lisp, Prolog is often used in the study of artificial intelligence.
			</p>

			<p>
				In essence, the programmer’s task in logic programming is to provide the computer with the pertinent facts and rules that describe the important aspects of a problem.  It is then the responsibility of an automated system, called the program interpreter or inference engine, to determine how the problem is to be solved.  This focus on describing <span class="Ital">what</span> the problem is, is in sharp contrast to the imperative approach in which the program directly encodes <span class="Ital">how</span> the problem is to be solved.  Because statements in logic-based languages represent declarations that are assumed to be true, rather than commands to be performed, this approach is sometimes referred to as the declarative paradigm.  Logic programming is further explored in Chapter <span class="contentNum objects false"></span>.  
			</p>

			<p>
				The <span class="Bolded">object-oriented approach</span> adds the concepts of objects and messages to the above paradigms.  Essentially, programs and the data on which they act are viewed as objects.  In order to perform a task an object must receive a message indicating that work needs to be done.  The object-oriented approach is well suited for implementing modern “point and click” program interfaces.  These interfaces consist of a number of graphical symbols, called <span class="Bolded">icons,</span> that are displayed on the screen.  Whenever a user clicks the mouse pointer on one of these icons, such as a button or scrollbar, a message is sent to the corresponding program object, causing it to execute.  Other distinguishing characteristics of object-oriented programs, including inheritance, polymorphism, and data encapsulation; are discussed in Chapter <span class="contentNum objects false"></span>.
			</p>

			<p>
				So far in this discussion of software, we have talked about algorithms, data structures, and programming paradigms.  Chapter <span class="contentNum engineering false"></span> focuses on a topic critical to the development of large computer programs – the topic of software engineering.  <span class="Bolded">Software engineering</span> is the study of the design, construction, and maintenance of large software systems.  
			</p>
	
			<p>
				As the hardware capabilities of computers have increased, so have the expectations for the performance of software.  We expect programs to be friendly, easy to use, reliable, well documented, and attractive. Meeting these expectations often increases the size and complexity of a program.  Thus, over time, the average size of programs has tended to increase.
			</p>
	
			<p>
				Many software systems represent a significant number of person-years of effort and are written by large teams of programmers.  These systems are so vast that they are beyond the comprehension of any single individual.  As computer systems become more and more intertwined into the fabric of modern life, the need for reliable software steadily increases.  As an example take the long distance telephone network.  This system consists of millions of lines of code written by thousands of people over decades – yet, it is expected to perform with complete reliability 24 hours a day, 7 days a week.  
			<p>

			<p>
				Unfortunately, whereas the scaling up of hardware has been a straightforward engineering exercise, software production cannot be so easily increased to meet escalating demand.  This is because software consists of algorithms that are essentially written by hand, one line at a time.  As the demands of increasing reliability and usability have led to software systems that can not be understood by a single person, questions concerning the organization of teams of programmers have become critical.
			</p>
	
			<p>
				These managerial issues are complicated by the unique nature of software production.  Programming is a challenging task in its own right, but its complexity is increased many fold by the need to divide a problem among a large group of workers.  How are such projects planned and completion dates specified?  How can large projects be organized so that individual software designers and programmers can come and go without endangering the stability of the project?  These are just some of the questions addressed by software engineering.
			</p>

			<p>
				One of the cornerstones of software engineering is the <span class="Bolded">software lifecycle</span>: a model of how software is developed, used, maintained over time, and eventually discarded.  This model is helpful in predicting costs and allocating programming resources, but it suffers from inflexibility.  This inflexibility has led to the adoption of alternative software development models in recent years, such as rapid prototyping.  Newer models tend to focus on improving user satisfaction with the software (e.g., making programs more usable and user-friendly).
			</p>

			<p>
				In addition to managing the development of individual software projects, software engineers also design tools for automating portions of the software development process.  For example, tools to assist with the creation of program documentation and testing are now common.  Such tools are often referred to as CASE tools, where CASE stands for Computer Aided Software Engineering.  
			</p>

			<div class="push"></div>
				
		</div> <!-- End wrapper -->

		<div class="blueFooterBar"></div> <!-- populates the bottom footer -->	

			<!-- Arrow navigation scripts -->
			<script>
				var pageObj;											// do NOT change name of variable
				var chapID = "science";
				
				$(document).ready(function() {
					populateNav();										// populate nav content
					populateSpans();									// populate figure/content spans
					pageObj = getArrowPathsByPage("scienceFour2");		// get arrow paths
					if (!localFlag) runGA();
				});	

			</script>
	</body>
</html>
